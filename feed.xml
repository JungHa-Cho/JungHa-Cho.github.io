<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>개발하는 조롱이</title>
  
  <subtitle>조롱이 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://jungha-cho.github.io/"/>
  <updated>2018-05-12T08:22:37.883Z</updated>
  <id>http://jungha-cho.github.io/</id>
  
  <author>
    <name>cho_jeong_ha</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>리팩토링 (7)</title>
    <link href="http://jungha-cho.github.io/2018/05/12/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-7/"/>
    <id>http://jungha-cho.github.io/2018/05/12/리팩토링-7/</id>
    <published>2018-05-12T08:14:03.000Z</published>
    <updated>2018-05-12T08:22:37.883Z</updated>
    
    <content type="html"><![CDATA[<h1>고객의 서버에 설치되는 비즈니스용 CLIENT 프로그램의 모니터링 개발</h1><ul><li>개발 카테고리에 작성해야 겠지만… 기존에 존재하던 프로그램에 웹 방식의 모니터링 프로그램을 개발해야 하는것임으로 리팩토링으로 넣었다.</li></ul><h1>필요성</h1><ul><li>고객의 요구사항이라거나 오너나 상급자의 지시가 아닌 편의성을 위해 개발을 진행함</li><li>고객의 문의 사항 중 대부분이 자신이 발송한 데이터의 개수나 통계자료를 간단히 보고 싶어 함</li></ul><h1>Jetty</h1><ul><li>경량 웹 프레임워크도 찾아보고 이것저것 많이 찾아봤지만, 프로젝트 자체가 WEB 기반이 아니라 embed 할 수 있는 기능이 필요했고, 주 기능이 아니므로 코딩 양 또한 많지 않아야 했다.</li><li>간단하게 Servlet 클래스 몇가지를 만들어 Data Base나 JVM, 프로그램 자체 비즈니스 정보를 뽑아 출력</li></ul><h1>Data Base</h1><ul><li>웹이 주 기능이 아니라 수많은 웹 기능을 넣을순 없었고 최대한 심플하게 필요한 정보만 전달하기 위한 웹 화면을 구성함</li><li>그 중 Data Base에 접근해 고객사 정보들을 SELECT하고 COUNT를 세는 등 Data Base 작업이 필요한 것들은 REFRESH에 포함시키지 않고, 버튼을 이용해 Data Base에 최대한 접근성을 줄이려 함</li><li>무엇보다 이것은 주 기능이 아니라 편의성을 위한 것임으로…</li></ul><h1>JVM</h1><ul><li>대신 JVM 쪽들은 모두 웹 화면에서 10초 간격으로 REFRESH 가능하게 자체 정책을 채웠으며, LOCAL TIME이나 프로그램 총 실행시간, JVM 메모리 정보, 쓰레드 상태, 서비스 상태등이 여기에 해당함.</li></ul><h1>블록형 웹 화면 구성</h1><ul><li>하나의 웹 화면에 필요한 정보를 효율적으로 표시해야 했음</li><li>한 화면에 블록 형태의 구분 영역을 만들고 한개의 블록은 하나의 정보만 표시함</li></ul><h1>무엇보다 모니터링 웹 페이지는 주 기능이 아님</h1><ul><li>이 리팩토링의 핵심은 편의성이고, 간단하게 CLIENT 프로그램의 동작 상태를 확인할 수 있는 페이지면 충분하기에 불필요한 모든 부분을 최소화 하기로 했음</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;고객의 서버에 설치되는 비즈니스용 CLIENT 프로그램의 모니터링 개발&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;개발 카테고리에 작성해야 겠지만… 기존에 존재하던 프로그램에 웹 방식의 모니터링 프로그램을 개발해야 하는것임으로 리팩토링으로 넣었다.&lt;/li&gt;
&lt;/
      
    
    </summary>
    
      <category term="업무" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>리팩토링 (6)</title>
    <link href="http://jungha-cho.github.io/2018/05/10/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-6/"/>
    <id>http://jungha-cho.github.io/2018/05/10/리팩토링-6/</id>
    <published>2018-05-10T05:44:16.000Z</published>
    <updated>2018-05-10T08:12:27.257Z</updated>
    
    <content type="html"><![CDATA[<h1>멀티 스레드 환경에서 스레드 중단 및 복구, 종료</h1><ul><li>멀티 스레드 환경에서 스레드 관리자의 리팩토링 전에 <code>Java Concurrency In Practice</code>의 7장 중단 및 종료를 복습하기로 함</li></ul><h1>자바에서 스레드의 종료</h1><ul><li>자바에서 스레드가 작업을 실행하고 있을 때 강제로 멈추도록 하는 방법이 없다.</li><li>물론 예전에는 있었다. Thread.stop()과 Thread.suspend()가 해당 기능을 제공하려 했는데, 지금은 <code>deprecated</code>되었다.</li></ul><h2>종료</h2><h3>사용자가 취소하기를 요청한 경우</h3><ul><li>사용자가 직접 GUI에서 취소 버튼을 클릭하거나, 관리 인터페이스를 통해 작업을 취소하도록 요청한 경우.</li></ul><h3>시간이 제한된 작업</h3><ul><li>일정한 시간 이내에 답이 될만한 결과를 계속해서 찾고 있다가, 제한된 시간이 지나면 그 동안 찾았던 결과 가운데 가장 좋은 값을 사용하도록 하는 프로그램</li></ul><h3>애플리케이션 이벤트</h3><ul><li>원하는 결과를 얻기 위해 다양한 조건을 지정해 여러 작업을 동시에 실행하던 중 원하던 값을 얻으면 나머지 실행중이던 작업을 모두 취소한다.</li></ul><h3>오류</h3><h3>종료</h3><h2>취소 요청이 들어올때까지 계속해서 소수를 찾아내는 작업을 진행하고, 취소 요청 플래그를 사용해 작업을 멈춘다.</h2><ul><li>안정적인 동작을 위해서는 cancelled 플래그가 volatile로 선언되어 있어야 한다.</li></ul><script src="//gist.github.com/a764693fb55983aee2df9e43d31c8b81.js?file=PrimeGenerator.java"></script><h2>소수 계산 작업 스레드를 실행시킨 다움 1초 후에 소수 계산 작업을 멈춘다.</h2><ul><li>이렇게 종료하게 되면, 반드시 1초후에 종료하는 것을 보장하지 않는다.</li><li>취소 요청 후 나머지 작업을 진행하기 위한 최소한의 시간이 필요하기 때문이다.</li><li>finally 구문 때문에, 슬립 도중 인터럽트가 걸려도, cancel은 반드시 호출 된다.</li></ul><script src="//gist.github.com/a764693fb55983aee2df9e43d31c8b81.js?file=aSecondOfPrimes.java"></script><h2>작업을 취소하려 할때에는 <code>취소 정책</code>이 명확해야 한다.</h2><ul><li>외부 프로그램에서 작업을 취소하려 할 때 어떤 방법으로 취소 요청을 보낼 수 있는지, 작업 내부에서 취소 요청이 들어 왔는지를 언제 확인하는지, 취소 요청이 들어오면 실행 중이던 작업이 어떤 형태로 동작하는지 등에 대한 정보를 제공해야 안전하게 사용할 수 있다.</li></ul><h1>인터럽트</h1><ul><li>스레드 내부에서 블로킹 되는 부분이 있다면, 큰 문제가 발생 할 수 있다.</li><li>취소 요청이 들어왔는지 확인을 하지 못하는 경우가 생길 수 도 있으며, 영원히 종료되지 않는 프로그램이 되어버릴 수도 있다.</li></ul><blockquote><p>interrupt 메소드는 인터럽트를 걸고, isInterrupted는 해당 스레드에 인터럽트가 걸려 있는지 체크가 가능하며, interrupted 메소드를 호출하면 스레드의 인터럽트 상태를 해제하고, 해제 이전 값을 돌려준다.</p></blockquote><h1>인터럽트에 응답하지 않는 블로킹 작업</h1><ul><li>InputStream, OutputStream은 인터럽트에 반응하지 않는다.</li></ul><h1>스레드 기반 서비스 중단</h1><ul><li></li></ul><h1>Thanks to 객체 관련 책들!</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;멀티 스레드 환경에서 스레드 중단 및 복구, 종료&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;멀티 스레드 환경에서 스레드 관리자의 리팩토링 전에 &lt;code&gt;Java Concurrency In Practice&lt;/code&gt;의 7장 중단 및 종료를 복습하기로 함&lt;/l
      
    
    </summary>
    
      <category term="업무" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>2018-05-08 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/05/08/2018-05-08-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/05/08/2018-05-08-독서-일지/</id>
    <published>2018-05-08T13:20:01.000Z</published>
    <updated>2018-05-08T13:55:50.561Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>예외는 예외적 상황에서만 사용하라.</h1><h1>복구 가능 상태에는 점검 지정 예외</h1><h1>프로그래밍 오류에는 실행 시점 예외</h1><h1>예외 연결 지원 생성자를 갖추면 로우 레벨 익셉션을 잡아 추상화 수준에 맞게 변환할 수 있고, 스택 정보도 통합된다.</h1><h1>병렬성</h1><h2>변경 가능 공유 데이터에 대한 접근은 동기화 하라.</h2><h2>동기화 영역 안에서 수행되는 로직은 최대한 줄여라</h2><h2>쓰레드 안전성에 대해 문서로 남겨라.</h2><h1>Reference</h1><ul><li><p>조슈아 블로크 지음, 이병준 옮김 『 Effective Java 2nd edition 』, 인사이트(2014. 09. 01), 인용.</p></li><li><p>스티브 맥코넬 지음, 서우석 옮김 『 코드 컴플리트 2nd edition 』, 위키북스(2017. 07. 28), 인용.</p></li><li><p>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</p></li><li><p>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</p></li><li><p>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;예외는 예외적 상황에서만 사용하라.&lt;/h1&gt;
&lt;h1&gt;복구 가능 상태에는 점검 지정 예외&lt;/h1&gt;
&lt;h1&gt;프로그래밍 오류에는 실행 시점
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>2018-05-07 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/05/07/2018-05-07-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/05/07/2018-05-07-독서-일지/</id>
    <published>2018-05-07T13:32:51.000Z</published>
    <updated>2018-05-07T13:42:35.052Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>어떤 라이브러리가 있는지 파악하고, 적절히 활용하라</h1><ul><li>표준 라이브러리 (standard library) 를 사용하면, 그 라이브러리를 개발한 전문가의 지식 뿐만 아니라 여러분보다 먼저 그 라이브러리를 사용한 사람들의 경험을 활용할 수 있다.</li><li>중복의 해악이랑 같은 맥락이지만, 이건 라이브러리 활용 측면에서 장점을 얘기하고 있는듯</li></ul><h1>정확한 답이 필요하다면 float과 double는 피하라.</h1><ul><li>float과 double는 정확한 결과는 제공하지 않는다.</li></ul><h1>문자열 연결 시 성능에 주의하라</h1><h1>객체를 참조할 때는 그 인터페이스를 사용하라.</h1><ul><li>인터페이스를 자료형으로 쓰는 습관을 들이면 프로그램은 더욱 유연해진다.</li></ul><blockquote><p>ex List 구현체인 Vector를 사용하더라도 Vector가 아닌 ArrayList로 교체하면, 나머지 코드는 그대로 동작한다.</p></blockquote><h1>Reference</h1><ul><li><p>조슈아 블로크 지음, 이병준 옮김 『 Effective Java 2nd edition 』, 인사이트(2014. 09. 01), 인용.</p></li><li><p>스티브 맥코넬 지음, 서우석 옮김 『 코드 컴플리트 2nd edition 』, 위키북스(2017. 07. 28), 인용.</p></li><li><p>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</p></li><li><p>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</p></li><li><p>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;어떤 라이브러리가 있는지 파악하고, 적절히 활용하라&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;표준 라이브러리 (standard library) 를 사
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>리팩토링 (5)</title>
    <link href="http://jungha-cho.github.io/2018/05/04/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-5/"/>
    <id>http://jungha-cho.github.io/2018/05/04/리팩토링-5/</id>
    <published>2018-05-04T13:15:31.000Z</published>
    <updated>2018-05-04T13:25:33.539Z</updated>
    
    <content type="html"><![CDATA[<h1>리팩토링 후기</h1><ul><li>처음부터 끝가지 변수명부터 시작해서 메소드 이름, 클래스 이름 그리고 불필요한 클래스를 감추거나 인스턴스화 시켜서 필요한 순간에만 사용하게끔 만들었다.</li><li>불필요한 상속으로 추상화 단계만 복잡하게 만들어져 있던 메인 로직을 단순화 시키고 수정하고, 코드 품질을 올리기 위해 부단히 노력했다.</li><li>아직은 필요 이상으로 덩치가 큰 클래스가 보이고, 비즈니스상 얽히고설켜 큰 흐름으로 따라가야만 로직의 큰 줄기를 파악할 수 있기 때문에 패키지로 분류하고, 클래스로 분류한뒤 클래스 두개를 합치거나, 추상화 수준을 맞추기 위해 정확한 한가지 책임을 지고 역활을 하는 클래스로 분리하기도 하고 있다.</li></ul><h1>처음 시작할땐 막막해 보이던게 리팩토링을 진행하면 할수록 확신이 든다. 소프트웨어는 살아 있다.</h1><ul><li>무슨 말이냐면, 관심도 주지않고 <code>동작하니까</code> 넌 됐어. 정도의 애정을 가지고 있으면, 그 코드는 죽은 코드다.</li><li>리팩토링을 마음먹고 내가 봐도 흐뭇한 코드가 될때까지 닦고 조이고 기름치다 보니 <code>input</code>이 들어오면 <code>output</code>을 내는 한낱 소프트웨어일 뿐이지만 <code>티코</code>가 무리하게 속도를 내는 소프트웨어가 아니라 <code>소나타</code> 정도 되는 중형 세단이 마음먹고 속도를 내는 느낌이다.</li><li>구조는 착 잡혀 있으며, 한눈에 보기도 쉽게 분류를 잘 진행했고, 실제로 해당 코드를 처음보는 사람에게도 검수를 받아봤다.</li><li>이제 <code>소나타</code>가 아니라 <code>벤틀리</code>로 변신할 차례다.</li></ul><h1><code>벤틀리</code> 소프트웨어를 만들기 위해서는?</h1><ul><li>음… 아직도 고심하고 있는 부분인데, 지금 갓 클래스를 분류하고 인스턴스화 할수 있는 객체로 분리하면서 <code>Dependency Injection</code>에 많은 신경을 썼다.</li><li>어떤 특정한 일을 하는 클래스를 인스턴스화 할때 필요한 변수들을 주입받고 그때 자기 역할만 수행하고 가비지 컬렉터에게 수집을 당해버리는 클래스 말이다.</li><li>이걸 왜 하냐면… 처음부터 테스트 코드가 같이 작성된 소프트웨어가 아니다 보니, 테스트 코드를 작성하고 싶어도 작성할 수 없는 수준의 소프트웨어였다.</li><li>DI에 신경을 쓰면, 테스트 가능한 클래스들이 많아질 것이고, 이걸 바탕으로 자동화 테스트를 작성하려고 계획중이기 때문이다.</li><li><code>벤틀리</code>가 소프트웨어 그 자체라면… 테스트 코드는 <code>벤틀리</code>가 잘 달릴 수 있는 <code>도로</code> 쯤으로 생각하면 될까?</li></ul><h1>Thanks to 객체 관련 책들!</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;리팩토링 후기&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;처음부터 끝가지 변수명부터 시작해서 메소드 이름, 클래스 이름 그리고 불필요한 클래스를 감추거나 인스턴스화 시켜서 필요한 순간에만 사용하게끔 만들었다.&lt;/li&gt;
&lt;li&gt;불필요한 상속으로 추상화 단계만 복잡
      
    
    </summary>
    
      <category term="업무" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>2018-05-03 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/05/03/2018-05-03-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/05/03/2018-05-03-독서-일지/</id>
    <published>2018-05-03T13:26:54.000Z</published>
    <updated>2018-05-03T14:04:09.666Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>메서드 시그니처는 신중하게 설계하라.</h1><ul><li>Standard Naming Convention 룰을 따르라.</li><li>자바 API 이름을 참고하라.</li></ul><h1>오버로딩할 때는 주의하라.</h1><h1>Varargs는 신중히 사용하라.</h1><ul><li>가변인자</li></ul><h1>null 대신 빈 배열이나 컬렉션을 반환하라</h1><h1>지역 변수의 유효 범위를 최소화하라</h1><ul><li>코드 가독성은?.. 나빠지는게 아닐까?</li><li>핵심은 이것인 것같다. 메서드의 크기를 줄이고 특정한 기능에 집중하라는 것!</li></ul><h1>for 문 보다는 for-each 문을 사용하라.</h1><h1>고질병이 도지는것 같네… 한두달 바짝 불태우고 흥미가 바짝 떨어지는것…</h1><h1>학습에 터닝포인트가 필요하다.</h1><h1>Reference</h1><ul><li><p>조슈아 블로크 지음, 이병준 옮김 『 Effective Java 2nd edition 』, 인사이트(2014. 09. 01), 인용.</p></li><li><p>스티브 맥코넬 지음, 서우석 옮김 『 코드 컴플리트 2nd edition 』, 위키북스(2017. 07. 28), 인용.</p></li><li><p>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</p></li><li><p>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</p></li><li><p>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;메서드 시그니처는 신중하게 설계하라.&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Standard Naming Convention 룰을 따르라.&lt;/li&gt;
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>2018-05-02 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/05/02/2018-05-02-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/05/02/2018-05-02-독서-일지/</id>
    <published>2018-05-02T13:12:21.000Z</published>
    <updated>2018-05-03T13:26:55.339Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>int 상수 대신 enum을 사용하라</h1><ul><li>상수, 하드 코딩된 스트링 문자열은 전부 extract로 뽑아서 관리하고, 리팩토링했다.</li></ul><blockquote><p>int를 이용한 enum 패턴 -&gt; 더럽고 타입 안정성을 보장하지 않는다.</p></blockquote><h2>다른 언어의 enum은 enum의 껍데기를 쓴 int 형이지만, java는 완전한 기능을 갖춘 클래스다.</h2><ul><li>요즘 enum을 이용해 리팩토링을 많이 진행중인데, 천편일률적인 모양새가 대부분이다.</li><li>스트링을 속성으로 갖는 일반적인 enum 형태…</li><li>다양한 사용법을 비즈니스에 적용할 방법을 고민해봐야겠다.</li></ul><h1>Ordinal 대신 객체 필드를 사용하라.</h1><ul><li>Ordinal은 일반적인 프로그래머가 사용할 일이 없다. 피하자.</li></ul><h1>Enum에 메소드를 구현하고, 인터페이스를 이용해 확장 가능하다.</h1><h1>Reference</h1><ul><li><p>조슈아 블로크 지음, 이병준 옮김 『 Effective Java 2nd edition 』, 인사이트(2014. 09. 01), 인용.</p></li><li><p>스티브 맥코넬 지음, 서우석 옮김 『 코드 컴플리트 2nd edition 』, 위키북스(2017. 07. 28), 인용.</p></li><li><p>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</p></li><li><p>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</p></li><li><p>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;int 상수 대신 enum을 사용하라&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;상수, 하드 코딩된 스트링 문자열은 전부 extract로 뽑아서 관리하
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>03~04월 정리</title>
    <link href="http://jungha-cho.github.io/2018/05/01/03-04%EC%9B%94-%EC%A0%95%EB%A6%AC/"/>
    <id>http://jungha-cho.github.io/2018/05/01/03-04월-정리/</id>
    <published>2018-05-01T12:20:57.000Z</published>
    <updated>2018-05-01T12:23:00.254Z</updated>
    
    <content type="html"><![CDATA[<ul><li>3월 부터 몇몇일을 빼놓고는 조금씩 공부를 무조건 했다. 잘한것</li><li>알고리즘 풀이도 같이 진행했지만, 하다 보니 알고리즘은 뒷전이고 개발이나 리팩토링 부분에 상당히 관심이 많이 생겨서 그쪽으로 많이 진행한 것 같다.</li><li>알고리즘 풀이가 부족함!</li><li>객체 지향 설계쪽도 블랙잭 게임을 완성하지 못했다. 못한것</li><li>5월도 이렇게 쭈욱! 계속 공부하자!!</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;3월 부터 몇몇일을 빼놓고는 조금씩 공부를 무조건 했다. 잘한것&lt;/li&gt;
&lt;li&gt;알고리즘 풀이도 같이 진행했지만, 하다 보니 알고리즘은 뒷전이고 개발이나 리팩토링 부분에 상당히 관심이 많이 생겨서 그쪽으로 많이 진행한 것 같다.&lt;/li
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-29 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/29/2018-04-29-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/29/2018-04-29-독서-일지/</id>
    <published>2018-04-29T13:32:14.000Z</published>
    <updated>2018-04-29T13:38:44.969Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>클래스</h1><ul><li>설계에서부터 루틴의 작성, 테스트 등 일반적인 개발 순서도를 설명한다.</li></ul><blockquote><p>의사 코드는 일반적으로 프로그래밍 언어의 문법적인 요소를 사용하지 않고 문장으로 작성한다.</p></blockquote><h1>PPP외, 테스트 주도 개발, 리팩토링을 추천</h1><h1>Reference</h1><ul><li><p>스티브 맥코넬 지음, 서우석 옮김 『 코드 컴플리트 2nd edition 』, 위키북스(2017. 07. 28), 인용.</p></li><li><p>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</p></li><li><p>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</p></li><li><p>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;클래스&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;설계에서부터 루틴의 작성, 테스트 등 일반적인 개발 순서도를 설명한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;bloc
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>리팩토링 (4)</title>
    <link href="http://jungha-cho.github.io/2018/04/28/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-4/"/>
    <id>http://jungha-cho.github.io/2018/04/28/리팩토링-4/</id>
    <published>2018-04-28T14:18:05.000Z</published>
    <updated>2018-04-28T14:05:36.778Z</updated>
    
    <content type="html"><![CDATA[<h1>인터페이스 적용</h1><ul><li>자주 변경되는 또 중복되는 곳을 찾았는데, 인터페이스를 이용해서 처리할 수 있을거라 생각하고 한창 리팩토링을 했는데… 인터페이스가 다른곳에는 적용될수 없게 dto에 의존성이 생겨버렸다…</li><li>리팩토링 전 미리 좀 혜안을 가지고 더 깊게 볼순 없을까…? 음… 방법이 있을까?</li></ul><h1>Thanks to 객체 관련 책들!</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;인터페이스 적용&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;자주 변경되는 또 중복되는 곳을 찾았는데, 인터페이스를 이용해서 처리할 수 있을거라 생각하고 한창 리팩토링을 했는데… 인터페이스가 다른곳에는 적용될수 없게 dto에 의존성이 생겨버렸다…&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="업무" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-27 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/27/2018-04-27-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/27/2018-04-27-독서-일지/</id>
    <published>2018-04-27T10:55:40.000Z</published>
    <updated>2018-04-27T14:42:39.921Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>아…</h1><ul><li>요 이삼일 정도 책을 못봤다… 조금이라도 읽어야 되는데…</li><li>대신에 알고리즘 한두문제 풀고 자야지…</li></ul><h1>대신 리팩토링 얘기</h1><ul><li>God Class의 God Method들을 줄이고, 세분화 시켜가니까 다행이 구조가 편해지고 한눈에 보기 쉬워졌다. 보기 쉬워진 메소드들은 더욱더 간략하게 수정하고, 클래스와 메소드명, 변수명에 신경이 쓰이기 시작했다. 바꾸고 또바꾸고 또바꾸고의 연속이지만, 즐겁다. 내가 짜고 있는 코드가 흐뭇해 지는 기분…</li></ul><h1>Reference</h1><ul><li><p>스티브 맥코넬 지음, 서우석 옮김 『 코드 컴플리트 2nd edition 』, 위키북스(2017. 07. 28), 인용.</p></li><li><p>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</p></li><li><p>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</p></li><li><p>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;아…&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;요 이삼일 정도 책을 못봤다… 조금이라도 읽어야 되는데…&lt;/li&gt;
&lt;li&gt;대신에 알고리즘 한두문제 풀고
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>리팩토링 (3)</title>
    <link href="http://jungha-cho.github.io/2018/04/26/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-3/"/>
    <id>http://jungha-cho.github.io/2018/04/26/리팩토링-3/</id>
    <published>2018-04-26T14:18:05.000Z</published>
    <updated>2018-04-26T14:21:22.946Z</updated>
    
    <content type="html"><![CDATA[<h1>약 50개 가량 되는 클래스의 정리가 얼추 끝났다.</h1><ul><li>인터페이스로 다형성을 적용해 변경이 많은 부분을 분리할 수 있는 부분을 찾았다.</li><li>허허… 이런게 객체 지향의 재미인가…</li><li>작업할 거리는 많지만, 간단해지고 더욱 깔끔해 지는 클래스를 보니 기분이 좋아진다.</li></ul><h1>Thanks to 객체 관련 책들!</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;약 50개 가량 되는 클래스의 정리가 얼추 끝났다.&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;인터페이스로 다형성을 적용해 변경이 많은 부분을 분리할 수 있는 부분을 찾았다.&lt;/li&gt;
&lt;li&gt;허허… 이런게 객체 지향의 재미인가…&lt;/li&gt;
&lt;li&gt;작업할 거리는 많
      
    
    </summary>
    
      <category term="업무" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>리팩토링 (2)</title>
    <link href="http://jungha-cho.github.io/2018/04/24/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-2/"/>
    <id>http://jungha-cho.github.io/2018/04/24/리팩토링-2/</id>
    <published>2018-04-24T12:54:05.000Z</published>
    <updated>2018-04-25T08:53:54.418Z</updated>
    
    <content type="html"><![CDATA[<p>저번 글의 끝에 아래와 같은 고민이 있었는데…</p><h1>문제는</h1><ul><li>메인 감시 클래스에 모든 스레드 정보가 담겨있는 맵이 존재하는데, 이 맵은 스태틱이며 메인 감시 클래스에서만 접근이 가능해, 각각의 하위 클래스에 정보로 전달이 불가능했다.</li><li>어느 책인지 기억이 나진 않지만, <code>클래스</code>가 멤버 변수가 없다면 <code>클래스가 아니다</code>라는 글귀가 기억이 나는데, 이 글귀에 따르자면 각각의 하위 클래스는 클래스가 아니다…</li><li>이렇게 스태틱으로 관리되는 맵이 있으면, 하위 클래스가 이를 전달받기 위해서는 어떻게 해야 할까? 상속? 인터페이스?.. 이 부분을 고민해야 겠다.</li></ul><h1>일단</h1><p>문제는 제껴두고 <code>갓 클래스</code>들을 보기쉽게 또 알기 쉽게 분해하고 책임을 나누고 작고 서술적인 메소드로 수정하며 로직에 불필요한 부분을 줄여나가고 있다.<br>지금 모든 클래스의 2/3을 끝낸거 같은데, 리팩토링 하다보니 느끼는 점이 있는데, 이때까지 나는 모든 것을 전부 <code>객체 지향</code>적 시선과 생각으로 보지 않고, <code>절차 지향</code>적인 생각과 코딩으로 일관 했다.</p><blockquote><p>조금 귀찮으면, static을 쓰고 여기 저기서 static 변수, 메소드, 클래스를 불러오며 덕지 덕지 모든것을 그렇게 수행했다.<br>이건 무슨… 구조만 클래스로 바뀐것 뿐이지, C 스타일 이다. 내 생각도 그렇고 지금 보고 있는 코드도 그렇다.<br>static으로 도배하고, 이클래스와 저 클래스 사이에서 뛰어 노는 전역 변수들을 보고 있자니 머리가 아파온다.</p></blockquote><ul><li><p>이제 좀 공부한 보람이 있는것 같다. 클래스 기준으로 바라보는게 아니라, 객체와 객체간의 메세지를 전달하고, 캡슐화해 필요한 정보만 제공하며, 자기 할일이 끝나면 사라져 버리는 객체들 그리고 객체간 추상화 수준…</p></li><li><p>지금 내가 보고 있는 코드는 오합지졸의 합창을 보는것 같으며, 날아다니는… 아니 하늘 위에 우주가 있는지 모르고 땅만 보며 걸어 다니는 사람 같다…</p></li><li><p>천천히… 비즈니스 로직에는 영향이 없게 천천히 static을 걷어내고 객체 세상을 다시 건설해볼 생각이다.</p></li></ul><h1>추가</h1><ul><li>업무 프로그램 성격상 전역 변수로 선언되어 관리 되어야 할 데이터가 있다면, 프로그램이 시작될때 입력되어 프로그램이 끝날때까지 같이 가는 설정 정보들 일것이다.</li><li>이 데이터는 DTO 객체로 맵 형태로 관리되는데, 기존엔 여기 설정정보에 접근할때 어떠한 제약도 없었다. 중구난방 어디서든 접근이 가능했고, 프로그램 내부에서도 접근 메소드가 상당부분 흩어져 있었다.</li></ul><blockquote><p>ThreadPropertyAccess 이름으로 클래스를 만들고 내부에서 private으로 DTO 맵을 선언한뒤 접그네어자는 전부 public으로 메소드를 뽑았다.<br>ThreadPropertyAccess 클래스는 특정 클래스에머 static으로 선언되어있고 프로그램 시작과 끝을 함께 한다.<br>이 클래스 접근 제어자도 선언된 클래스에 메소드로 설정되어, 이 통로로만 접근 가능하게 모든 접근 포인트를 줄여버리고, 제어 메소드는 Access 내부로 집중화 시켰다.</p></blockquote><h1>Thanks to 객체 관련 책들!</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;저번 글의 끝에 아래와 같은 고민이 있었는데…&lt;/p&gt;
&lt;h1&gt;문제는&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;메인 감시 클래스에 모든 스레드 정보가 담겨있는 맵이 존재하는데, 이 맵은 스태틱이며 메인 감시 클래스에서만 접근이 가능해, 각각의 하위 클래스에 정보로
      
    
    </summary>
    
      <category term="업무" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-24 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/24/2018-04-24-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/24/2018-04-24-독서-일지/</id>
    <published>2018-04-24T10:35:12.000Z</published>
    <updated>2018-04-24T12:53:46.146Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>Assert 활용법</h1><ul><li>입력 또는 출력 매개 변수의 값이 예상 범위 내에 속하는지</li><li>파일이나 스트림이 루틴이 시작할 때 또는 끝날때 열려있는지 또는 닫혀있는지</li><li>파일이나 스트림이 루틴이 시작할 때 또는 끝날때 시작 또는 끝에 있는지</li><li>파일이나 스트림이 읽지 전용이나 쓰기 전용, 읽기/쓰기로 열려 있는지.</li><li>입력만 가능한 변수의 값이 루틴에 의해서 변경되지 않는지</li><li>포인터가 Null이 아닌지</li><li>루틴에 전달되는 배열이나 다른 컨테이너가 적어도 X개의 데이터 요소를 포함할 수 있는지</li><li>테이블이 실제 값을 포함할 수 있도록 초기화 되었는지</li><li>컨테이너가 루틴이 시작할 때 또는 끝날 때 비어 있는지 또는 채워져 있는지</li><li>매우 최적화되어 있고 이해하기 어려운 루틴의 결과가 수행 속도는 느리지만 이해하기 쉬운 루틴의 결과와 일치하는지</li></ul><h1>Reference</h1><ul><li><p>스티브 맥코넬 지음, 서우석 옮김 『 코드 컴플리트 2nd edition 』, 위키북스(2017. 07. 28), 인용.</p></li><li><p>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</p></li><li><p>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</p></li><li><p>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Assert 활용법&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;입력 또는 출력 매개 변수의 값이 예상 범위 내에 속하는지&lt;/li&gt;
&lt;li&gt;파일이나 스트
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-23 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/23/2018-04-23-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/23/2018-04-23-독서-일지/</id>
    <published>2018-04-23T12:20:40.000Z</published>
    <updated>2018-04-23T13:06:59.611Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>루틴을 작성하는 이유</h1><ul><li>복잡성을 줄인다.</li><li>이해하기 쉬운 중간 단계의 추상화를 도입한다.</li><li>코드의 중복을 피한다.</li><li>서브 클래싱을 지원한다.</li><li>코드의 실행 순서를 감춘다.</li><li>포인터 연산을 감춘다.</li><li>이식성을 높인다.</li><li>복잡한 불린 테스트를 단순화한다.</li><li>성능을 개선한다.</li></ul><h1>클래스를 작성하는 이유</h1><ul><li>복잡성을 고립시킨다.</li><li>구현 세부 사항을 숨긴다.</li><li>변경의 효과를 제한한다.</li><li>전역 데이터를 숨긴다.</li><li>중앙 집중 관리한다.</li><li>코드의 재사용을 돕는다.</li><li>특정한 리팩터링을 수행한다.</li></ul><h1>Reference</h1><ul><li><p>스티브 맥코넬 지음, 서우석 옮김 『 코드 컴플리트 2nd edition 』, 위키북스(2017. 07. 28), 인용.</p></li><li><p>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</p></li><li><p>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</p></li><li><p>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;루틴을 작성하는 이유&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;복잡성을 줄인다.&lt;/li&gt;
&lt;li&gt;이해하기 쉬운 중간 단계의 추상화를 도입한다.&lt;/li
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>리팩토링 (1)</title>
    <link href="http://jungha-cho.github.io/2018/04/23/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-1/"/>
    <id>http://jungha-cho.github.io/2018/04/23/리팩토링-1/</id>
    <published>2018-04-23T04:27:42.000Z</published>
    <updated>2018-04-23T04:46:24.779Z</updated>
    
    <content type="html"><![CDATA[<h1>Java, 리팩토링</h1><ul><li>회사 비즈니스상 고객들의 서버와 컴퓨터에 설치되어 비즈니스를 수행하는 <code>Java, Client Program</code> 유지/보수/개발 업무를 맡고 있음.</li><li>Java 1.6 Base로 개발되어 현재는 1.7로 포팅된 상태이고, 1.7 기반으로 유지/보수/개발 이 진행 중임.</li><li>멀티 쓰레드 기반이며, 영속성 ORM 도구는 MYBATIS를 사용중</li></ul><h1>답답하다.</h1><ul><li>처음 인수 인계 받고도 막막했지만, 익숙해진 지금도 막막하다.</li><li>클래스 관계는 꼬여 있으며, 하나의 클래스에 다 때려박아 놓는 <code>갓 클래스</code>가 존재하며, 멀티 스레드 환경이 제대로 통제된 느낌이 없다.</li><li>그때 그때 요구 사항을 개발하며, <code>작동만</code> 하게끔 만들어논 티가 물씬 풍긴다.</li></ul><h1>처음에는.</h1><ul><li>나도 처음에는 모든 열정을 품고 새로 만들거나 고쳐 보려는 시도를 했지만, 이미 <code>존재</code>하는 프로그램을 새로 짤 이유를 찾지 못했어며, <code>리팩토링</code> 시도는 내가 수정한 부분이 어디까지 영향을 끼칠지 감이 오지 않아서 시도를 하지 못했다.</li></ul><h1>지금은.</h1><ul><li>내 업무를 받을 후임에게도 미안하고, 내 자신에게도 부끄러운 코드가 지속되고 있다고 생각하니, 참을 수 없었다.</li><li>우선 패키지를 정돈하고, 클래스 네이밍 수정 및 변수 정리 그리고 <code>잘게 쪼개어지고 서술적인 이름을 가진 클래스 내 메소드</code>를 Intellij의 <code>Extract</code> 기능들을 이용해 정돈중이다.</li></ul><h1>분석중.</h1><ul><li>책을 읽으며 습득한 지식으로 혼자 고민하며, 변경이 지속될 부분을 찾고 있으며, 디자인 패턴 적용도 고려 중이다.</li></ul><h1>이것은… 파괴적인… 혼돈의… 자바 코드에 생명을 불어넣기 위한 일지이다…</h1><h1>쓰레드</h1><ul><li>멀티 쓰레드 환경에서 쓰레드는 항상 비정상 동작을 염두에 두고 대비책을 세워야 한다.</li><li>해당 프로그램은 Thread를 관리하는 데몬 스레드가 존재하며, 해당 데몬 스레드는 비즈니스 스레드를 <code>감시</code>하고, <code>준비 및 시작</code>하며, <code>종료</code>까지 책임 진다.</li><li>이 모든 기능이 클래스 하나에 때려박혀 있으니… 이게 <code>갓 클래스</code>가 아니면 무엇이겠는가…</li></ul><h2>따라서, 쓰레드 감시 클래스를 기능 별로 분류해 책임을 분산시켰다.</h2><ul><li>메인 감시 스레드는 각각의 기능 동작 주기만을 관장한다.</li><li>이니시에이터 클래스는 초기화를 담당한다.</li><li>익스큐터 클래스는 시작을 담당한다.</li><li>인스펙터 클래스는 감시를 담당한다.</li></ul><h2>문제는</h2><ul><li>메인 감시 클래스에 모든 스레드 정보가 담겨있는 맵이 존재하는데, 이 맵은 스태틱이며 메인 감시 클래스에서만 접근이 가능해, 각각의 하위 클래스에 정보로 전달이 불가능했다.</li><li>어느 책인지 기억이 나진 않지만, <code>클래스</code>가 멤버 변수가 없다면 <code>클래스가 아니다</code>라는 글귀가 기억이 나는데, 이 글귀에 따르자면 각각의 하위 클래스는 클래스가 아니다…</li><li>이렇게 스태틱으로 관리되는 맵이 있으면, 하위 클래스가 이를 전달받기 위해서는 어떻게 해야 할까? 상속? 인터페이스?.. 이 부분을 고민해야 겠다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Java, 리팩토링&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;회사 비즈니스상 고객들의 서버와 컴퓨터에 설치되어 비즈니스를 수행하는 &lt;code&gt;Java, Client Program&lt;/code&gt; 유지/보수/개발 업무를 맡고 있음.&lt;/li&gt;
&lt;li&gt;Java 1.6 
      
    
    </summary>
    
      <category term="업무" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="리팩토링" scheme="http://jungha-cho.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-22 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/22/2018-04-22-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/22/2018-04-22-독서-일지/</id>
    <published>2018-04-22T13:00:45.000Z</published>
    <updated>2018-04-22T13:17:14.729Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>클래스 다루기</h1><ul><li>코드를 작성할 때의 편의성보다 가독성이 높은 코드를 작성하라.</li><li>캡슐화의 의미론적인 위반을 각별히 주의하라.</li></ul><h2><code>포함 has a (갖다)(Containment)</code> 관계</h2><ul><li>직원은 이름을 “갖고” 전화번호를 “갖고” 세금 ID 등을 &quot;갖는&quot;다.</li><li><code>7+-2</code>는 개인이 다른 작업을 수행하고 있을때 기억할 수 있는 개별적인 항목의 수다. 클래스의 멤버 변수가 이 수치를 넘는다면 리팩토링을 고려하라.</li></ul><h2><code>상속 is a</code> 관계</h2><ul><li>상속을 고려해서 설계하고 문서화하라. 그게 아니면 상속을 금지하라.</li></ul><h2>광범위한 타입 검사보다 다형성을 사용하라.</h2><h2>클래스를 작성하는 이유</h2><ul><li>현실 세계의 객체를 모델링한다.</li><li>추상 객체를 모델링 한다.</li><li>복잡성을 줄인다.</li><li>복잡성을 고립시킨다.</li><li>구현 세부 사항을 숨긴다.</li><li>변경의 효과를 제한한다.</li><li>전역 데이터를 숨긴다.</li><li>매개 변수 전달을 간소화 한다.</li><li>중앙 집중 관리한다.</li><li>코드 재사용을 돕는다.</li><li>연관된 기능을 패키지로 구성한다.</li><li>특정한 리퍽토링을 수행한다.</li></ul><h1>Reference</h1><ul><li><p>스티브 맥코넬 지음, 서우석 옮김 『 코드 컴플리트 2nd edition 』, 위키북스(2017. 07. 28), 인용.</p></li><li><p>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</p></li><li><p>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</p></li><li><p>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;클래스 다루기&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;코드를 작성할 때의 편의성보다 가독성이 높은 코드를 작성하라.&lt;/li&gt;
&lt;li&gt;캡슐화의 의미론
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-21 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/21/2018-04-21-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/21/2018-04-21-독서-일지/</id>
    <published>2018-04-21T03:31:18.000Z</published>
    <updated>2018-04-22T13:00:28.364Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>코드 컴플리트 2nd edition</h1><h2>6장 클래스 다루기</h2><ul><li>명령문의 집합으로 프로그래밍을 이해하던 시대에서, 클래스로써 프로그래밍을 이해하려 하는 현재 패러다임은 최대한 코드에 집중할 수 있게 해준다.</li></ul><blockquote><p>추상 데이터형 Abstract Data Type<br>ADT를 이해하지 못한다면, 이름만, 껍데기만 클래스인 가짜 클래스를 작성하게 될 것이다.</p></blockquote><ul><li>구현 세부사항을 감출수 있다.</li><li>변경이 전체에 영향을 미치지 않는다.</li><li>인터페이스가 더 많은 정보를 제공하도록 만들 수 있다.</li><li>성능을 향상시키기 쉽다.</li><li>프로그램이 명백하게 정확해진다.</li><li>프로그램의 가독성이 높아진다.</li><li>전체 프로그램에 데이터를 넘길 필요가 없다.</li><li>저수준 구현 구조체 대신 현실 세계의 개체를 다룰 수 있다.</li></ul><h2>EXAMPLE</h2><ul><li><p>엘리베이터.</p></li><li><p>한 층 위로 이동한다.</p></li><li><p>한 층 아래로 이동한다.</p></li><li><p>특정 층으로 이동한다.</p></li><li><p>현재 층을 보고 한다.</p></li><li><p>현관 층으로 돌아 간다.</p></li><li><p>클래스가 구현하고 있는 추상화가 무엇인지 이해해야 한다.</p></li></ul><h1>Reference</h1><ul><li><p>스티브 맥코넬 지음, 서우석 옮김 『 코드 컴플리트 2nd edition 』, 위키북스(2017. 07. 28), 인용.</p></li><li><p>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</p></li><li><p>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</p></li><li><p>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;코드 컴플리트 2nd edition&lt;/h1&gt;
&lt;h2&gt;6장 클래스 다루기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;명령문의 집합으로 프로그래밍을 이해하
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-18 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/18/2018-04-18-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/18/2018-04-18-독서-일지/</id>
    <published>2018-04-18T08:24:25.000Z</published>
    <updated>2018-04-18T14:38:50.179Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>객체 지향의 사실과 오해 (역할, 책임, 협력 관점에서 본 객체 지향)</h1><h2>분류와 인스턴스화</h2><ul><li>분류는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정이다.</li><li>분류의 역은 범주로부터 객체를 생성하는 인스턴스화 과정이다.<br>???</li></ul><h2>일반화와 특서화</h2><ul><li>일반화는 범주 사이 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다.</li><li>일반화의 역을 특수화라 한다.</li></ul><h2>집합과 분해</h2><ul><li>집합은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정</li><li>집합의 반대 괒엉은 전체를 부분으로 분리하는 분해</li></ul><h1>코드 컴플리트 2nd edition</h1><ul><li>허허… 책 두께가 900페이지이다.</li><li>실용적인 지시서와 체크 리스트, 요점 정리로 가득찬 실용서인것 같다.</li><li>6장 클래스 다루기 전까진 실제 구현 전 참고해야할 자료들을 기술하고 있다.</li><li>용어를 정리하고, 구현 전 선행 조건을 점검하며 구현시 결정해야할 점 또 설계에 대해 기술하고 체크 리스트를 제시하고 있따.</li></ul><h1>Reference</h1><ul><li><p>조영호, 『 객체 지향의 사실과 오해, 역할, 책임, 협력 관점에서 본 객체 지향 』, 위키북스(2015 06 17), 인용.</p></li><li><p>스티브 맥코넬 지음, 서우석 옮김 『 코드 컴플리트 2nd edition 』, 위키북스(2017. 07. 28), 인용.</p></li><li><p>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</p></li><li><p>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</p></li><li><p>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;객체 지향의 사실과 오해 (역할, 책임, 협력 관점에서 본 객체 지향)&lt;/h1&gt;
&lt;h2&gt;분류와 인스턴스화&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;분
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-17 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/17/2018-04-17-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/17/2018-04-17-독서-일지/</id>
    <published>2018-04-17T07:34:38.000Z</published>
    <updated>2018-04-17T13:15:42.491Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>객체 지향의 사실과 오해 (역할, 책임, 협력 관점에서 본 객체 지향)</h1><h2>역할 책임 협력</h2><ul><li>역할이 중요하다. 다만, 대체할 수 있다.</li><li><code>전지 전능한 객체; god object</code>는 내부 복잡도에 의해 자멸한다.</li></ul><blockquote><p><code>상태; state</code><br><code>행동; behavior</code></p></blockquote><ul><li>객체 지향은 클래스를 중심으로 작성되는 코드로 설명되는 것 같지는 않다. 책에서도 강조하듯 객체 지향은 객체간의 역할, 책임, 협력을 강조한다. 하나의 클래스에 모든것을 담는 것은 객체 지향의 올바른 자세가 아니며, 각 객체가 협력해 어떤 일련의 절차나 행동을 구현하는 것에 집중해야 할 것같다.</li></ul><h2>이상한 나라의 객체</h2><ul><li>객체 지향 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 새로운 세계를 창조하는 것이다.</li><li>객체의 상태를 조회하는 작업을 <code>쿼리 (query)</code></li><li>객체의 상태를 변경하는 작업을 <code>명령 (command)</code></li></ul><h2>타입과 추상화</h2><ul><li>지하철 노선도 또한 추상화의 결과물이라 한다. 필요한 정보만, 필요 없는 정보는 과감히 빼버린…</li></ul><blockquote><p>추상화<br>구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 <code>일반화</code><br>중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만듦</p></blockquote><ul><li>타입은 객체를 분류하기위해 사용하는 개념. 클래스는 타입을 구현할 수 있는 구현 매커니즘 중하나</li><li>클래스는 타입의 구현 외에도 코드를 재사용하는 용도로 이용된다.</li><li>동적으로 변하는 객체의 <code>상태</code>와 상태를 변경하는 <code>행위</code>에 집중하라.</li></ul><h1>Reference</h1><ul><li><p>조영호, 『 객체 지향의 사실과 오해, 역할, 책임, 협력 관점에서 본 객체 지향 』, 위키북스(2015 06 17), 인용.</p></li><li><p>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</p></li><li><p>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</p></li><li><p>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;객체 지향의 사실과 오해 (역할, 책임, 협력 관점에서 본 객체 지향)&lt;/h1&gt;
&lt;h2&gt;역할 책임 협력&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;역할
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-16 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/16/2018-04-16-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/16/2018-04-16-독서-일지/</id>
    <published>2018-04-16T07:00:55.000Z</published>
    <updated>2018-04-16T08:41:07.330Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]</h1><h2>아스키 코드와 문자의 변환</h2><ul><li><p>언제 한번 날 잡아서, 아스키에서 유니코드로 넘어오고, 코드 포인트가 사용된 이유와 UTF-8이 혁신이었던 이유 등등을 정리 포스팅을 해야겠다.</p></li><li><p>아슬 아슬 줄다리기도 아니고, 어느 부분만 알고 모르는건 또 모르고, 개인적인 생각이지만, 정확하게 풀어서 입으로 설명하지 못한다면 아는게 아니라는 주의인데, 문자열에 대해서 나는 모르는게 확실하다.</p></li><li><p>문자라는 개념이 가지고있는 단어 한개 한개의 의미는 변하지 않는다. 다만 폰트와 사이즈, 간격 등이 변할 뿐이다.</p></li><li><p>이름을 굴림체로 쓰든 SIZE 20으로 쓰든 내 이름 그 글자의 뜻과 내용은 변하지 않음</p></li></ul><blockquote><p>ASCII ( American Standard Code for Information Interchange; ASCII) 미국 표준 부호, 표준 규격</p></blockquote><ul><li><p>영문 대소문자 52개, 숫자 10개, 특수문자포함해도 128개를 넘어갈 수 없음.</p></li><li><p>그래서 ASCII 코드 하나는 7비트를 사용함, 그러나 표현 가능한 키보드의 모든 개수는 95개 이므로 33개의 자리가 있음.</p></li><li><p>대문자와 소문자는 16진수로 20h가 차이가남, 정확하게 20 이므로, a 아스키 코드에 20을 더하면 A가 됨</p></li><li><p>표현 가능한 문자는 95개이고 나머지 33개는 제어 문자임</p></li><li><p>아스키 코드는 영어권에 맞춰져 있음… 따라서 아스키를 대체할 UNICODE가 개발됨.</p></li><li><p>다만 아스키 코드는 7비트인것에 비해 유니코드는 16비트를 기본으로 사용함으로 약 2배 가량 용량 차이가 남</p></li></ul><h2>버스에 올라 탑시다.</h2><h2>운영체제</h2><h2>고정 소수점과 부동 소수점과</h2><h2>고수준 언어와 저수준 언어</h2><h2>그래픽 언어</h2><h1>휘몰아 치다.</h1><ul><li>아주 차근 차근, 유치원생에게 한글을 숫자를 가르치듯 천천히 그러나 폭풍처럼 컴퓨터의 기반이 되는, 엔지니어의 상식이 될 기초외 기반 지식들을 휘몰아쳐 준다.</li><li>이 모든 것들은 엔지니어의 기본 자양분이 될것으로 믿어 의심치 않는다. 다만, 상식과 기초라는 부분이 <code>소프트웨어</code>에 맞춰져 있지 않고, 하드웨어가 동작하는 원리부터 시작해, 컴퓨터를 이루는 모든 부분을 아주 밑바닥부터 훝어주고 있어, 이해 되지 않는 부분이 많다.</li><li>아직 이 내용을 온전히 내 것으로 받아 들일 정도는 아닌것 같다. 다만, <code>코드 code</code>라는 책에서 관련 내용이 나왔으니, 그때 그때 참고 자료 삼아 한번씩 읽어볼 수 있게, 필수 구입 도서로 선정해야겠다!</li></ul><h1>Reference</h1><ul><li>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</li><li>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</li><li>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]&lt;/h1&gt;
&lt;h2&gt;아스키 코드와 문자의 변환&lt;/h2&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-14 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/14/2018-04-14-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/14/2018-04-14-독서-일지/</id>
    <published>2018-04-14T04:07:09.000Z</published>
    <updated>2018-04-14T07:24:43.738Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]</h1><h2>메모리를 만들어 봅시다.</h2><ul><li><p>기본은 플립플롭이다. 클럭이 1일땐 출력이 클럭 입력과 같아지지만, 클럭이 0이면 출력은 이전에 출력값을 유지하는 특성을 이용한다.</p></li><li><p>3비트 주소 입력을 가지는 8개의 1비트 래치 모음은 일반적으로 <code>RAM; Random Access Memory</code>라 부르며, 3비트 주소 입력이 어느 래치에 정보를 저장할 것인지를 선택한다.</p></li><li><p>입력 주소 값만 바꾸면 어느 비트든 접근이 가능하기 때문에 <code>임의 접근 메모리; Random Access Memory</code>라 부른다.</p></li></ul><blockquote><p>램 배열에 저장되는 값의 수 = 2^주소 입력의 비트 수</p></blockquote><ul><li><p>1024 = KiloByte, Kilo는 그리스어로 1000을 의미하는 Khillioi에서 유래되서 킬로 바이트가 1000이라 혼동 한다.</p></li><li><p>하지만, 킬로 바이트는 1000바이트가 아닌 1024바이트를 의미한다.</p></li><li><p>키햐, 이런 단어의 유래까지 설명을 들어가며, 킬로바이트가 1000이 아니라 1024인 이유가 해결 됐다…</p></li><li><p>10, 100, 1000, 10000단위의 10 거듭 제곱 수를 생각한다면, 킬로는 1000이 맞지만, 우리의 바이너리 기반 메모리는 2의 거듭제곱수 이므로, 2, 4, 8, 16 ~ 1024를 의미한다.</p></li><li><p>1024KB = 1MegaByte</p></li><li><p>1024MB = 1GigaByte</p></li><li><p>1024GB = 1TeraByte</p></li><li><p>1TB = 2^40 근사함</p></li><li><p>정리 하자면, 1킬로바이트는 천 바이트에 근사하며, 메가바이트는 백만 바이트에 근사하고, 기가 바이트는 십억 바이트에 근사하며, 테라 바이트는 1조 바이트에 근사하다.</p></li><li><p>메모리의 각 게이트는 적절한 전원이 공급되지 않으면 원래 천이 되지 않은 상태로 돌아가고, 안에 저장되는 자료는 사라진다고 한다. 이게 <code>RAM이 휘발성 메모리</code>라 불리는 이유다.</p></li></ul><h2>혼자서 움직이는 컴퓨터</h2><ul><li>덧셈을 자동화 했는데, Assembly로 코드 언어가 나온다… 학부 시절 잠깐 실습 해본것 같은 기억 이있다… 읽은 것만으로도 용하다…허허</li></ul><h2>주판에서 반도체까지</h2><ul><li><p>4비트 마이크로프로세서는 데이터 패스의 넓이가 4비트라, 수를 더하거나 뺄때 4비트씩 계산할 수 있다는 얘기이다.</p></li><li><p>최대 클럭 주파수는 프로세서의 전반적인 속도에 영향을 미친다.</p></li><li><p>프로세서의 데이터 폭 또한 속도에 영향을 준다.</p></li><li><p>4비트 프로세서도 32비트 숫자를 더할 순 있지만, 32비트 프로세서 처럼 빠르게 더할 순 없다.</p></li></ul><h2>두 가지 고전적인 마이크로 프로세서들</h2><h1>테스트 주도 개발로 배우는 객체 지향 설계와 실천 [스티브 프리먼, 냇 프라이스]</h1><h2>스나이퍼가 경매에서 낙찰하다.</h2><ul><li>음 점점 이책에 흥미가 떨어진다… TDD보다 한단계 더 높은 시점에서 프로젝트 전체를 놓고 효율적인 개발론을 설명하고 있으니 당연하다. 아직 TDD도 익숙하지 않은 상태에서 읽으면 안될 책인 것만은 분명하지만… 나는 무엇을 모르는지도 모른 상태보다 무엇을 모르는지 아는 상태가 훨씬 났고 다르다고 생각하니 끝까지 읽어 봅시다!!!</li></ul><h2>실제 사용자 인터페이스를 향해</h2><ul><li>잠깐 중단. 여기서부터 4부 전 까지는 실제 개발 사례를 이용해, TDD를 적용해가며 개발하고 설계하는 부분을 설명하는데, 안되겠다. 이해가 안되니… 핵심만 읽으러 가자</li></ul><h2>4부 지속 가능한 테스트 주도 개발</h2><h2>테스트에 귀 기울이기</h2><h2>테스트 가독성</h2><h1>실용주의 프로그래머 [앤드류 헌트, 데이비드 토머스]</h1><h2>실용주의 프로젝트</h2><h1>Reference</h1><ul><li>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</li><li>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</li><li>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]&lt;/h1&gt;
&lt;h2&gt;메모리를 만들어 봅시다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>객체지향설계 블랙잭 (14)</title>
    <link href="http://jungha-cho.github.io/2018/04/12/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD-14/"/>
    <id>http://jungha-cho.github.io/2018/04/12/객체지향설계-블랙잭-14/</id>
    <published>2018-04-12T14:12:00.000Z</published>
    <updated>2018-04-12T14:23:35.411Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 지향 설계 연습하기 - 블랙잭 (13)</h1><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github source code</a></p><h1>들어가며</h1><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h1>정신이 없습니다.</h1><p>TEST 코드 없이는 기능 코드를 작성하지 않으려 했지만… 테스트 코드 작성하고, 기능쪽을 보니 바꾸고 싶은게 태산이고… 왔다 갔다 왔다 갔다… 정신은 없고… 지키고자 했던 원칙은 온데 간데 없습니다…</p><blockquote><p>다만 한가지는 분명합니다. 작성되 있던 기능을 이렇게 저렇게 바꾸고 전체 테스트를 돌려보면 이전에 작성해놨던 회귀 테스트들이 제기능을 다하고 있습니다. 아주 조그만 변경이라도 미리 작성해놨던 든든한 회귀 테스트가 있다면, 사소한 변경이라도 안심하고 변경한 뒤 테스트를 통해 <code>피드백</code>을 받을 수 있다는 것입니다.</p></blockquote><h1>오늘은 테스트 코드 먼저 까볼게요!</h1><p>![20180412-blackjack-v3-testcase.JPG][/images/20180412-blackjack-v3-testcase.JPG]</p><script src="//gist.github.com/c0b59dad90a350514c7fef0b18f18c8f.js?file=1.java"></script><script src="//gist.github.com/c0b59dad90a350514c7fef0b18f18c8f.js?file=2.java"></script><script src="//gist.github.com/c0b59dad90a350514c7fef0b18f18c8f.js?file=3.java"></script><script src="//gist.github.com/c0b59dad90a350514c7fef0b18f18c8f.js?file=4.java"></script><script src="//gist.github.com/c0b59dad90a350514c7fef0b18f18c8f.js?file=5.java"></script><h1>소스코드</h1><script src="//gist.github.com/b0f9c120d73fea5e5ae6f0288acc8852.js?file=1.java"></script><script src="//gist.github.com/b0f9c120d73fea5e5ae6f0288acc8852.js?file=2.java"></script><script src="//gist.github.com/b0f9c120d73fea5e5ae6f0288acc8852.js?file=3.java"></script><script src="//gist.github.com/b0f9c120d73fea5e5ae6f0288acc8852.js?file=4.java"></script><script src="//gist.github.com/b0f9c120d73fea5e5ae6f0288acc8852.js?file=5.java"></script><script src="//gist.github.com/b0f9c120d73fea5e5ae6f0288acc8852.js?file=6.java"></script><script src="//gist.github.com/b0f9c120d73fea5e5ae6f0288acc8852.js?file=7.java"></script><script src="//gist.github.com/b0f9c120d73fea5e5ae6f0288acc8852.js?file=8.java"></script><script src="//gist.github.com/b0f9c120d73fea5e5ae6f0288acc8852.js?file=9.java"></script><script src="//gist.github.com/b0f9c120d73fea5e5ae6f0288acc8852.js?file=10.java"></script><script src="//gist.github.com/b0f9c120d73fea5e5ae6f0288acc8852.js?file=11.java"></script><h1>오늘까지의 후기</h1><ul><li>그때 그때 시간 날때마다 조금씩 고치며 적용해보고 있는거라 진도가…</li><li>사실… 마음에 안들어서 폐기, 코드 버리고 다시, 다시, 다시,</li><li>다만 V3는 TDD를 적용해 저 스스로 객체 지향적 원칙을 적용하려 노력하며 짜다보니, 상당히 안정적인 느낌이 듭니다.</li><li>이런 느낌이라는 것도… 느낌 보다는 확신이나 증거, 증명이 필요할텐데 말입니다…</li><li>음…</li></ul><h1>Reference</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 지향 설계 연습하기 - 블랙잭 (13)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/BlackJack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github source code&lt;/a&gt;
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="디자인 패턴" scheme="http://jungha-cho.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="헤드 퍼스트 디자인 패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C-%ED%8D%BC%EC%8A%A4%ED%8A%B8-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-12 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/12/2018-04-12-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/12/2018-04-12-독서-일지/</id>
    <published>2018-04-12T10:16:48.000Z</published>
    <updated>2018-04-12T12:07:24.260Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]</h1><h2>피드백과 플립플롭</h2><ul><li><p>음… <code>Oscillator 오실레이터; 전동자</code>… 학부때 분명히 공부를 했던 기억이 있는데… 어떤 것이었는지 정확하게 기억이 나진 않는다…</p></li><li><p>인버터를 한개로 구성하고 인버터의 출력을 인버터의 입력으로 물린 후 입력을 넣으면 어떻게 될까?</p></li><li><p>0, 1, 0, 1로 신호가 반복될 건데… 이거를 <code>오실레이터</code>라고 책에서 설명 한다. 뭐지 분명히 공부했는데 이 새로운 느낌은?</p></li><li><p>보통 <code>오실레이터</code> = <code>클럭</code> 이라 부르며 동일한 뜻</p></li><li><p>오실레이터가 0, 1, 0, 1로 반복하는데, 여기서 처음 시작한 부분에서 상태가 바뀌었다가 원래 상태로 돌아올때, 그때를 주기라 한다.</p></li><li><p>주기의 역수로 초당 몇 사이클이 순환하는지 알 수 있는데, 이때 초당 사이클을 <code>헤르츠, hz</code>라 표현한다…</p></li></ul><p>오… 오… 오… 하다가 플립플롭부터, 플립 플롭을 이용한 1bit 메모리, 그리고 카운터까지 나와버리자… 정신을 놓아 버렸다…<br>기본 적인 원리는 이해가 되지만, 이론적인 내용이 합쳐저 더 큰 개념으로 조합되니까 재밌는데 이해가 잘 되지 않네…ㅠㅠ</p><h2>바이트와 16진수</h2><ul><li>비트 단위는 0, 1 두가지 상태를 나타낼 수 있다는 것은 이미 알고 있다. 그런데, byte 단위인 8bit는 왜 하필 byte는 8bit 일까?</li><li>생각치도 못한 질문이다…</li></ul><p>바이트는 부호가 있을 경우 -128~127 숫자 범위를 표현 가능하고, 부호가 없을 경우 0~255까지 양수를 표현 가능하다.<br>그런데, 이 256가지라는게, 아주 우현이도, 세계 대부분 문자를 저장하는데 아주 이상적인 크기이며, 흑백사진의 회색조를 표현하는데도 아주 이상적이란다.<br>사람의 눈이 대략 256가지의 명암을 구분 가능하기 때문이다.</p><ul><li>4byte = nibble 이라 한다.</li></ul><h1>테스트 주도 개발로 배우는 객체 지향 설계와 실천 [스티브 프리먼, 냇 프라이스]</h1><h1>실용주의 프로그래머 [앤드류 헌트, 데이비드 토머스]</h1><h2>프로젝트 전에</h2><h1>격언</h1><blockquote><p>완성이라는 것은 더 이상 더할 것이 없을 때가 아니라, 더 이상 빼낼 것이 없을 때 얻게 되는 것이다. - 생텍쥐페리</p></blockquote><h1>Reference</h1><ul><li>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</li><li>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</li><li>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]&lt;/h1&gt;
&lt;h2&gt;피드백과 플립플롭&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>책 정리 (1)</title>
    <link href="http://jungha-cho.github.io/2018/04/11/%EC%B1%85-%EC%A0%95%EB%A6%AC-1/"/>
    <id>http://jungha-cho.github.io/2018/04/11/책-정리-1/</id>
    <published>2018-04-11T13:51:40.000Z</published>
    <updated>2018-04-14T04:29:17.980Z</updated>
    
    <content type="html"><![CDATA[<h1>읽은 것들</h1><h2>일반, 교양</h2><ul><li>조엘 온 소프트웨어</li><li>코드</li><li>실용주의 프로그래머</li></ul><h2>자바</h2><p>자바의 정석 2nd<br>자바 IO &amp; NIO<br>자바 병렬 프로그래밍</p><h2>TDD</h2><p>테스트 주도 개발로 배우는 객체 지향 설계와 실천</p><h2>패턴</h2><p>헤드 퍼스트 디자인 패턴</p><h1>읽어야 할 것들</h1><h2>일반 교양</h2><ul><li>피플 웨어</li></ul><h2>자바</h2><p>이펙티브 자바</p><h2>기타</h2><p>클린 코드<br>클린 코더<br>켄트 벡의 구현 패턴<br>UML 실전에서는 이것만 쓴다.<br>리팩터링<br>익스트림 프로그래밍<br>테스트 주도 개발</p><h1>Reference</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;읽은 것들&lt;/h1&gt;
&lt;h2&gt;일반, 교양&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;조엘 온 소프트웨어&lt;/li&gt;
&lt;li&gt;코드&lt;/li&gt;
&lt;li&gt;실용주의 프로그래머&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;자바&lt;/h2&gt;
&lt;p&gt;자바의 정석 2nd&lt;br&gt;
자바 IO &amp;amp; NIO&lt;
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
      <category term="책 정리" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/%EC%B1%85-%EC%A0%95%EB%A6%AC/"/>
    
    
      <category term="책 정리" scheme="http://jungha-cho.github.io/tags/%EC%B1%85-%EC%A0%95%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-11 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/11/2018-04-11-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/11/2018-04-11-독서-일지/</id>
    <published>2018-04-11T05:20:09.000Z</published>
    <updated>2018-04-11T13:48:54.472Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]</h1><h2>이진 덧셈기</h2><h2>이진 뺄셈…</h2><ul><li>와우 순식간이네… 가산기까지… 완벽하게 숙지가 되지는 않지만, 뺄셈을 덧셈만으로 구하는 방법, 덧셈기의 원리 등등 기본내용이 나온다.</li><li>보수가 필요한 이유, 보수는 인버터로 구현이 가능한점 등</li><li>전체적으로 모든게 흡수가 되는 느낌은 아니다. 나중에 다시 읽어봐야 겠다.</li></ul><blockquote><p>음… 일반적인 int 변수의 범위가 -부터 0 +양수 까지 범위가 제한된 이유가 나온다.<br>unsigned int는 음수를 표현하는 플래그 비트를 음수로 사용하지 않을때 2배로 큰 양수 범위를 사용할 수 있는 이유가 여기에서 설명된다.<br>숫자가 원형으로 늘어진 형태는… <a href="https://jungha-cho.github.io/2017/04/03/2complement/">링크</a> 참고</p></blockquote><ul><li>8비트 메모리를 가지는 정수는 -128~127 까지 범위를 가지는데 이게 비트 형태일때 계속 비트를 1로 더하면 127 다음에 숫자는 -128이다.</li><li>이걸 숫자가 원형으로 표현되어 있다고 얘기하는 것이다.</li></ul><blockquote><p>모든 뺄셈은 덧셈으로 계산할 수 있다.<br>143원을 가지고 있다고 하자. 여기에서 78을 빼려면, 143 + (-78) 이다. 바꿔서 -78을 10의 보수로 표현하면 <strong><em>999 - 078 +1</em></strong> 이므로 <strong><em>922</em></strong> 가 된다.<br>따라서 원래 계산식은 143+922로 표현 가능하다. 이 계산은 자리 올림을 무시할 것임으로 65원이 된다.<br>또 나아가서 150을 또 빼면, 앞에 설명한 계산식으로 150의 10이 보수는 850이되며, <strong><em>065+850</em></strong> 인데, 이는 <strong><em>915</em></strong> 원이고 실제적으로 음수 값 <code>-85</code>를 의미한다. (음수를 표현하는 제일 첫번째 비트가 1로 켜져 있으므로…)</p></blockquote><h1>테스트 주도 개발로 배우는 객체 지향 설계와 실천 [스티브 프리먼, 냇 프라이스]</h1><h2>동작하는 골격</h2><ul><li><p>동작하는 골격의 핵심은 대략적인 시스템 구조를 제안하고 그것의 유효성을 검증할 수 있을 정도로 요구 사항을 이해하는데 이바지 하는 것이다.</p></li><li><p>참으로 맞는 말만 하시는 분이네…</p></li><li><p>어떤 시스템의 대략적인 구조 뿐만 아니라, 개발에서 빌드 환경, 운영 환경까지 배포 가능한 구조를 잡고 세팅하는 과정에서 온갖 기술적인 문제가 튀어 나온다.</p></li><li><p>여기서 골격이라 함은 실 비즈니스 로직이나, 실제적인 요구사항을 테스트 해볼수 있고 개발 할 수 있으며, 배포 할수 있는 기반 환경이고 이를 <code>골격</code>이라고 표현하는것 같다.</p></li></ul><h2>첫 테스트 통과하기</h2><h2>입찰 준비</h2><h1>실용주의 프로그래머 [앤드류 헌트, 데이비드 토머스]</h1><h2>코딩하는 동안 해야 할 일들</h2><blockquote><p>우연에 맡기는 프로그래밍 != 추측하지 말고 검증하라.</p></blockquote><ul><li>예전, 어느 커뮤니티에서 이런 글을 봤다. 어느 남자가 의자 옆에 털썩 앉아 좌절 하는 사진과 함께 글이 있었는데, 글 내용은 <code>프로그램이 돌아가는데 왜 돌아가는지 모르겠어.</code> 였다. 이 예시가 말하듯, 우연에 맡기는 것은 왜 그렇게 동작하는지 설명하지 못하는 선 무당이 되기 쉽다.</li></ul><h2>우연에 맡기는 프로그래밍</h2><blockquote><p>의도적으로 프로그래밍하라</p></blockquote><ul><li>잘 돌아 간다고 <code>생각</code>만 한적이 몇번이던가… 눈, 손, 감 코딩을 하면서 간단하고 제한적인 테스트 케이스를 통해 잘 돌아간다고 <code>확신</code>을 갖게 되니 그 코드는 눈덩이가 되어 나한테 돌아 왔었다.</li><li>내가 짠 코드 뿐만 아니라 남의 코드 또한 살펴보고 수정 보완해야 하는 업무가 있었는데, 정말로 극한 직업이 따로 없었다…</li><li>실 업무에서도 느꼈던 내용인 만큼 이 챕터에서는 참고할만한 격언이 많이 나온다.</li></ul><blockquote><p>우연에 맡기지 말고 운에 맡기지 말라는 말은 실제로 테스트 케이스를 세워가며 검증하고 그 기반으로 코드를 작성해 나가라는 말인데, 이는 <code>추측하지 말고 검증하라</code> 라는 말과 일맥 상통 한다.</p></blockquote><ul><li>계획을 세우라, 언제나 자기 자신이 무엇을 하고 있는지 자각해야 하며, 맹목적이지 말라.</li><li>신뢰할 수 있는 것에만 기대고, 우연한 일이나, 가정에 기대지 말라.</li><li>나만의 가정은 혼자 생각하지 말고, 문서로 남겨라.</li></ul><h2>알고리즘의 속도</h2><ul><li>반복문이나 재귀 호출 코드를 작성할때, 무리한 일을 하는 것은 아닌지 항상 새각해 보고, O() 표기법으로 정식 계산 또한 진행하라</li></ul><table><thead><tr><th>구분</th><th>내용</th></tr></thead><tbody><tr><td>O(1)</td><td>상수적 ( 배열 원소 접근, 단순 명령문)</td></tr><tr><td>O(log(n))</td><td>대수적 (이진 검색)</td></tr><tr><td>O(n)</td><td>선형적 (순차 검색)</td></tr><tr><td>O(nlog(n))</td><td>선형보다는 좋지 않지만, 많이 나쁘진 않음 (heap 정렬, quick 정렬의 평균 수행시간)</td></tr><tr><td>O(n^2)</td><td>제곱 (선택 정렬, 삽입 정렬)</td></tr><tr><td>O(n^3)</td><td>세제곱 2차원 배열 2개의 곱</td></tr><tr><td>O(C^n)</td><td>지수적 (여행하는 판매원 문제, 집합 분할)</td></tr></tbody></table><h2>2중 반복문</h2><ul><li>요즘 알고리즘 공부를 하면서 정렬이나 기초적인 자료구조를 구현할 문제를 발견해서 코딩하고 있는데, 관련 내용이 나왔다. 간단한 정렬이란, 버블, 삽입, 선택 정렬 처럼 2중 반복문을 포함하는 정렬을 얘기한다.</li><li>또 이러한 정렬은 바깥쪽 반복문이 배열을 순서대로 순회하는데 이를 <code>round</code>라 표현하고, 안쪽 반복문은 각 라운드 내에서 최대값이나 최소 값을 찾는다.</li></ul><h2>반씩 잘라내기</h2><ul><li>하나의 반복문에서 검색 대상의 범위를 반틈씩 제거해 나간다면 <code>O(log(n))</code>이 될 가능성이 있다. 정렬 목록의 이진 검색이나, 이진 트리의 순회 등이 이에 해당한다.</li></ul><h2>DIVIDE AND CONQUER</h2><ul><li>데이터를 반으로 나눠 각각 독립적으로 작업한 다음 결과를 합친다면, <code>O(nlog(n))</code>일 확률이 높다. 이미 정렬된 값이 들어올 경우 성능이 떨어지기 때문에, O(n^2)이 될 수도 있지만, 퀵정렬의 평균 수행 시간은 O(nlog(n))이다.</li></ul><blockquote><p>현실이다. 이제 이 기본적인 정렬이나 자료구조 구현에 실 업무의 아까운 시간을 투자하진 않는다. 나 또한 그렇다. Java가 제공하는 라이브러리를 이용하고, 이미 구현 되어 있는 것을 사용한다. 다만, 이 책에서는 이를 제외하고, 일반적으로 코드를 작성할때 사용하는 반복문이나, while 루프, 이중 반복문 또는 어떤 알고리즘 등 그 코드를 수행하는데 얼마나 걸릴지, 얼마나 큰 수의 입력이 들어올지 예상하고 작성하라는 것이다.</p></blockquote><h2>테스트 하기 쉬운 코드</h2><h1>Reference</h1><ul><li>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</li><li>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</li><li>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]&lt;/h1&gt;
&lt;h2&gt;이진 덧셈기&lt;/h2&gt;
&lt;h2&gt;이진 뺄셈…&lt;/h2&gt;

      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>알고리즘 버블, 삽입, 선택 정렬</title>
    <link href="http://jungha-cho.github.io/2018/04/10/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B2%84%EB%B8%94-%EC%82%BD%EC%9E%85-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC/"/>
    <id>http://jungha-cho.github.io/2018/04/10/알고리즘-버블-삽입-선택-정렬/</id>
    <published>2018-04-10T13:34:36.000Z</published>
    <updated>2018-04-10T14:56:23.951Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>코딩 문제 풀이 중, 소트가 막히길래 다시 풀어봄</li></ul><h1>버블</h1><script src="//gist.github.com/8967ec9e718a73c9922e5ae44ddd1186.js?file=bubble.cpp"></script><h1>셀렉션</h1><script src="//gist.github.com/8967ec9e718a73c9922e5ae44ddd1186.js?file=selection.cpp"></script><h1>인서트</h1><script src="//gist.github.com/8967ec9e718a73c9922e5ae44ddd1186.js?file=insert.cpp"></script><h1>전체 소스</h1><script src="//gist.github.com/8967ec9e718a73c9922e5ae44ddd1186.js?file=all.cpp"></script><h1>Reference</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;코딩 문제 풀이 중, 소트가 막히길래 다시 풀어봄&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;버블&lt;/h1&gt;
&lt;script src=&quot;//gist.github.com/8967ec9e718a73c9922e5ae44ddd1186.js
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://jungha-cho.github.io/categories/Algorithm/"/>
    
      <category term="Sort" scheme="http://jungha-cho.github.io/categories/Algorithm/Sort/"/>
    
    
      <category term="알고리즘" scheme="http://jungha-cho.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="정렬" scheme="http://jungha-cho.github.io/tags/%EC%A0%95%EB%A0%AC/"/>
    
      <category term="버블 정렬" scheme="http://jungha-cho.github.io/tags/%EB%B2%84%EB%B8%94-%EC%A0%95%EB%A0%AC/"/>
    
      <category term="삽입 정렬" scheme="http://jungha-cho.github.io/tags/%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC/"/>
    
      <category term="선택 정렬" scheme="http://jungha-cho.github.io/tags/%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-10 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/10/2018-04-10-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/10/2018-04-10-독서-일지/</id>
    <published>2018-04-10T10:14:22.000Z</published>
    <updated>2018-04-10T12:40:16.748Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]</h1><h2>논리와 스위치</h2><ul><li>오우, 기본적인 이진법의 기초 개념을 활용한 불을 끄고 키는 것부터 시작해서, 전기를 이용한 <code>부호 code</code> 통신, 이진법, 팔진법, 십육진법을 통해 드디어 <code>논리</code>에 도착했다.</li><li>아리스토텔레스 논리학 왈 연역법이라 불리는 <code>삼단논법</code>이 기본이다.</li></ul><blockquote><p>모든 인간은 죽는다.<br>소크라테스는 인간이다.<br>따라서 소크라테스도 죽는다.</p></blockquote><ul><li>컴퓨터의 기본이 되는 논리식 AND, OR을 가르쳐 준다.</li></ul><h2>논리 게이트</h2><ul><li>음… AND게이트다. 학부시절 배웠던 <code>논리회로</code>는 지루하기만 했었는데…</li><li>전기적인 신호가 있을때와 없을때를 1, 0으로 보고, 이러한 전기적 신호가 논리적으로 어떠한 개념을 가지는지 논리 게이트를 통해 풀어내고 있다.</li></ul><blockquote><p>애매하게 고양이 종류를 찾는 고객의 요구 사항을 논리게이트로 풀어서 선택을 <code>자동화</code>했다.</p></blockquote><ul><li>AND, OR, NOT AND (NAND), NOT OR (NOR), 인버터 까지</li></ul><h1>테스트 주도 개발로 배우는 객체 지향 설계와 실천 [스티브 프리먼, 냇 프라이스]</h1><h2>경매 스나이퍼 개발 의뢰</h2><ul><li>어떠한 개발을 시작하기 전 준비해야될 사항과, 대략적인 요구사항, 그리고 최초 골격을 어떻게 생성해 진행할지에 대한 내용</li></ul><h1>실용주의 프로그래머 [앤드류 헌트, 데이비드 토머스]</h1><h2>구부러지거나 부러지거나</h2><ul><li><code>가역성 reversibility</code>, <code>결합도 coupling</code> <code>결합도 줄이기 decoupling</code>, <code>디미터 법칙</code>, <code>메타 프로그래밍</code>, <code>사전적 결합 temporal coupling</code></li></ul><h2>결합도 줄이기와 디미터 법칙</h2><blockquote><p>결합도를 낮추라</p></blockquote><ul><li>그 객체에게 직접 물어보자. 직접 객체를 헤집고 다닌다면, 의존성이 폭발할 수도 있다. 진짜로…</li></ul><blockquote><p>디미터의 법칙<br>객체의 모든 메서드는 자기 자신, 메소드로 넘어온 인자, 자신이 생성한 객체, 직접 포함하고 있는 객체만 호출 한다.</p></blockquote><ul><li>다만, 어느 곳에서나 그렇듯이 이책에서도 <code>트레이드 오프</code>를 강조 하고 있다.</li><li>디미터 법칙은 주 계약자가 모든 하부 객체를 관리하고 역할을 위임하며, 단순 요청을 전달만 하는 메서드를 강제함으로, <code>성능 저하</code>와 <code>메모리 과부하</code> 같은 점을 강조한다.</li><li>이는 어떤 종류의 소프트웨어에서는 치명적일 수도 있으므로, 선택적으로 사용해야 한다.</li></ul><h2>메타 프로그래밍</h2><ul><li>동적 설정, 배경 색, 프롬프트 텍스트, 알고리즘 선택, 사용할 데이터베이스 제품, 미들웨어 기술, 사용자 인터페이스 스타일 등 시스템 및 층까지 선택 가능하게 하라.</li></ul><blockquote><p>통합하지 말고 설정하라.</p></blockquote><h1>격언</h1><blockquote><p>좋은 울타리는 좋은 이웃을 만든다 - 로버트 프로스트<br>아무리 뛰어난 천재라도 세부사항에 집착하면 그 재능이 발휘되지 않는 법이다 - 레비의 8번째 법칙</p></blockquote><h1>Reference</h1><ul><li>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</li><li>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</li><li>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]&lt;/h1&gt;
&lt;h2&gt;논리와 스위치&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;오우, 기본
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>String, StringBuilder, StringBuffer</title>
    <link href="http://jungha-cho.github.io/2018/04/10/String-StringBuilder-StringBuffer/"/>
    <id>http://jungha-cho.github.io/2018/04/10/String-StringBuilder-StringBuffer/</id>
    <published>2018-04-10T00:31:08.000Z</published>
    <updated>2018-04-17T08:32:05.161Z</updated>
    
    <content type="html"><![CDATA[<h1>참조 및 직접 찾아봄</h1><ol><li>String 객체는 불변이기 때문에 변하지 않는 문자열은 String을 사용한다.</li><li>StringBuilder는 비동기방식이기 때문에 Single Thread 환경하에서, 변화되는 문자열의 사용한다.</li><li>StringBuffer 동기방식으로 저장되기 때문에 멀티쓰레드로 접근하거나 문자열이 변경될 경우에 사용한다.</li></ol><h2>“string”.concat(“sum”);</h2><blockquote><p>1.8 버전에서 확인</p><blockquote><p>concat 함수는 내부에서 문자열을 합친 후 <code>new String(합친 문자열)</code> 새로운 스트링을 반환함<br><code>String concatTest = &quot;s&quot;.concat(&quot;s&quot;).concat(&quot;s&quot;);</code> 형태로 사용 가능<br>문자열 자체는 Java에서 <code>불변(immutable)</code>으로 다루고 있음</p></blockquote></blockquote><h2>그렇다면 “스트링” + &quot;스트링&quot;은 어떻게 동작할까?</h2><ul><li><ul><li>연산은 내부적으로 스트링 빌더를 사용해 문자열을 붙여 toString으로 리턴한다.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String example = <span class="string">"스트링"</span> + <span class="string">"스트링2"</span>;</span><br><span class="line">String real = <span class="keyword">new</span> StringBuilder(String.valueOf(<span class="string">"스트링"</span>)).append(<span class="string">"스트링2"</span>).toString(); <span class="comment">// +연산자 실제 동작방식</span></span><br></pre></td></tr></table></figure><h2>“”.concat과 StringBuilder의 차이는?</h2><ul><li>효율성? 문제.</li><li>concat은 새로운 new String을 만들어 반환하는 형태이기 때문에, 새로운 String을 담을 공간이 필요함.</li><li>실제 함수를 타고 들어가보면 concat은 new String을 반환하고, append는 기존 메모리의 캐릭터 시퀀스 뒤에 갖다 붙이는걸 볼 수 있음</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** String 객체에서 사용할 수 있는 concat 메소드 **/</span></span><br><span class="line"><span class="comment">/** Java 1.8 **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>주소</th><th>값</th></tr></thead><tbody><tr><td>0x00</td><td>하나</td></tr><tr><td>0x01</td><td>하나둘</td></tr><tr><td>0x02</td><td>하나둘셋</td></tr><tr><td>0x03</td><td>하나둘셋넷</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** StringBuilder가 상속받는 추상 클래스의 append 메소드 **/</span></span><br><span class="line"><span class="comment">/** Java 1.8 **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>주소</th><th>값</th></tr></thead><tbody><tr><td>0x00</td><td>하나</td></tr><tr><td>0x00</td><td>하나둘</td></tr><tr><td>0x00</td><td>하나둘셋</td></tr><tr><td>0x00</td><td>하나둘셋넷</td></tr></tbody></table><h2>StringBuffer와 StringBuilder?</h2><ul><li>두개 다 똑같이 AbstractStringBuilder 추상 클래스를 상속받고 있음.</li><li>즉, append 메소드는 동일함</li><li>그러나 StringBuffer는 synchronized 키워드로 멀티스레드 환경에서 안정성을 확보하고 있음</li><li>StringBuilder는 키워드 없음!</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** StringBuffer의 append **/</span></span><br><span class="line"><span class="comment">/** synchronized 키워드 확인 **/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** StringBuffer의 append **/</span></span><br><span class="line"><span class="comment">/** synchronized 키워드는 없음 **/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>끝으로</h1><ul><li><code>추측</code>하지 말고 <code>증명</code>하자의 실천!</li></ul><h1>Reference</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;참조 및 직접 찾아봄&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;String 객체는 불변이기 때문에 변하지 않는 문자열은 String을 사용한다.&lt;/li&gt;
&lt;li&gt;StringBuilder는 비동기방식이기 때문에 Single Thread 환경하에서, 변화되는 문자
      
    
    </summary>
    
      <category term="자바" scheme="http://jungha-cho.github.io/categories/%EC%9E%90%EB%B0%94/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/%EC%9E%90%EB%B0%94/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="자바" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="String" scheme="http://jungha-cho.github.io/tags/String/"/>
    
      <category term="StringBuffer" scheme="http://jungha-cho.github.io/tags/StringBuffer/"/>
    
      <category term="StringBuilder" scheme="http://jungha-cho.github.io/tags/StringBuilder/"/>
    
  </entry>
  
  <entry>
    <title>알고리즘 - 스택</title>
    <link href="http://jungha-cho.github.io/2018/04/09/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%A4%ED%83%9D/"/>
    <id>http://jungha-cho.github.io/2018/04/09/알고리즘-스택/</id>
    <published>2018-04-09T14:44:16.000Z</published>
    <updated>2018-04-10T13:34:03.482Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>코딩 문제 풀이 중, 기본 자료구조를 구현하는 문제에서 조금 많이 막히길래, 다시 작성해봄</li></ul><script src="//gist.github.com/050f0cddf1fd8f47e56860e5defb3acf.js"></script><h1>Reference</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;코딩 문제 풀이 중, 기본 자료구조를 구현하는 문제에서 조금 많이 막히길래, 다시 작성해봄&lt;/li&gt;
&lt;/ul&gt;
&lt;script src=&quot;//gist.github.com/050f0cddf1fd8f47e56860e5
      
    
    </summary>
    
      <category term="Data Structure" scheme="http://jungha-cho.github.io/categories/Data-Structure/"/>
    
      <category term="C++" scheme="http://jungha-cho.github.io/categories/Data-Structure/C/"/>
    
    
      <category term="알고리즘" scheme="http://jungha-cho.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="자료구조" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"/>
    
      <category term="C++" scheme="http://jungha-cho.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>객체지향설계 블랙잭(13)</title>
    <link href="http://jungha-cho.github.io/2018/04/09/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD-13/"/>
    <id>http://jungha-cho.github.io/2018/04/09/객체지향설계-블랙잭-13/</id>
    <published>2018-04-09T13:03:57.000Z</published>
    <updated>2018-04-09T13:37:04.423Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 지향 설계 연습하기 - 블랙잭 (13)</h1><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github source code</a></p><h1>들어가며</h1><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h1>TDD</h1><ul><li>어느 정도 TDD의 순간이 보이고, 책과 각종 유튜브 강의로 눈에 익자 TDD를 시도하며 코드 작성을 시도했습니다.</li><li>완벽한 설계는 없다는 원칙을 고수하고 이전에 남아 있던, UML을 바탕으로 큰 그림을 먼저 그리려 했습니다.</li></ul><h1>인수 테스트와 유닛 테스트의 조합으로 회귀 테스트를 더 강력하게</h1><ul><li>초기 테스트를 작성하다 보면, 아주 많은 작업이 필요한 경우가 있다.</li><li>보통은 getting Stuck 이라고 하는 잘못된 케이스 일 수도 있지만, 테스트 작성을 위한 더 세부적인 내용을 작성해야 할 수 있다.</li><li>책에서는 인수 테스트를 <code>전체 시스템이 동작하는가?</code>라고 정의하고 있다.</li></ul><blockquote><ol start="0"><li>실패하는 인수 테스트를 작성한다.</li></ol><blockquote><ol><li>테스트를 작성한다.</li><li>해당 테스트가 동작하게 만들 코드를 작성한다.</li><li>코드를 가급적 테스트한 기능의 단순 구현으로 리팩토링 한다.</li><li>반복한다.</li><li>인수 테스트를 반복한다.</li></ol></blockquote></blockquote><p><img src="/images/testcase.JPG" alt="testcase.JPG"></p><h1>인수 테스트를 이곳에 적용 했습니다.</h1><ul><li>순환 고리 형태로, 게임을 만들고, 카드 게임의 제일 기본 원칙인 초기화 세팅 테스트 함수</li><li>딜러가 카드를 나눠 줘야 하는데, 카드 게임의 기반이 없으므로, <code>canInitialize()</code> 메소드를 인수테스트로 작성.</li><li>그 후 canInitialize() 함수가 동작하기 위한 기반인 Card 클래스를 작성함</li></ul><script src="//gist.github.com/01b37237cffb30d389a4276ee714cc1b.js?file=BlackJackTest.java"></script><h1>카드 클래스의 테스트 코드</h1><ul><li>기본적인 카드 클래스가 가져야할 속성과 모양이 정상적으로 세팅 되는지 부터 검사</li><li>이부분에서 처음에는 지저분하고 가독성이 낮은 코드가 작성되었음.</li><li>리팩토링하며, 테스트 코드 뿐만 아니라, 실 메소드 사용에서도 사용될 <code>isEqual()</code> 메소드를 작성하고, 테스트 코드 또한 한눈에 잘 보이게끔 지속적으로 리팩토링함</li></ul><script src="//gist.github.com/01b37237cffb30d389a4276ee714cc1b.js?file=CardUnitTest.java"></script><h1>Card와 모양, 끗수</h1><ul><li>모양과 끗수 클래스는 큰 차이점 없습니다.</li><li>Card 클래스에는 속성을 하나의 변수로 유지하려 Pair로 변경했습니다. 카드는 한쌍이 있어야 하나의 카드이니까요.</li><li>카드 비교가 마땅치 않아, isEqual 메소드를 생성했습니다.</li><li>여기서도 라인수 및 가독성을 위해 리팩토링을 많이 진행했지만, 아직 지저분해 보입니다.</li></ul><script src="//gist.github.com/01b37237cffb30d389a4276ee714cc1b.js?file=Card.java"></script><script src="//gist.github.com/01b37237cffb30d389a4276ee714cc1b.js?file=Suit.java"></script><script src="//gist.github.com/01b37237cffb30d389a4276ee714cc1b.js?file=Denomination.java"></script><h1>V3 시작의 첫날</h1><ul><li>TDD를 제대로 준수하며, 작성하고 리팩토링하면서, 제 눈으로 코드가 깔끔해지고 뒤가 든든해지는 코딩 방법을 체득하고 있다고 느꼈습니다.</li><li>테스트는 제 코드에 신뢰성을 더해줄 것이며, 리팩토링은 저 포함 유지 보수 인력이 파악하기 편한 코드가 될것이라고 직접 느낀것 같습니다.</li></ul><h1>철저히 TDD 원칙을 준수 했습니다.</h1><ul><li>테스트 코드 없이는 기능 코드를 작성하지 않는다.</li><li>쉬운 것 부터 작성한다.</li><li>리팩토링시 가독성에 주안점을 둔다.</li></ul><h1>소트웍스 엔솔로지 원칙을 준수하려 노력했습니다.</h1><ul><li>규칙 1 메소드당 들여쓰기 한 번</li><li>규칙 2 else 예약어 금지</li><li>규칙 3 원시값과 문자열의 포장</li><li>규칙 4 한 줄에 한 점만 사용</li><li>규칙 5 축약 금지</li><li>규칙 6 모든 엔티티를 작게 유지</li><li>규칙 7 2개 이상의 인스턴스 변수를 가진 클래스 사용 금지</li><li>규칙 8 일급 콜렉션 사용</li><li>규칙 9 게터/세터/속성 사용 금지</li></ul><h1>Reference</h1><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 지향 설계 연습하기 - 블랙잭 (13)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/BlackJack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github source code&lt;/a&gt;
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="디자인 패턴" scheme="http://jungha-cho.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="헤드 퍼스트 디자인 패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C-%ED%8D%BC%EC%8A%A4%ED%8A%B8-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-09 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/09/2018-04-09-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/09/2018-04-09-독서-일지/</id>
    <published>2018-04-09T09:51:52.000Z</published>
    <updated>2018-04-09T11:32:09.259Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li><li>6, 7, 8 흐름이 끊겼다… 다시 분발!</li></ul><h1>Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]</h1><h2>드디어 비트!</h2><p>손으로 셈을 하게된 인류는 10진법에 익숙한데, 만약 우리가 진짜로 8개의 손가락을 가졌다면, 8진법으로 셈법을 계산 했을까?..<br>여튼, <code>비트(bit)</code>는 2진(binary) 체계로 Yes, No 또는 On, Off… 1과 0… 가장 간단한 숫자 체계이다!!</p><ul><li>저자는 <code>비트(bit)</code>라는 단어가 컴퓨터와 연관된 단어중 가장 사랑스럽다고 한다…</li></ul><p>00 의 두자리 bit로 나타낼 수 있는 정보의 가지수는 모두들 알다시피 <code>00, 01, 10, 11</code> 네가지 이다.<br>00에 대한 정보, 01, 10, 11에 대한 정보를 대화하고자 하는 두명이 모두 속 뜻을 알아야 이 두 비트로 대화 가능하다.</p><p>호오… 바코드와 카메라 필름에도 2진수가 사용되었다고 한다.<br>바코드는 2배 3배 4배 굵은 검은 줄과 2배 3배 4배 넓은 간격을 이용해 95비트를 표현한다.</p><h1>테스트 주도 개발로 배우는 객체 지향 설계와 실천 [스티브 프리먼, 냇 프라이스]</h1><h2>객체 지향 설계의 달성</h2><ul><li>테스트가 주도 하는 개발의 진정한 의미는 <code>어떻게</code>를 고려하기 전에 TDD를 통해 <code>무엇을</code> 표현하고 해결할지 기술하는데 있다.</li></ul><h2>분해 파생 포장</h2><p>읽다가 드는 생각인데, 입문서로는 맞지 않는 내용인것 같다. 어떻게 하라, 이렇게 하라 저렇게 하라라고 가이드를 제시하고 있지만,<br>그 대상의 범위가 추상적으로 느껴질 정도면, 내 수준에 맞지 않는 책이지 않나 싶다.<br>수준 높은 단계에서 전체적인 방향성을 제시하고 세부적인 것도 찝어주는데, 내가 이해되고 현재 상태에서 필요한 내용을 집중적으로 읽어야 겠다.</p><h1>실용주의 프로그래머 [앤드류 헌트, 데이비드 토머스]</h1><ul><li>죽은 프로그램이 끼치는 피해는 절름발이 프로그램이 끼니는 해보다 훨씬 덜하다.</li></ul><h1>Reference</h1><ul><li>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</li><li>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</li><li>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;li&gt;6, 7, 8 흐름이 끊겼다… 다시 분발!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]&lt;/h1&gt;
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-05 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/05/2018-04-05-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/05/2018-04-05-독서-일지/</id>
    <published>2018-04-05T10:01:44.000Z</published>
    <updated>2018-04-09T11:22:02.471Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]</h1><h2>우리가 사용하는 열 개의 숫자들</h2><ul><li>숫자는 만국 공통어이다.</li><li>손가락이 10개가 아니었다면, 수를 세는 방법이 달랐을 것</li><li>숫자를 나타내는 <code>digit</code>라는 단어의 워원이 손가락, 발가락이라는 점이나 <code>five 다섯</code>이라는 단어와 <code>fist 주먹</code> 이라는 단어가 같은 어원을 가지고 있다는 점.</li><li>10에 기반을 두고 있는 수체계, <code>십진수 decimal; 라틴어로 10을 의미</code> 를 수체계로 사용하고 있는 것은 아주 자의적으로 이루어진 것</li><li>우리는 10에 기반을 두는 숫자에 대해 매우 중요한 의미를 부여한다. 10년은 10년(decade)라 부르고, 10번의 10년은 <code>세기 centry</code>, 10번의 세기는 <code>천년 millennium</code>이라 부른다.</li></ul><table><thead><tr><th>10 기반</th></tr></thead><tbody><tr><td>10^1 = 10</td></tr><tr><td>10^2 = 100</td></tr><tr><td>10^3 = 1,000 thousand</td></tr><tr><td>10^4 = 10,000</td></tr><tr><td>10^5 = 100,000</td></tr><tr><td>10^6 = 1,000,000 million</td></tr><tr><td>10^7 = 10,000,000</td></tr><tr><td>10^8 = 100,000,000</td></tr><tr><td>10^9 = 1000,000,000 billion</td></tr></tbody></table><h2>십진수 이외의 것</h2><p>이진수, 사진수, 팔진수, 십진수, 십육진수까지 해볼만한 내용의 충분한 수 체계를 공부하고는 결국 <code>비트 bit</code>로 돌아온다. 비트는 규칙적이며 0과 1로 표현되며 어떠한 것도 1과 0 반대를 가지는 사물을 표현 가능하다.</p><h1>테스트 주도 개발로 배우는 객체 지향 설계와 실천 [스티브 프리먼, 냇 프라이스]</h1><h2>테스트 주도 개발의 유지</h2><p>문득 그런 생각이 들었다. 아무리 좋은 책과 좋은 내용도, 내가 진정 이해하고 있는 상태에서 읽지 않으면, 하나도 와닿지 않는다는 것이다.<br>좋다. TDD, 나가가 인수 테스트로 단위 테스트의 회귀 고리를 완성하고 첫 시작부터 끝까지 TDD 내에서 프로그래밍하며 진행하라는 것.<br>좋은 객체 지향 스타일, 좋은 가독성, 좋은 구조 다 좋다. 그런데, 지금 내 상태에서는 이 책 지금 글자가 그렇게 와닿지는 않는 다는 것이다.<br>언젠가 이 글이 내 양식이 되는 날이 오겠지…? 아니면 지금 당장 TDD부터 몸에 익혀야 하는지…? 고민이다.</p><h2>객체 지향 스타일</h2><p>작성하기 쉬운 코드 보다, 유지 보수 하기 쉬운 코드를 높게 평가하라.</p><ul><li>기능을 객체로, 객체를 패키지로, 패키지를 프로그램으로, 프로그램을 시스템으로 구조화 한다.</li><li>다른 책에서 나왔던 <code>Orthogonality 직교성</code>의 실효성을 설명한다.</li></ul><h1>실용주의 프로그래머 [앤드류 헌트, 데이비드 토머스]</h1><h2>기본적인 도구</h2><ul><li>모든 환경에서 범용적으로 사용하는 텍스트 에디터 하나를 집중적으로 파고들어 익혀라.</li><li>vim 공부하기!!</li></ul><h1>Reference</h1><ul><li>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</li><li>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</li><li>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]&lt;/h1&gt;
&lt;h2&gt;우리가 사용하는 열 개의 숫자들&lt;/h2&gt;
&lt;ul&gt;

      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-04-독서-일지</title>
    <link href="http://jungha-cho.github.io/2018/04/04/2018-04-04-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/04/2018-04-04-독서-일지/</id>
    <published>2018-04-04T10:17:40.000Z</published>
    <updated>2018-04-09T11:22:09.314Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]</h1><h2>점자 부호</h2><p>점자 부호 또한 볼록하거나 평평하거나 로 표현되는 6가지 점이 조합된 단어가 하나의 <code>부호 code</code>를 의미한다. 여기에서 흥미를 끄는 것은 <code>볼록</code>하거나 <code>평평</code>하거나 두가지로 표현되는 <code>2진 binary</code>라는 것이다. <code>2진 binary</code>가 6개가 조합되어 한 단어를 이루므로 <code>2^6=64</code>가지의 <code>부호 code</code>를 나타낼 수 있다. 또한 64가지의 <code>부호 Code</code>는 <code>문맥</code>에 따라 그 의미가 다르게 표현도 가능하다. 중요한 것은 이 점자 부호에 <code>시프트 shift</code> 개념이 존재하는데, 이 부호들은 부호 뒤에 나오는 부호의 의미를 숫자에서 문자로 문자에서 숫자로 전환 시킨다. 이처럼 <code>2진 binary</code> 개념이 곳곳에서 사용되고 쓰이는 것을 보며, 좀 놀라웠다. 단순히 0과 1의 세계가 흥미롭게 활용되는 부분을 보며…</p><h2>전등을 분해해 봅시다.</h2><ul><li>전자론, 전기란 전자의 움직임으로 발생한다.</li><li>으악… 회로 이야기가 나온다…</li><li>회로 또한 스위치가 존재하며, 끈다 켠다의 이분법 <code>2진 binary</code>가 존재한다.</li></ul><h2>다른 방법을 찾아 봅시다.</h2><p>전선과 전구, 스위치를 이용해 친구의 집과 연결하고, 모스 부호를 통해 통신한다. 통신의 기원에 대한 설명, 그리고 기술의 발전에 대한 설명</p><h2>전신과 릴레이</h2><p><code>전신 telegraph; 사전적 의미는 원격 기록</code> 의 개념 자체는 1800년대에 널리 퍼져 있었음. <code>전선으로 연결된 한쪽 끝에 어떤 일을 하면 그것이 전선의 맞은편에서 어떤 일을 유발 시킬 수 있다.</code>는 전기의 원리를 이용한다.</p><blockquote><p>강철 막대기에 얇은 전선을 수백 번 감고 전선에 전류를 흘리면, 강철 막대기가 자석처럼 동작한다.<br>이런 장치를 전자석이라 한다.</p></blockquote><p>호오… 참으로 사소한 것, 몰랐던 것, 무심코 그냥 지나쳤던 것들을 모두 엮어내 <code>부호 Code</code>에 대한 큰 그림을 설명하고 있는 것 같다.</p><blockquote><p>새뮤얼 모스는 1844년 5월 24일 전신을 이용해 워싱턴 DC와 메릴랜드 주 볼티모어 사이에 연결된 전선으로 <code>놀라운 하나님의 작품;민수기 23장 23절의 일부</code>를 전달한다.</p></blockquote><p>전신의 발명은 본격적으로 현대적인 통신이 시작되었음을 알리는 사건.</p><p><code>여기서 사용된 전선은 구리선으로 무한정 늘릴수 없기 떄문에 **릴레이** 시스템이 사용된다.</code></p><p>그림과 같이 봐야 정상적으로 이해되는 내용으로 이 중계기 또는 릴레이 시스템은 <code>리피터 repeater</code>라 부르거나 <code>릴레이 relay 또는 계전기</code>라고도 한다.</p><p>이 릴레이는 매우 중요한 장치인데, 일종의 스위치 이지만, 사람의 손이 아닌 전류에 의해 스위치를 제어하며, 이 장치를 이용해 <code>컴퓨터</code> 또한 만들어 낼 수 있다.</p><h1>테스트 주도 개발로 배우는 객체 지향 설계와 실천 [스티브 프리먼, 냇 프라이스]</h1><p>객체 간의 의사 소통 기법을 얘기하는데 <code>메시지를 따르라</code>라고 한다. 이 메시지를 따르라라는 내용이 이해가 안돼 몇번 읽었다. 시점에 따라, 시야에 따라 이러한 <code>메시지를 따르는</code> 의사소통 기법 및 구현 기법이 달라진다. 즉, 설계도 달라질 수도 있다는 얘기를 했다.</p><h2>역할, 책임, 협력자</h2><blockquote><p>객체를 역할, 책임, 협력자라는 측면에서 생각하라. - 워프 브록, 맥킨<br>객체는 하나 이상의 역할을 구현한 것이며, 역할은 관련된 책임의 집합이며, 책임은 어떤 과업을 수행하거나 정보를 알아야할 의무를 말한다.<br>인덱스 카드를 활용하라.</p></blockquote><p><strong>묻지 말고 말하라, 디미터의 법칙</strong></p><blockquote><p>객체를 분리해서 구분하고, 서로 메시지를 따르게끔, 구현하는 것은 이해가 되는데, 묻지 말고 말하라는 얼추 한번에 이해가 되지 않아, 머리를 싸맷다.<br>흔히 볼수 있는 메소드 호출의 예로 <code>father.giveMeOneDolar()</code>을 보면 되겠다. 아버지에게 1달러를 달라고 호출 하는 것이다.</p></blockquote><h2>목 (Mock)</h2><p>목 객체를 사용만 할 뿐이지, 왜 어떻게 얼마나 잘 활용할수 있는지에는 관심이 없었다. 이 장에서는 기초적인 목 객체의 사용법을 이론적으로 풀어내고 있는데, <code>Stub</code> 개념은 아직까지는 잘 모르겠고, <code>모조 객체</code>를 이용해 실제 객체를 생성하고 실제 객체의 테스트할 부분은 이렇게 동작할 것이다. 라고 <code>단정</code>지은 후 실제로 모조 객체가 단정문으로 호출이 되었는지 검사할 수 있다.</p><h2>3장 도구 소개</h2><p>jUnit과 JMock2를 기반으로 햄크레스트 등등 단정문 사용법, 애노테이션을 이용해 Exception 발생 테스트 기법등을 소개하고 있다. 또한 JMock2를 소개하고 있는데, JMock2의 핵심 개념은 <code>모조 객체</code>, <code>목 객체</code>, <code>예상 구문</code>이다.</p><h2>4장 테스트 주도 주기 시작</h2><p>내가 필요로 했던 부분이 나왔다. 자세하게는 나오지 않았지만, <code>기존 시스템</code>을 대상으로 한 개발에 대한 짧은 코멘트 이다. 기존 시스템을 대상으로 TDD를 시작하는 절차는 새 시스템에 TDD를 적용하는 것과 근본적으로 다르지 않다는 코멘트이다. 만약 회귀성을 파악할만한 테스트가 없다고 해서 시스템을 뜯어 고쳐 테스트를 추가하는 것은 굉장히 위험한 일이라고 얘기한다. 가장 안전하게 시작하는 방법은 빌드, 배포 과정을 자동화 한 뒤 <code>변경 하고자 하는 전 구간 테스트를 추가하는 것이다.</code> 이렇게 해서 코드 영역을 보호해 두면 좀더 확신을 갖고 기능을 추가할때마다 코드를 리팩터링하고 단위 테스트를 도입하면서 내부 품질 문제를 해결해 나갈수 있을거라고 얘기한다.</p><h1>실용주의 프로그래머 [앤드류 헌트, 데이비드 토머스]</h1><p><strong>중복의 해악, 직교성 Orthogonality, 가역성 Reversibility, 예광탄 Tracer Bullets, 프로토 타입과 포스트잇, 도메인 언어 Domain Language, 추정 Estimating</strong></p><h2>중복의 해악</h2><blockquote><p>강요된 중복, 부주의한 중복, 참을성 없는 중복, 개발자간의 중복</p></blockquote><h2>직교성</h2><ul><li><code>독립성 independence</code>, <code>결합도 분리 decoupling</code></li><li>하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다.</li><li>직교성은 변화가 <code>국소화 localize</code> 된다. 재사용을 촉진한다.</li></ul><h2>벤더 의존</h2><p>벤더사에 의존적인 코드는 인터페이스를 통해 깨끗하게 분리하라.</p><blockquote><p>개발은 슈뢰딩거의 고양이이다. 최종 결정이란 것은 없으며, 미리 방지하라.</p></blockquote><h1>Reference</h1><ul><li>찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.</li><li>스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.</li><li>앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]&lt;/h1&gt;
&lt;h2&gt;점자 부호&lt;/h2&gt;
&lt;p&gt;점자 부호 또한 볼록하거나
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-03 독서 일지</title>
    <link href="http://jungha-cho.github.io/2018/04/03/2018-04-03-%EB%8F%85%EC%84%9C-%EC%9D%BC%EC%A7%80/"/>
    <id>http://jungha-cho.github.io/2018/04/03/2018-04-03-독서-일지/</id>
    <published>2018-04-03T14:05:03.000Z</published>
    <updated>2018-04-03T14:23:48.779Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>습관을 들이기 위해 하루 하루 일지를 작성할 예정</li></ul><h1>Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]</h1><p>프로그래머로 경력을 시작하기 전 학부에선 그저 게으르지만, 무엇인가 만드는 것이 좋아 코드에만 몰두 했던 코더 였는데, 내가 작성하고 있는 이 코드의 근원이 항상 궁금했다. 다만, 게을러 빠졌던 그때에는 <code>논리 회로</code>와 <code>공업 수학</code>이 내가 궁금해하는 것들의 기초가 될것이라는 생각은 못했던 것 같다. <code>확률</code> 또한…</p><p>오늘 Chapter 2까지 읽었는데, 중간 중간 흥미로운 얘기가 많이 나왔다. 모스 부호에 대한 이야기가 주된 내용이었는데, <code>점 dot</code>과 <code>선 dash</code>로 이루어진 모스 부호의 조합으로 2^4 = 30개 까지 표현 조합이 가능하며 이를 26개의 단어와 매치해 소통하는 <code>부호 Code</code>에 대한 이야기였다.</p><p>0과 1의 디지털 세계라는 얘기는 귓구멍이 파이도록 들었던 얘기지만, 실질적인 예를 들어 설명이 나오니 책에 빠져 들어 읽은 것 같다.</p><p>앞으로 나올 얘기가 어떤 부분인지 충분히 예상 가능하게도, 천천히 점진적으로 충분히 이해 가능하게 <code>부호 Code</code>에 대해 설명하려는 책 인것 같다.</p><h1>테스트 주도 개발로 배우는 객체 지향 설계와 실천 [스티브 프리먼, 냇 프라이스]</h1><p><code>TDD</code>… 애증이다. 실 업무에서는 항상 End To End 테스트를 수행한다. 실 운영 환경에서 조합 가능한 모든 Input을 쿼리로 짜놓고, 돈이 줄줄 세는 Output ( 실 업무 실 테스트는 비용이 나가는 구조이다. )을 확인하며 수동 테스트 중인 것이다.</p><p>업무를 수행하며 누구보다 <code>TDD</code>에 목말라 왔고 갈증이 있었지만, <code>실패되는 테스트 코드를 작성한다</code> -&gt; <code>성공되는 코드를 작성한다</code> -&gt; <code>리팩토링</code>의 고리에 들어가지 못하고, <code>코드를 작성한다.</code> -&gt; <code>테스트 코드를 작성해 테스트한다</code> -&gt; <code>끝</code> 이라는 아주 단순 무식한 방법의 소용돌이에서 헤엄치고 있다.</p><p>Chapter 1에서는 간단한 용어 설명 및 개념 설명과 더불어 핵심을 설명했고, TDD가 필요한 이유, TDD의 장점 등을 기술했다. 이 책을 통해 내 몸에 <code>TDD</code>를 세겼으면 하는 기대가 있다.</p><h1>실용주의 프로그래머 [앤드류 헌트, 데이비드 토머스]</h1><p>사실, 도서관에서 3번째 빌리는 책이다. 이 포스트에서도 언급했듯 게으르다. 다만, 재미있어하고 관심있어 하는 부분은 지독하게 파고든다. 내가 재미없어 하는 부분은 어떻게 해결해야 하며 어떻게 수행해야 <code>잘</code> 대처했다고 볼 수 있을까?<br>그 답을 기대하며, 다시 읽어본다. 사실, 이전 2번째 빌렸을땐 Chapter 1을 못넘겼다.<br>지금은 스스로 지식의 욕구가 넘쳐나서 꼭 읽어 보고 싶었던, <code>1장부터 끝까지</code> 읽어 보고 싶었던 책이라 다시 빌렸으며, 1장을 독파 했다.<br>1장에서는 개발자라기 보단, 한 사람이 가져야할 올바른 <code>태도</code>나 <code>생각</code>에 대해 설명하고 있다. 서론에서도 <code>개발자</code>에 국한되지 않은 구독자를 타게팅 한다고 나와있다.</p><h1>개인 프로젝트</h1><h2>알고리즘</h2><p>C로 하루에 적어도 한문제는 꾸준히 풀고 있다. 백준 사이트는 취준생 시절 대기업 프로그래밍 시험 준비로 애용했던 기억이 있어 지금도 애용 중이다.</p><h2>블랙잭</h2><p>… 말이 필요 없다. 비판적인 태도를 가지고 내 설계와 코드를 보고 있자니, 한심할 뿐이다. 반성하고 시간이 날때마다 UML을 쏘아 보며 해결책을 찾아보려 애쓰는 중…</p><h1>이상 2018-04-03 일지 끝</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;습관을 들이기 위해 하루 하루 일지를 작성할 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]&lt;/h1&gt;
&lt;p&gt;프로그래머로 경력을 시작하기 전 학부에선 그저 게으르
      
    
    </summary>
    
      <category term="일지" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EC%A7%80/"/>
    
    
      <category term="일지" scheme="http://jungha-cho.github.io/tags/%EC%9D%BC%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>지식 포트폴리오 20180403</title>
    <link href="http://jungha-cho.github.io/2018/04/03/%EC%A7%80%EC%8B%9D-%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4-20180403/"/>
    <id>http://jungha-cho.github.io/2018/04/03/지식-포트폴리오-20180403/</id>
    <published>2018-04-03T13:55:51.000Z</published>
    <updated>2018-04-04T08:07:30.947Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>실용 주의 프로그래머의 <code>지식 포트폴리오</code>를 실천해 보기 위함</li><li>지속적으로 UPDATE 될 포스트</li></ul><h1>가이드 라인</h1><ul><li>매년 새로운 언어를 최소 하나는 배우기</li><li>기술 서적을 분기마다 한 권씩 읽기</li><li>비 기술 서적도 읽기</li><li>수업을 듣기</li><li>지역 사용자 모임에 참여</li><li>다른 환경에서 실험하기</li><li>최신 트렌드를 놓치지 않기</li><li>인터넷을 이용하기</li></ul><h1>20180403</h1><h2>주기적인 투자</h2><ul><li>현재 Java, TDD, INTELLIJ, C, Algorithm, Books</li></ul><h2>다각화</h2><ul><li>현재 Native Java Program 개발자</li><li>계획 SpringBoot, JavaScript, Scala</li></ul><h2>리스크 관리</h2><ul><li>계획 Java 지식 고도화, SpringBoot 시작하기</li></ul><h2>싸게 사서 비싸게 팔기</h2><ul><li>새롭게 떠오르는 기술이 인기를 끌기 전에 미리 알고 학습</li><li>?? 찾아보기</li></ul><h2>검토 및 재조정</h2><ul><li>20180403, 현재를 직시해보기</li></ul><h1>Reference</h1><blockquote><ul><li><a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=38786788" target="_blank" rel="noopener">실용주의 프로그래머</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;실용 주의 프로그래머의 &lt;code&gt;지식 포트폴리오&lt;/code&gt;를 실천해 보기 위함&lt;/li&gt;
&lt;li&gt;지속적으로 UPDATE 될 포스트&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;가이드 라인&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;매년 새로운 
      
    
    </summary>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EB%B0%98/"/>
    
      <category term="지식 포트폴리오" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EB%B0%98/%EC%A7%80%EC%8B%9D-%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4/"/>
    
    
      <category term="지식 포트폴리오" scheme="http://jungha-cho.github.io/tags/%EC%A7%80%EC%8B%9D-%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4/"/>
    
  </entry>
  
  <entry>
    <title>실용주의 프로그래머 (1)</title>
    <link href="http://jungha-cho.github.io/2018/04/03/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-1/"/>
    <id>http://jungha-cho.github.io/2018/04/03/실용주의-프로그래머-1/</id>
    <published>2018-04-03T13:25:20.000Z</published>
    <updated>2018-04-03T13:55:31.382Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가기전에</h1><ul><li>책 내용을 요약해 스스로 정리하는 포스트</li></ul><h1>[Pragmatic; 실용주의]</h1><ul><li>라틴어 [pragmaticus; 일에 숙달된] 에서 유래됨</li><li>무엇을 <code>하는</code>것에 대한 책</li></ul><blockquote><p>애매 모호한 요구사항을 포착해 단순한 기계까지도 그것을 잘 수행할 수 있도록 요구 사항을 표현하는 방법</p></blockquote><h1>얼리어답터 / 새로운 것에 빨리 적응하는 성향</h1><ul><li>캐묻기 좋아한다., 비판적인 사고의 소유자이며 현실적이고 다방면의 기술에 익숙하다</li></ul><blockquote><p>우리가 단지 돌을 자를지라도 언제나 대성당을 마음속에 그려야 한다. - 채석장 일꾼의 신조<br>카이젠은 지속적으로 조금씩 자주 개량하는 것을 뜻하는 일본어.</p></blockquote><h1>Chapter 1 실용 주의 철학</h1><blockquote><p>가장 큰 약점은 약점을 보일 것에 대한 두려움이다 - 보쉬에<br>어설픈 변명을 만들지 말고 대안을 제시하라.</p></blockquote><h1>Chapter 2 소프트웨어 엔트로피</h1><blockquote><p>깨진 창문 이론</p></blockquote><h1>Chapter 3 돌멩이 수프와 삶은 개구리</h1><h1>Chapter 4 적당히 괜찮은 소프트웨어</h1><h1>Chapter 5 지식 포트폴리어</h1><h1>Chapter 6 소통하라</h1><h1>Reference</h1><blockquote><ul><li><a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=38786788" target="_blank" rel="noopener">실용주의 프로그래머</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가기전에&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;책 내용을 요약해 스스로 정리하는 포스트&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;[Pragmatic; 실용주의]&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;라틴어 [pragmaticus; 일에 숙달된] 에서 유래됨&lt;/li&gt;
&lt;li&gt;무엇을
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="실용주의 프로그래머" scheme="http://jungha-cho.github.io/categories/Book/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8/"/>
    
    
      <category term="실용주의 프로그래머" scheme="http://jungha-cho.github.io/tags/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8/"/>
    
  </entry>
  
  <entry>
    <title>CODE - 하드웨어와 소프트웨어에 숨어있는 언어 (1)</title>
    <link href="http://jungha-cho.github.io/2018/04/03/CODE-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%99%80-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EC%97%90-%EC%88%A8%EC%96%B4-%EC%9E%88%EB%8A%94-%EC%96%B8%EC%96%B4-1/"/>
    <id>http://jungha-cho.github.io/2018/04/03/CODE-하드웨어와-소프트웨어에-숨어-있는-언어-1/</id>
    <published>2018-04-03T12:35:05.000Z</published>
    <updated>2018-04-03T13:11:15.799Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가기전에</h1><ul><li>책 내용을 요약해 스스로 정리하는 포스트</li></ul><h1>클래식 = 오래된 것</h1><ul><li>클래식이란 시간을 뛰어넘는 영원의 생명력을 얻은 작품</li></ul><h1>컴퓨터란 어떻게 동작하는가?</h1><ul><li>0과 1의 근원</li></ul><h1>Chapter 1 친한 친구와의 대화</h1><ul><li>손전등으로 대화할때 A = 1번 깜빡임 B = 2번 깜빡임 이라면, <code>How are you</code>는 131번 깜빡여야 된다.</li><li>모스 부호는 짧은 깜빡임과 긴 깜빡임이라는 두 가지 형태를 가지고 있다.</li><li>이러한 형태를 이용해 32번 깜빡임으로 <code>How are you</code>를 전달 할 수 있다.</li><li>깜빡임이라고 표현 했지만, 모스부호에서는 <code>점 dot</code>과 <code>선 dash</code>라 한다.</li></ul><blockquote><p>부호 ( code )는 사람과 컴퓨터 간 정보 전달 체계를 의미</p></blockquote><ul><li>사물에 장소에 물건에 이름을 붙이는 것도 <code>부호 code</code></li><li>단어도 <code>부호 code</code></li><li>언어도 <code>부호 code</code></li><li>종이도 <code>부호 code</code> -&gt; 잡지 종이 책</li><li>듣거나 말할 수 없는 사람들이 서로 마주보고 대화하는 방법 또한 <code>부호 code</code> -&gt; 수화</li><li>보지 못하는 사람은 점자 <code>부호 code</code></li></ul><blockquote><p>세 번의 점, 세 번의 선, 세 번의 점은 <code>SOS</code>로 국제 조난 신호<br>외우기 쉬운 조합을 나타내다 보니 <code>SOS</code>로 표현된 것</p></blockquote><p><strong><ins><em>중요한 것은 <code>두 가지</code>라는 것이다. <code>점 dot</code>과 <code>선 dash</code>를 이용해 소통 가능한 부호를 만들었다.</em></ins></strong></p><h1>Chapter 2 부호와 조합</h1><ul><li>새뮤얼 핀리 브리즈 모스 (Samuel Finley Breese Morse)가 모스 부호를 만들었다.</li><li>전신(Telegraph)와 모스는 밀접한 연관이 있음.</li><li>전신 역시 컴퓨터 하드웨어를 이해하는데 좋은 길잡이가 될 수 있다.</li></ul><h2>조합</h2><ul><li>점 하나는 E, 선 하나는 T, <code>2가지</code></li><li>두 개의 점과 선을 조합하는 경우, I, A, N, M을 표현 가능하며 <code>4가지</code></li><li>세 개의 점과 선을 조합하는 경우 <code>8가지</code> 표현 가능</li><li>네 개의 점과 선을 조합하는 경우 <code>16가지</code> 표현 가능</li></ul><blockquote><p>2, 4, 8, 16가지를 표현 가능하니 총 30가지의 문자를 표현할 수 있다.<br>알파벳은 26개로 4개가 남으니 강조 문자가 존재 함</p></blockquote><table><thead><tr><th>점과 선의 수</th><th>부호의 수, 곱</th><th>부호의 수, 지수</th><th>부호의 수, 총합</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>2^1</td><td>2</td></tr><tr><td>2</td><td>2x2</td><td>2^2</td><td>4</td></tr><tr><td>3</td><td>2x2x2</td><td>2^3</td><td>8</td></tr><tr><td>4</td><td>2x2x2x2</td><td>2^4</td><td>16</td></tr></tbody></table><blockquote><p><ins><code>표현할 수 있는 부호의 수 = 2^점과 선의 수</code></ins><br>2의 거듭 제곱은 많은 부호에서 살펴 볼 수 있는 특징<br>모스 부호는 점과 선이라는 두 가지 요소로 이루어져 있으므로, <code>이진(binary; 사전적 의미로 2개로 구성된)</code> 부호라 이야기함</p></blockquote><h1>Reference</h1><blockquote><ul><li><a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=53051178" target="_blank" rel="noopener">CODE - 하드웨어와 소프트웨어에 숨어있는 언어</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가기전에&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;책 내용을 요약해 스스로 정리하는 포스트&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;클래식 = 오래된 것&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;클래식이란 시간을 뛰어넘는 영원의 생명력을 얻은 작품&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;컴퓨터란 어
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="CODE - 하드웨어와 소프트웨어에 숨어있는 언어" scheme="http://jungha-cho.github.io/categories/Book/CODE-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%99%80-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EC%97%90-%EC%88%A8%EC%96%B4%EC%9E%88%EB%8A%94-%EC%96%B8%EC%96%B4/"/>
    
    
      <category term="하드웨어와 소프트웨어" scheme="http://jungha-cho.github.io/tags/%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%99%80-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="찰스 펫졸드" scheme="http://jungha-cho.github.io/tags/%EC%B0%B0%EC%8A%A4-%ED%8E%AB%EC%A1%B8%EB%93%9C/"/>
    
  </entry>
  
  <entry>
    <title>테스트 주도 개발로 배우는 객체 지향 설계와 실천 (1)</title>
    <link href="http://jungha-cho.github.io/2018/04/03/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8B%A4%EC%B2%9C-1/"/>
    <id>http://jungha-cho.github.io/2018/04/03/테스트-주도-개발로-배우는-객체-지향-설계와-실천-1/</id>
    <published>2018-04-03T10:56:34.000Z</published>
    <updated>2018-04-03T11:41:29.827Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가기전에</h1><ul><li>책 내용을 요약해 스스로 정리하는 포스트</li></ul><h1>서론</h1><ul><li>테스트 주도 개발은 언뜻 보기에는 단순한 아이디어다.</li></ul><h1>테스트 주도 개발의 핵심은 무엇인가?</h1><ul><li>불확실한 변화를 예측하려면 불확실성을 해결하는데 도움이 될 프로세스가 있어야 한다.</li></ul><h1>테스트 주도 개발의 핵심 주기</h1><ol><li>테스트를 작성한다.</li><li>해당 테스트가 동작하게 만들 코드를 작성한다.</li><li>코드를 가급적 테스트한 기능의 단순 구현으로 리팩토링 한다.</li><li>반복한다.</li></ol><blockquote><p>이 과정을 통해 시스템 구현의 안정성과 설계의 품질에 대한 피드백을 받는다.</p></blockquote><h1>테스트 주도 개발의 황금률</h1><ul><li>실패하는 테스트 없이는 새 기능을 작성하지 말라.</li></ul><h1>인수 테스트 ( Acceptance Test )</h1><ul><li>만들고자 하는 <code>기능</code>을 시험하는 테스트</li></ul><h2>실패하는 <code>기능</code> 또는 <code>인수 테스트</code></h2><ul><li>고리 중첩 TDD</li></ul><blockquote><ol start="0"><li>실패하는 인수 테스트를 작성한다.</li></ol><blockquote><ol><li>테스트를 작성한다.</li><li>해당 테스트가 동작하게 만들 코드를 작성한다.</li><li>코드를 가급적 테스트한 기능의 단순 구현으로 리팩토링 한다.</li><li>반복한다.</li><li>인수 테스트를 반복한다.</li></ol></blockquote></blockquote><ul><li>실패하는 단위 테스트는 소스 저장소에 커밋하지 않는다.</li></ul><h1>전 구간 테스트</h1><ul><li>외부에서 유래되는 시스템과 상호 작용하는 것 이상을 뜻함</li><li>시스템과 해당 시스템을 구축하고 배포하는 프로세스를 모두 시험하는 방식</li></ul><blockquote><p>push 시점에서 단위 테스트 실행 후 패키지화 하고, 현실적인 운영 환경 수준에 배포된 후 외부 접근 지점을 통해 시스템을 시험<br><code>DevOps</code>보다 더 나아가 실제 환경 테스트를 얘기하는 듯</p></blockquote><h1>배포는 인수 테스트가 모두 통과할때 배포한다.</h1><h1>테스트의 수준</h1><ul><li>인수 테스트 : 전체 시스템이 동작 하는가?</li><li>통합 테스트 : 변경할 수 없는 코드를 대상으로 코드가 동작하는가?</li><li>단위 테스트 : 객체가 제대로 동작하는가? 객체를 이용하기 편리한가?</li><li><code>변경할 수 없는 외부 라이브러리나 코드 테스트를 가리켜 통합 테스트라 한다.</code></li><li><strong>용어는 조직마다, 팀마다 그 의미가 대동소이하다.</strong></li></ul><h1>결합도와 응집도</h1><ul><li>결합도와 응집도는 일부 코드의 동작 방식을 얼마나 쉽게 바꿀 수 있는지를 대략적으로 설명하는 척도다.</li><li><code>래리 콘스탄틴(Larry Constantine), [Yonrdon79]</code></li></ul><h2>결합도</h2><p>한 변경이 다른 것의 변경을 강제한다면 요소들이 결합된 상태다. 예를 들어, 두 클래스가 공통 부모로부터 상속할 경우 한 클래스를 변경하면 다른 클래스를 변경해야 할지도 모른다. 각기 분리된 <code>컴포넌트</code>로 어떤 기계를 조립한다면, 한 <code>컴포넌트</code>가 고장났을때, 전체를 교체할 필요 없이 고장난 <code>컴포넌트</code>만 교체하면 되므로, <code>느슨하게</code> 결합된 기능이 유지보수하기 더 쉽다.</p><blockquote><p>큰 그림으로 봤을때, <code>소프트웨어</code>를 컴포넌트 별로 나누고, 컴포넌트를 조합한 형태로 구조화 한다면, 유지보수가 쉬워질 것이라는 얘기인 것 같다.</p></blockquote><h2>응집도</h2><p>한 요소의 응집도는 해당 요소의 책임이 의미 있는 단위를 형성하는지 나타내는 척도다. URL과 날짜를 모두 파싱하는 클래스는 응집력이 없는데, 두 일은 서로 관련이 없는 개념이기 때문이다. 응집도가 <code>높은</code> 기능은 유지보수 하기 쉽다.</p><blockquote><p>한개의 클래스에는 한가지 속성만 가진다. 라는 원칙도 <code>응집도</code>와 연관이 있는 내용인것 같다. 다만 클래스에 여러가지 기능이 있더라도 관련 있는 기능이 뭉쳐야 한다는 내용인것 같다.</p></blockquote><h1>마치며</h1><ul><li>오늘은 여기까지, 책 여러권을 하루에 조금씩 읽으며 집중력있고 꾸준하게 읽어나갈 참이다.</li></ul><blockquote><p>사람은 행함으로써 배워야 한다. 안다고 여기는것도 직접 해보지 않는 이상 확신할 수 없다. - 소포클레스</p></blockquote><h1>Reference</h1><blockquote><ul><li><a href="https://books.google.co.kr/books/about/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84%EC%99%80_%EC%8B%A4%EC%B2%9C_%ED%85%8C%EC%8A%A4%ED%8A%B8.html?id=nna_nQEACAAJ&amp;redir_esc=y" target="_blank" rel="noopener">테스트 주도 개발로 배우는 객체 지향 설계와 실천</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가기전에&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;책 내용을 요약해 스스로 정리하는 포스트&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;서론&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;테스트 주도 개발은 언뜻 보기에는 단순한 아이디어다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;테스트 주도 개발의 핵심은 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="테스트 주도 개발로 배우는 객체 지향 설계와 실천" scheme="http://jungha-cho.github.io/categories/Book/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8B%A4%EC%B2%9C/"/>
    
    
      <category term="TDD" scheme="http://jungha-cho.github.io/tags/TDD/"/>
    
      <category term="테스트 주도 개발" scheme="http://jungha-cho.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C/"/>
    
  </entry>
  
  <entry>
    <title>객체지향설계-블랙잭(12)</title>
    <link href="http://jungha-cho.github.io/2018/04/02/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD-12/"/>
    <id>http://jungha-cho.github.io/2018/04/02/객체지향설계-블랙잭-12/</id>
    <published>2018-04-02T13:47:59.000Z</published>
    <updated>2018-04-02T14:33:57.224Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h1>이제부터 <a href="https://jungha-cho.github.io/2018/03/30/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%97%B0%EC%8A%B5-%ED%95%98%EA%B8%B0-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">객체 지향 생활 체조</a>를 준수하겠습니다.</h1><h1>요구 사항 분석 v2</h1><ul><li>요구 사항은 지속적으로 수정한다.</li></ul><table><thead><tr><th>구분</th><th>내용</th></tr></thead><tbody><tr><td>저자</td><td>조정하</td></tr><tr><td>시나리오</td><td>유저는 게임을 키면 딜러의 플레이 설명을 본뒤, 게임 스타트를 하면 카드 2장을 나눠 받는다.</td></tr><tr><td></td><td>유저는 나눠 받은 2장과 딜러의 2장 카드를 보며 Hit와 Stay를 선택하며, 블랙잭 게임 룰에따라 끝날때까지 게임을 진행한다.</td></tr><tr><td></td><td>초반 코인은 1,000원으로 진행하며 돈이 없어질때까지 또는 게임을 포기할때 까지 블랙잭 게임은 계속된다.</td></tr><tr><td>회피목표</td><td>실제 블랙잭 모델은 딜러 1명과 7명의 유저까지 게임 플레이가 가능하지만, 현재 V2는 딜러 1명과 유저 1명이 게임 진행 가능하게 만든다.</td></tr><tr><td></td><td>V2 버전에서는 세부 규칙 외 기본 딜러 규칙과 기본 유저 규칙만 적용한다.</td></tr><tr><td>세부사항1</td><td>코드는 객체 지향 생활 체조를 준수 한다.</td></tr><tr><td></td><td>클래스 다이어그램을 상세하게 다시 작성해야 한다.</td></tr><tr><td>딜러 세부사항</td><td>딜러는 카드의 합이 16이하면 무조건 HIT, 17이상이면 무조건 STAY</td></tr><tr><td></td><td>딜러는 초기 카드 2장 중 카드 한장을 항상 가려두고 나머지만 오픈한다</td></tr><tr><td>플레이어 세부사항</td><td>플레이어는 딜러의 카드 합이 16이하이면 무조건 HIT한다</td></tr><tr><td>미해결 문제</td><td>유저의 세부 규칙이 미적용 되어 있다. 스플릿, 더블다운, 인셔런스, 푸시, 이븐머니, 서렌더 등</td></tr></tbody></table><h1>UML</h1><ul><li>객체 지향과 디자인 패턴에만 너무 빠져, 과유 불급인것 같아 불필요한 부분은 솎아냈습니다.</li><li>Rule 부분을 STRATEGY 패턴으로 묶어 적용 중입니다.</li><li>Rule은 딜러와 플레이어가 적용 받는 규칙이 다르며, 해당 규칙은 특정 행동으로 묶여있습니다.</li><li>현재까지 ACE 카드 룰과 STAY, HIT 룰을 적용했습니다.</li><li><a href="https://jungha-cho.github.io/2018/03/30/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%97%B0%EC%8A%B5-%ED%95%98%EA%B8%B0-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">객체 지향 생활 체조</a>를 준수하려고 했지만, 마음대로 되지가 않습니다.</li><li>조금더 나은 UML이 될때까지 수정 수정 수정, 블랙잭 V2 버전 코드는 설계 후에 진행하겠습니다.</li></ul><p><img src="/images/blackjack_v8.JPG" alt="blackjack_v8.JPG"></p><h1>Reference</h1><blockquote><ul><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.&lt;/li&gt;
&lt;li&gt;단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.&lt;/li&gt;
&lt;li&gt;신규 개발 뿐만 아니라 유지 보수 
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="디자인 패턴" scheme="http://jungha-cho.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="헤드 퍼스트 디자인 패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C-%ED%8D%BC%EC%8A%A4%ED%8A%B8-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>객체지향설계-블랙잭(11)</title>
    <link href="http://jungha-cho.github.io/2018/04/01/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(11)/"/>
    <id>http://jungha-cho.github.io/2018/04/01/객체지향설계-블랙잭(11)/</id>
    <published>2018-04-01T13:52:21.000Z</published>
    <updated>2018-04-02T13:02:14.319Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h1>다시 블랙잭</h1><ul><li>요구 사항 분석을 진행하고 다시 리팩토링해 보겠습니다.</li></ul><h2>이제부터 <a href="https://jungha-cho.github.io/2018/03/30/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%97%B0%EC%8A%B5-%ED%95%98%EA%B8%B0-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">객체 지향 생활 체조</a>를 준수하겠습니다.</h2><h2>요구 사항 분석</h2><ul><li>요구 사항은 지속적으로 수정한다.</li></ul><table><thead><tr><th>구분</th><th>내용</th></tr></thead><tbody><tr><td>저자</td><td>조정하</td></tr><tr><td>시나리오</td><td>유저는 게임을 키면 딜러의 플레이 설명을 본뒤, 게임 스타트를 하면 카드 2장을 나눠 받는다.</td></tr><tr><td>시나리오</td><td>유저는 나눠 받은 2장과 딜러의 2장 카드를 보며 Hit와 Stay를 선택하며, 블랙잭 게임 룰에따라 끝날때까지 게임을 진행한다.</td></tr><tr><td>시나리오</td><td>초반 코인은 1,000원으로 진행하며 돈이 없어질때까지 또는 게임을 포기할때 까지 블랙잭 게임은 계속된다.</td></tr><tr><td>회피목표</td><td>실제 블랙잭 모델은 딜러 1명과 7명의 유저까지 게임 플레이가 가능하지만, 현재 V2는 딜러 1명과 유저 1명이 게임 진행 가능하게 만든다.</td></tr><tr><td>회피목표</td><td>V2 버전에서는 세부 규칙 외 기본 딜러 규칙과 기본 유저 규칙만 적용한다.</td></tr><tr><td>세부사항1</td><td>코드는 객체 지향 생활 체조를 준수 한다.</td></tr><tr><td>세부사항2</td><td>클래스 다이어그램을 상세하게 다시 작성해야 한다.</td></tr><tr><td>미해결 문제</td><td>유저의 세부 규칙이 미적용 되어 있다. 스플릿, 더블다운, 인셔런스, 푸시, 이븐머니, 서렌더 등</td></tr></tbody></table><h1>UML V7</h1><ul><li><p>지긋지긋 할수도 있는 UML입니다.</p></li><li><p>다시 요구 분석부터 진행하려 전체적인 구조부터 새로 잡았습니다.</p></li><li><p>Card는 Hand 클래스의 Pair가 대체합니다. Card 클래스가 꼭 필요하진 않다고 판단 했습니다.</p></li><li><p>Card는 개인 준수 사항인 2개 이상의 인스턴스 변수를 가지며, Hand 클래스가 대체 가능하므로 제외했습니다.</p></li><li><p>Deck 또한 딜러만 사용하는 클래스이지만, Hand 클래스와 같은 상태와 행동을 가집니다.</p></li><li><p>Deck 또한 Hand 클래스로 대체합니다.</p></li><li><p>Mixer와 Drawer는 객체 지향 생활 체조 준수 사항을 지키기 위해, 기존 클래스의 인스턴스 변수에서 클래스로 분리 했습니다.</p></li><li><p>Rule 인터페이스가 애매해 고민중입니다.</p></li><li><p>이상 아래는 V7 버전 UML 입니다.</p></li></ul><p><img src="/images/blackjack_v7.JPG" alt="blackjack_v7.JPG"></p><h1>Reference</h1><blockquote><ul><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.&lt;/li&gt;
&lt;li&gt;단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.&lt;/li&gt;
&lt;li&gt;신규 개발 뿐만 아니라 유지 보수 
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="디자인 패턴" scheme="http://jungha-cho.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="헤드 퍼스트 디자인 패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C-%ED%8D%BC%EC%8A%A4%ED%8A%B8-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>자바와 다중 상속에 대한 고찰</title>
    <link href="http://jungha-cho.github.io/2018/04/01/%EC%9E%90%EB%B0%94%EC%99%80-%EB%8B%A4%EC%A4%91-%EC%83%81%EC%86%8D%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0/"/>
    <id>http://jungha-cho.github.io/2018/04/01/자바와-다중-상속에-대한-고찰/</id>
    <published>2018-04-01T13:01:59.000Z</published>
    <updated>2018-04-01T13:14:31.869Z</updated>
    
    <content type="html"><![CDATA[<h1>상속</h1><ul><li><p>부모-자식 관계가 형성 된다.</p></li><li><p>부모의 상태, 행동을 자식이 그대로 물려 받아 사용 가능하다.</p></li><li><p>부모의 상태, 행동을 자식이 변경해 사용 가능 하다.</p></li><li><p>자식은 부모가 될수 있으나, 부모는 자식이 될 수없다. (자식이 기능을 확장한 경우에)</p></li><li><p>상속은 재사용성 측면에서 부모의 상태와 행동을 재사용 할수 있는 테크닉</p></li><li><p>그러나 처음부터 상속을 고려해 만들어진 클래스가 아니라면 부작용이 생길 수 있다.</p></li><li><p>의도치 않은 상속은 부모 자식간의 강한 의존성을 생성하게 되고 캡슐화가 깨질수도 있다는 얘기이다.</p></li><li><p>이를 막기위해 final로 행동이나 상태를 선언하거나, 최소한 상속을 고려해 문서화를 고려해 볼 수 있다.</p></li></ul><h1>다중 상속</h1><ul><li><p>할아버지를 상속받은 아버지 1, 아버지 2가 있고 이 둘을 다중 상속 받은 자식이 있다고 하자.</p></li><li><p>두 명의 아버지가 할아버지의 행동을 오버라이드 했다면 똑같은 행동이 자식에게도 존재할 것이다.</p></li><li><p>메소드가 중복으로 발생한 경우이며, 이 행동을 자식이 호출할 경우 아버지1의 메소드인지 아버지2의 메소드인지 호출 당하는 쪽이 어느쪽인지 모호하다.</p></li><li><p>다중 상속을 지원하는 언어는 이를 피해가기 위한 문제 해결 방법을 지원한다.</p></li><li><p>이런 저런 문제로 다중 상속이 위험하고 단일 상속을 강제 하는것은 객체의 단일 책임 원칙을 준수할 수  있지만, 안타깝게도 다중 상속은 매우 유용하다.</p></li><li><p>또 단일 객체 상속은 객체가 여러가지 특성을 가져야할 때 곤란하다.</p></li><li><p>객체를 모델링할때 하나의 객체가 여러 특성을 가지는 예로 사람은 학생이면서 동시에 가족이 될수 있고, 과외를 진행하는 선생님이 될수도 있다.</p></li></ul><h1>자바와 다중 상속 그리고 인터페이스</h1><ul><li>자바는 다중 상속을 지원하며, 자바의 구현 방식은 다이아몬드 문제 뿐만 아니라 다중 상속의 복잡성도 해결한다.</li><li>모호하게 들릴 수 있지만, 자바는 부모 객체가 특별한 조건에 부합할때에만 다중 상속을 구현하게끔 강제했다.</li><li>부모의 객체가 순수하게 추상화된 객체만 다중 상속을 허용한다.</li><li>자바에서 이러한 객체를 인터페이스라 부른다.</li></ul><h1>자바와 상속, 아니 확장</h1><ul><li><p>자바에선 상속이라는 개념을, 상속의 형태를 <code>extends</code> 확장이라 표현한다.</p></li><li><p>interface를 구현할때 쓰이는 <code>implements</code>는 구현이라 한다.</p></li><li><p>개념상 상속은 내가 물려받은 재산에 초점이 맞춰져 있다.</p></li><li><p>개념상 확장은 내가 해야할 행동에 초점이 맞춰져 있다.</p></li><li><p>확장은 is-a 개념을 가지고 있으며, A가 B를 상속받았을때, B is a A 관계가 성립함을 뜻한다.</p></li><li><p>확장은 어떤 객체에 메소드를 추가해 성능을 높이거나 기능을 추가하는 것이다.</p></li><li><p>상속은 has-a 개념을 내포하고 있으며, 이는 변질될 가능성을 내포하고 있다.</p></li><li><p>아버지에게 물려받은 상태와 행동을 자식이 오버라이딩해 온갖 잡다한 행동과 상태로 채워나간다면, 아들은 아버지를 아버지라 부를수 있을까?</p></li></ul><h1>자바와 상속, 확장</h1><ul><li>개발자가 is-a 개념을 상속으로 사용한다면 자바는 다중 상속을 지원하는 언어이다.</li><li>반대로 has-a 개념으로 상속을 사용한다면, 자바는 다중 상속을 지원하지 않는다.</li><li>C++는 이를 개발자가 실천해야할 규볌으로 열어놓았을뿐, Java는 언어 차원에서 강제할 뿐이다.</li></ul><p>결론은 심사 숙고해서 잘 사용하자.</p><h1>Reference</h1><blockquote><ul><li><a href="http://gyumee.egloos.com/m/3200829" target="_blank" rel="noopener">자바가 다중 상속을 지원하지 않는 이유?</a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;상속&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;부모-자식 관계가 형성 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;부모의 상태, 행동을 자식이 그대로 물려 받아 사용 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;부모의 상태, 행동을 자식이 변경해 사용 가능 하
      
    
    </summary>
    
      <category term="Java" scheme="http://jungha-cho.github.io/categories/Java/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Java/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="extends" scheme="http://jungha-cho.github.io/tags/extends/"/>
    
      <category term="interface" scheme="http://jungha-cho.github.io/tags/interface/"/>
    
      <category term="상속" scheme="http://jungha-cho.github.io/tags/%EC%83%81%EC%86%8D/"/>
    
  </entry>
  
  <entry>
    <title>C언어에서 숫자가 입력된 CHAR에서 INT를 추출할때 &#39;0&#39;을 빼는 이유</title>
    <link href="http://jungha-cho.github.io/2018/03/31/C%EC%96%B8%EC%96%B4%EC%97%90%EC%84%9C-%EB%AC%B8%EC%9E%90%EC%97%90%EC%84%9C-int%EB%A5%BC-%EC%B6%94%EC%B6%9C%ED%95%A0%EB%95%8C-0-%EC%9D%84-%EB%B9%BC%EB%8A%94-%EC%9D%B4%EC%9C%A0/"/>
    <id>http://jungha-cho.github.io/2018/03/31/C언어에서-문자에서-int를-추출할때-0-을-빼는-이유/</id>
    <published>2018-03-31T14:36:16.000Z</published>
    <updated>2018-03-31T14:47:12.914Z</updated>
    
    <content type="html"><![CDATA[<h1>C언어에서 숫자가 입력된 CHAR에서 INT를 추출할때 '0’을 빼는 이유</h1><p><a href="https://www.acmicpc.net/problem/11720" target="_blank" rel="noopener">baekjoon 11720번 문제</a><br>학부 이후 C를 오랜만에 만지게 된 계기가, 알고리즘 문제를 다시 풀면서 익숙한 java나 다른 언어를 제외하고 원시 언어를 이용해 풀기로 스스로 정했기 때문이다.<br>문제를 풀어 나가던 중에, 숫자가 입력된 CHAR 자료형을 다루게 됐는데, INT 자료형으로 처리할 수 없는 문제라서 CHAR인 숫자에서 INT를 추출할때 0을 빼는 이유가 궁금해 졌다.</p><h1>11720 INTEGER로 풀때</h1><ul><li>보다시피 알고리즘은 먹히고 간단한 자리수 까지는 문제가 풀린다.</li><li>문제는 입력이 1 &lt;= N &lt;= 100까지라는 건데, 100자리까지 들어온 INT는 범위를 벗어나, 정상적으로 저장이 되지 않으므로 실패한다.</li></ul><script src="//gist.github.com/86952f7620f4ad0868a79b92497e37bd.js?file=INTEGER.C"></script><h1>11720 CHAR로 풀때</h1><ul><li>이제 입력되는 숫자는 문자열로 받아 한자리씩 숫자로 바꿔야 한다.</li><li>이때 각 자리수별 CHAR에 입력되 있는 숫자를 INT로 바꿔야 되는데, 문자 '0’을 빼는 이유는 CHAR = '1’이 입력되 있다는건 ASCII 숫자 49로 표현되기 때문이다.</li><li>실제로 CHAR에 입력되어있는 숫자를 %d로 출력해 보면, 0이 48로 출력되고 <code>48은 ASCII 코드에서 문자 0을 의미한다.</code></li><li>자세한 내용은 <a href="https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C" target="_blank" rel="noopener">ASCII CODE</a></li></ul><script src="//gist.github.com/86952f7620f4ad0868a79b92497e37bd.js?file=CHAR.C"></script><h1>Reference</h1><blockquote><ul><li><a href="https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C" target="_blank" rel="noopener">ASCII CODE</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;C언어에서 숫자가 입력된 CHAR에서 INT를 추출할때 &#39;0’을 빼는 이유&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/11720&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;baekjoo
      
    
    </summary>
    
      <category term="C" scheme="http://jungha-cho.github.io/categories/C/"/>
    
      <category term="자료형" scheme="http://jungha-cho.github.io/categories/C/%EC%9E%90%EB%A3%8C%ED%98%95/"/>
    
    
      <category term="C" scheme="http://jungha-cho.github.io/tags/C/"/>
    
      <category term="알고리즘" scheme="http://jungha-cho.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="알고리즘 문제 풀이" scheme="http://jungha-cho.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/"/>
    
  </entry>
  
  <entry>
    <title>조엘 온 소프트웨어 다시 읽기 3</title>
    <link href="http://jungha-cho.github.io/2018/03/31/%EC%A1%B0%EC%97%98-%EC%98%A8-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EB%8B%A4%EC%8B%9C-%EC%9D%BD%EA%B8%B0-3/"/>
    <id>http://jungha-cho.github.io/2018/03/31/조엘-온-소프트웨어-다시-읽기-3/</id>
    <published>2018-03-31T12:50:53.000Z</published>
    <updated>2018-04-01T14:19:13.208Z</updated>
    
    <content type="html"><![CDATA[<h1>명세서</h1><h2>면책 조항</h2><ul><li>순수 방어적인 내용. <code>이 명세서는 완벽하지 않습니다.</code></li></ul><h2>저자</h2><ul><li>저자는 1명이다.</li><li>큰 제품일 경우 모듈로 쪼개서 담당 모듈 별 1명의 저자.</li><li>자신이 명세한 사항에 대해 책임감과 소유 의식을 느껴야 함.</li></ul><h2>시나리오</h2><ul><li>제품 설계시 사용 방법에 대한 생생한 시나리오를 염두에 둬야 한다.</li></ul><h2>회피 목표</h2><ul><li>구현 하지 않을 기능을 명세</li><li>쓸모 없는 기능이 많이지고, 시간도, 돈도 무한정 드는 경우를 방지하기 위함.</li><li>현재 실제 구동까지만 구현하고, v2에서 성능을 최적화 한다,</li></ul><h2>개괄</h2><ul><li>들어가기 전에</li></ul><h2>세부사항</h2><ul><li>세부 사항, 세부 사항, 세부 사항, 결정을 미루지 말자.</li><li>세부에 세부까지 파고들어 의사 결정을 내리자.</li><li>이러한 결정을 문서화할 필요가 있다.</li></ul><h2>미해결 문제</h2><h2>방주</h2><ul><li>테스팅 노트, 마케팅 노트, 문서화 노트, 기술 노트 등등 각 기술 담당이 관심을 가질만한 항목 표</li></ul><h2>명세는 지속적으로 개정해야 한다.</h2><ul><li>폭포수 사고방식은 명세서에 적이다.</li><li>주기적으로 개정해 변화하는 현실에 소프트웨어와 같이 발맞춰 명세서도 개정하자.</li></ul><h1>9장 손쉬운 소프트웨어 일정 관리</h1><ul><li>과업은 일단위, 주단위 보다 세부적으로 시간 단위로 나누라.</li><li>시간 단위로 나누다 보면, 과업을 더 자세하게 쪼개어서 생각하게 되고, 이런 생각의 흐름은 망할 명세서를 작성하게 한다.</li></ul><h2>초기 예측과 현재 예측을 동시에 유지하라</h2><ul><li>초기 예측과 현재 예측을 동시에 유지하다 보면, 일정을 관리하고 측정하는 방법을 배우게 된다.</li></ul><h2>경과 ( elapsed ) 열은 매일 갱신하라</h2><h2>일정에 휴가나 휴일 같은 항목을 넣으라</h2><h2>일정에 디버깅 시간을 포함하라</h2><ul><li>코드 버그는 항상 최대한 낮게 유지해야 한다.</li></ul><blockquote><p>코드를 작성한 당일 버그를 수정하는 작업이 훨씬 쉽기 때문이다. 정확한 코드 동작 원리를 까먹은 한달 뒤엔 버그 수정이 어려워 진다.<br>버그를 찾아 해결하는 시간은 예측이 불가능하다.</p></blockquote><h2>일정에 통합 시간을 포함하라.</h2><h2>일정에 여유 기간을 포함하라.</h2><h2>관리자가 프로그래머에게 일정을 단축하도록 강요하지 마라.</h2><h1>10장 일일 빌드는 당신의 친구</h1><h2>일일 빌드의 장점</h2><ul><li>버그 수정 후 테스터는 버그를 수정했는지 확인하기 위해 재테스트에 들어간다.</li><li>개발자는 직접 테스트를 하지 않고 테스트 가능하다.</li><li>미완성 제품을 테스트 하거나 마케팅, 베타 고객 사이트 등 외부 그룹은 안정적인 빌드를 이용해 테스트가 가능하다.</li><li>일일 빌드 모음을 유지하면, 추적 가능하다.</li><li>빌드 번호를 통해 테스터와 소통 가능</li></ul><h2>일일 빌드 팁</h2><ul><li>일일 빌드는 새로 체크아웃 하며 깨끗한 일일 빌드로 만들어낸 코드만 외부로 내보낸다.</li><li>코드 퀄리티, 커버리지 등 모든 요소 검사를 최대로 키고 경고를 발생 시킨 후 빌드를 멈추게 해 수정을 도모한다.</li><li>일일 빌드가 깨졌다면 문제점을 해결할 때 가지 빌드를 멈추고 수정 작업을 진행한다.</li><li>실패는 반드시 모든 팀원에게 통보 한다.</li></ul><h1>11장 고리타분한 버그 수정</h1><ul><li>버그 수정은 버그 가치가 수정 비용을 넘어설 때만 그 의미가 있다.</li></ul><h1>12장 다섯가지 세계</h1><ul><li>상품, 사내용, 임베디드, 게임, 일회성 소프트웨어</li></ul><h1>13장 종이 프로토타입</h1><h1>14장 화성인 아키텍트를 조심하세요.</h1><h1>15장 쏘면서 움직이라</h1><h1>16장 장인정신</h1><h1>17장 컴퓨터 과학 분야에서 떠도는 세가지 미신</h1><h1>18장 더불어 살기</h1><h1>19장 자동으로 충돌 보고서를 수집하세요</h1><h1>Reference</h1><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;명세서&lt;/h1&gt;
&lt;h2&gt;면책 조항&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;순수 방어적인 내용. &lt;code&gt;이 명세서는 완벽하지 않습니다.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;저자&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;저자는 1명이다.&lt;/li&gt;
&lt;li&gt;큰 제품일 경우 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="다시읽기" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/%EB%8B%A4%EC%8B%9C%EC%9D%BD%EA%B8%B0/"/>
    
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/tags/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="Book" scheme="http://jungha-cho.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>조엘 온 소프트웨어 다시 읽기 (2)</title>
    <link href="http://jungha-cho.github.io/2018/03/30/%EC%A1%B0%EC%97%98-%EC%98%A8-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EB%8B%A4%EC%8B%9C-%EC%9D%BD%EA%B8%B0-2/"/>
    <id>http://jungha-cho.github.io/2018/03/30/조엘-온-소프트웨어-다시-읽기-2/</id>
    <published>2018-03-30T12:24:50.000Z</published>
    <updated>2018-03-30T13:36:43.889Z</updated>
    
    <content type="html"><![CDATA[<h1>3장 더 나은 코드를 위한 12단계</h1><h2>조엘 테스트</h2><ol><li>소스 코드 관리 시스템을 사용하는지?</li><li>한방 빌드를 만들어낼 수 있나?</li><li>일일 빌드를 수행 중인가?</li><li>버그 추적 시스템 운영 중인가?</li><li>코드를 새로 작성하기 전에 버그를 수정하는지?</li><li>일정을 업데이트 하는지?</li><li>명세서를 작성하고 있는지?</li><li>조용한 작업 환경에서 일하고 있는지?</li><li>경제적인 범위 내에서 최고 성능의 도구를 사용하는지?</li><li>테스터를 별도로 두고 있는지?</li><li>프로그래머 채용 인터뷰 때 코딩 테스트를 진행 하는지?</li><li>무작위 사용 편의성 테스트를 수행 하는지?</li></ol><ul><li>예 아니오로 대답해 예는 1점씩 올리면 되는 간단한 테스트</li><li>10점 이하는 심각한 문제점이 있다는 의미.</li><li>대다수 2~3점으로 도움이 필요함.</li><li>마이크로소프트는 12점 만점</li></ul><blockquote><p>이 책을 읽었을때 해당 테스트를 진행 후에 업무를 위해 몇가지를 추가했었다.<br>그땐 2점 이었지만, 지금은 6점으로 점수가 오른것 같지만 여전히 도움이 필요한 수준이다.</p></blockquote><h2>버그 추적 시스템</h2><p>효과 적인 버그 추적 시스템은 아래 항목을 포함해야 한다.</p><ul><li>버그를 재현하기 위한 완벽한 단계</li><li>예상 수행 결과</li><li>관찰한 (버그로 간주되는) 실제 수행 결과</li><li>수정을 맡을 개발 책임자</li><li>수정 했는지 여부</li></ul><h2>명세 없이 코드는 없다.</h2><h1>4장 개발자가 꼭 알아둬야 할 유니코드와 문자 집합에 대한 고찰</h1><ul><li>ASCII 7비트 제외 8비트 128~255 사이 공간은? 사용처에서 임의로 정했었음.</li><li>인터넷이 대중화 되면서 유니코드 또한 대중화</li></ul><h2>유니코드</h2><ul><li><p><code>A -&gt; 0100 0001</code> 기존은 비트로 표현.</p></li><li><p>유니코드에서 글자 A는 관념적 이상, A, B는 다르고, a와도 다르다. 다만, 폰트가 각기 다른 A, A, A는 같다. [… 표현 불가능… 책 읽어보기 바람]</p></li><li><p>유니코드 컨소시엄은 각 알파벳에 존재하는 관념적인 철자마다 고유 번호를 붙여 놓았고, U+0645라는 식으로 표현.</p></li><li><p>이 고유 번호를 <code>코드 포인트</code>라고 부름.</p></li><li><p>U+는 <code>유니코드</code>를 의미하며, 숫자는 16진수로 표현.</p></li><li><p>U+0639는 아라비아 글자인 Ain을 나타냄.</p></li><li><p>영어 글자 A는 U+0041임.</p></li><li><p><a href="http://unicode.org" target="_blank" rel="noopener">http://unicode.org</a>에서 코드 포인트 확인 가능</p></li><li><p>Hello는 유니코드 <code>U+0048 U+0065 U+006C U+006C U+006F</code>로 표현 가능.</p></li></ul><h2>인코딩</h2><ul><li>유니코드가 2바이트라는 미신을 이끌어낸 유니코드 인코딩에 대한 초기 아이디어는 단순히 코드 포인트 숫자 두개를 각각 바이트로 저장하자 였음.</li><li>따라서 Hello는 <code>00 48 00 65 00 6C 00 6C 00 6F</code>로 표현 가능</li><li>하지만, <code>48 00 65 00 6C 00 6C 00 6F 00</code>은 어떤지?</li><li>CPU 특징에 따라 리틀 엔디안이나 빅엔디안으로 저장 가능함.</li><li>유니코드 문자열 시작부분에 FE, FF를 저장하는 관례가 생김</li><li>FE FF는 UTF-16/리틀 엔디안일 경우에만 해당하며, UTF-8에서는 EF BB BF를 UTF-32/리틀 엔디안에서는 FF FE 00 00을 사용</li><li>`이를 유니코드 바이트 순서 표시라 부름</li></ul><blockquote><p>이상과 달리 현실에서는 모든 유니코드 문자열의 시작 부분에 바이트 순서를 표시하진 않음 … [??]</p></blockquote><h2>공간 낭비</h2><ul><li>U+00FF 처럼 상위에 존재하는 사용하지 않는 코드 포인트의 공간 낭비를 해결하려 함</li></ul><h2>UTF-8의 등장</h2><ul><li>UTF-8은 유니코드 코드 포인트를 따르는 문자열을 저장하기 위한 또 다른 시스템</li><li>8비트 바이트를 사용해서 매직 U+넘버를 기억 공간에 저장</li></ul><ul><li>UTF-8은 0~127 사이에 존재하는 모든 코드 포인트를 단일 바이트로 저장함</li><li>128 이상 코드 포인트만 2, 3바이트에서 시작해 최대 한계인 6바이트 까지 확장 저장</li></ul><table><thead><tr><th>16진수 최소</th><th>16진수 최대</th><th>이진수로 표현한 바이트 배열</th></tr></thead><tbody><tr><td>00000000</td><td>0000007F</td><td>0xxxxxxx</td></tr><tr><td>00000080</td><td>000007FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>00000800</td><td>0000FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>00010000</td><td>001FFFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>00200000</td><td>03FFFFFF</td><td>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><blockquote><p>위 표가 뜻하는 바를 완벽하게 이해하진 못하겠다.</p><blockquote><p>2018-03-30, 변경! 최소와 최대는 범위를 뜻함<br>한글 “위” <a href="http://www.unicode.org/charts/PDF/UAC00.pdf" target="_blank" rel="noopener">코드 포인트</a>는 <code>U+C704</code>로 00000800~0000FFFF 범위에 속함<br>따라서, 1110xxxx 10xxxxxx 10xxxxxx 형식을 사용하며, <code>U+C704</code>를 2진수로 변경시 1100 0111 0000 0100로 표현되고, 순서대로 형식에 맞게 넣어주면 된다.<br>따라서 한글 ==<em>위</em>==는 코드포인트 <code>U+C704</code>이고, 이는 UTF-8 2진수로 변환시  1110<strong>1100</strong> 10<strong>011100</strong> 10<strong>000100</strong> 로 변환된다. 결과적으로 이 문자는 <code>3바이트</code>로 인코딩 된다.</p><blockquote><p>결국 첫 128 문자는 1바이트로 표시되고 <code>**(ASCII)**</code>, 그 다음 1920 문자는 2바이트로 표시되며, 나머지 문자들 중 BMP 안에 들어 있는 것은 3바이트, 아닌 것은 4바이트로 표시된다.</p></blockquote></blockquote></blockquote><blockquote><p>아하!!!, 더 자세한 내용은 위키 백과 참조!</p></blockquote><ul><li><p>이런 방식을 적용할 경우 UTF-8로 표현한 영어 텍스트가 ASCII와 완전히 똑같이 맞아 떨어짐 [???]</p></li><li><p><code>U+0048 U+0065 U+006C U+006C U+006F</code> Hello 문자를 UTF-8은 <code>48 65 6C 6C 6F</code>로 저장함.</p></li><li><p>이 방식은 ASCII, ANSI, 지구상에서 통용되는 모든 OEM 문자 집합으로 저장하는 방식과 동일.</p></li></ul><blockquote><p>허허… 이해가 잘 안됨… 왜케 이해가 안되는게 많지…<br>문서좀 뒤벼 봐야될것 같다.</p></blockquote><h2><code>일반 텍스트 개념은 존재하지 않는다.</code></h2><ul><li>문자열은 인코딩 방식을 기록해야 한다.</li><li>Content-Type: text/plain; charset=“UTF-8”</li></ul><blockquote><p>크하… 다시 읽어도 제대로 이해되지 않는 부분이 많으니 정진 하도록…</p></blockquote><h1>Reference</h1><blockquote><ul><li><a href="http://korean.joelonsoftware.com/" target="_blank" rel="noopener">조엘 온 소프트웨어</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3장 더 나은 코드를 위한 12단계&lt;/h1&gt;
&lt;h2&gt;조엘 테스트&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;소스 코드 관리 시스템을 사용하는지?&lt;/li&gt;
&lt;li&gt;한방 빌드를 만들어낼 수 있나?&lt;/li&gt;
&lt;li&gt;일일 빌드를 수행 중인가?&lt;/li&gt;
&lt;li&gt;버그 추적
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="다시읽기" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/%EB%8B%A4%EC%8B%9C%EC%9D%BD%EA%B8%B0/"/>
    
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/tags/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="Book" scheme="http://jungha-cho.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>조엘 온 소프트웨어 다시 읽기</title>
    <link href="http://jungha-cho.github.io/2018/03/30/%EC%A1%B0%EC%97%98-%EC%98%A8-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EB%8B%A4%EC%8B%9C-%EC%9D%BD%EA%B8%B0/"/>
    <id>http://jungha-cho.github.io/2018/03/30/조엘-온-소프트웨어-다시-읽기/</id>
    <published>2018-03-30T11:46:32.000Z</published>
    <updated>2018-03-30T12:40:55.436Z</updated>
    
    <content type="html"><![CDATA[<h1>2005년에 출판된 책이다. 현재 사정과 많이 다를 수도 있다.</h1><h1>2장 Back to the Basic, 기본으로 돌아가기</h1><ul><li><a href="http://egloos.zum.com/entireboy/v/2767590" target="_blank" rel="noopener">페인트 공 알고리즘</a></li></ul><h2>ASCIZ 문자열</h2><ul><li>문자열 끝을 Z = 0 로 표시하는 문자열</li><li>n^2 효율</li></ul><script src="//gist.github.com/ff4c544c4ebaa6059bc825e6b0ad20e0.js?file=ASCIZ.c"></script><ul><li>선형 효율</li></ul><script src="//gist.github.com/ff4c544c4ebaa6059bc825e6b0ad20e0.js?file=IntelliStrcat.c"></script><h2>파스칼 문자열</h2><ul><li>문자열의 시작점에 바이트 길이를 표시</li><li>파스칼 문자열은 255Byte로 길이 제한. 바이트에 들어가는 가장 큰 숫자가 255.</li></ul><h2>기억 공간 할당 문제</h2><ul><li>정확하지 않은 공간 할당은 오버 플로우 유발.</li><li>한때 오버 플로우는 해킹의 기본 기술…</li></ul><h3>Malloc</h3><ul><li>사용 가능한 메모리 블록을 <code>liked list</code>로 길게 연결한 <code>자유 체인 free chain</code>. [자유 체인…?]</li></ul><h3>Malloc 동작</h3><ul><li>malloc은 리스트를 따라가며, 요청한 메모리 양보다 큰 블록을 찾는다.</li><li>찾은 블록을 2개로 쪼개 하나는 호출자에게 반환, 하나는 다시 <code>liked list</code>에 넣어 놓는다.</li><li>free를 호출할 때, free는 해제한 메모리를 자유 체인에 추가한다.</li><li>결국 자유 체인은 자그마한 조각으로 잘게 쪼개지고, 단편화를 유발한다.</li><li>이럴경우 원하는 메모리 크기가 없을때가 있는데, 이땐 malloc이 타임아웃?을 선언하고 자유 체인의 작은 조각을 모두 정렬하고 인접한 자유 체인의 블록을 큰 블록으로 결합한다.</li></ul><h2>2배수 메모리 블록 할당</h2><ul><li>잠재적 혼란을 최소화 하기 위해 4, 8, 16 바이트로 할당한다.</li><li>자유 체인에서 생기는 단편화를 상당히 줄여준다.</li><li>50% 이하로 기억공간을 소비한다?</li></ul><h2>RDB가 <code>SELECT author FROM books</code>를 구현하는 방법</h2><ul><li>RDB의 books 테이블 내부의 모든 열 바이트 크기는 같다.</li><li>모든 필드는 항상 열의 시작에서 고정 <code>offset</code>으로 찾을 수 있다.</li><li>예를 들면, books 테이블에서 각 레코드가 100 바이트 크기를 가지고 있고, author 필드의 오프셋이 23이면, author 필드를 23, 123, 223, 323 바이트 위치에 저장한다.</li><li>여기서, 다음 레코드로 옮기는 코드는? <code>pointer += 100;</code></li></ul><h1>2장 끝으로</h1><ul><li>전산 신입생은 CPU부터 시작해 C를 활용하는데 까지 차곡 차곡 기초를 닦아라.</li><li>하양 평준화된 러시아 페인트공 알고리즘 생산자가 되지 말자…?허허…</li><li>문자열이 무엇인지 깊은 단계에서 이해하지 못하는 사람이 된다.</li></ul><blockquote><p>예전부터 해오던 생각이지만, 아주 어렷을적 window 97에 rpg maker라는 게임 만들기 프로그램으로 게임을 만든적이 있는데, 그때 블루 스크린을 너무나도 많이 봐왔다. 그때 문득 블루 스크린이 왜뜨는지, 궁금했었지만 알길이 없었다.<br>그때와 지금은 아주 많이 달라졌다. 하드웨어는 차고 넘칠만큼 빠르고 Java처럼 사용자가 편하게 사용하는 언어를 바탕으로 나 또한 코드만 찍어내는 코더가 되었다.<br>어느 선 까지는 이렇게 성장해도 올라 갈 수 있겠지만, 깊은 곳을 충분히 이해하지 못하면 그 허들을 넘지 못할거라는 걸 어렴풋이 알고 있었다.<br>학부시절 나를 끔찍히 괴롭힌 C와 C++이지만, 다시끔 C를 공부해야될 이유가 생겼다.</p></blockquote><h1>Reference</h1><blockquote><ul><li><a href="http://korean.joelonsoftware.com/" target="_blank" rel="noopener">조엘 온 소프트웨어</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;2005년에 출판된 책이다. 현재 사정과 많이 다를 수도 있다.&lt;/h1&gt;
&lt;h1&gt;2장 Back to the Basic, 기본으로 돌아가기&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://egloos.zum.com/entireboy/v/27
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="다시읽기" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/%EB%8B%A4%EC%8B%9C%EC%9D%BD%EA%B8%B0/"/>
    
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/tags/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="Book" scheme="http://jungha-cho.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>객체 지향 연습 하기 프로젝트</title>
    <link href="http://jungha-cho.github.io/2018/03/30/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%97%B0%EC%8A%B5-%ED%95%98%EA%B8%B0-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"/>
    <id>http://jungha-cho.github.io/2018/03/30/객체-지향-연습-하기-프로젝트/</id>
    <published>2018-03-30T10:56:51.000Z</published>
    <updated>2018-04-01T14:19:12.564Z</updated>
    
    <content type="html"><![CDATA[<h1>효과적으로 TDD, 리팩토링, OOP 연습해보기 (?)</h1><ul><li><a href="https://jungha-cho.github.io/2018/03/30/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(10)/">블랙잭 게임</a>과 <a href="https://jungha-cho.github.io/2018/03/29/UML-%EA%B8%B0%ED%98%B8-%EC%A0%95%EB%A6%AC/">UML</a> 공부, <a href="https://jungha-cho.github.io/2018/03/27/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-Command-(2)/">디자인 패턴</a>등 고급이라면 고급일수 있는 테크닉, 기술 등을 공부해 보면서, 기초가 튼튼하지 못하다는 느낌을 받음.</li><li>업무든 공부든 프로젝트든 <code>문제</code>가 생기면, <code>문제</code>를 해결하려, 결론으로 달려가기만 해서 원론적인 생각이나 고민, 깊이 없이 결과만 내놓고 이만하면 됐다는 마음을 먹음.</li><li>학부시절 C, C++를 다뤘지만, 이마저도 기억이 희미함.</li><li>C는 절차지향, C++는 객체지향이며 업무에 사용하는 Java 조차도 절차지향적으로 코딩하고 있음…</li></ul><blockquote><p>따라서, 객체 지향의 기본, 기초를 튼튼히 닦고싶어 관련 자료부터 조사해 봄</p></blockquote><h1></h1><p><a href="https://medium.com/@codesquad_yoda/%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-tdd-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-oop%EB%A5%BC-%EC%97%B0%EC%8A%B5%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80-7ecc9ddb5d45" target="_blank" rel="noopener">CodeSquad</a>, <a href="http://korean.joelonsoftware.com/" target="_blank" rel="noopener">조엘온소프트웨어</a> 참고</p><ul><li>순수 프로그래밍 언어만으로 프로그램을 구현하는 연습 ( DB, 프레임웤 등 기타 부산물이 결합되면 테스트가 어려움 )</li></ul><h1>연습하기 좋은 프로그램</h1><ul><li>게임과 같이 요구사항이 명확한 프로그램.</li><li>의존관계가 없는 프로그램으로 연습.</li><li>약간은 복잡한 로직이 있는 프로그램 -&gt; 게임</li></ul><p>예제</p><ul><li>로또 ( 콘솔 UI )</li><li>사다리 타기 ( 콘솔 UI )</li><li>볼링 게임 점수판 ( 콘솔 UI )</li><li>체스 게임 ( UI 콘솔 )</li><li>지뢰 찾기 게임 ( UI 콘솔 )</li></ul><blockquote><p>게임의 경우 규칙이 명확하기 때문</p></blockquote><h1><code>소트웍스 앤솔러지</code> - 객체 지향 생활 체조 9가지 원칙</h1><h2>규칙 1 메소드당 들여쓰기 한 번</h2><ul><li>한 메서드 길이는 5줄로 제한하기</li><li>한 메서드당 하나의 제어 구조</li><li>한 메서드당 하나의 문장 단락</li></ul><blockquote><p>정확히 한가지 일을 하는 메서드로 작업을 하면, 코드가 달라지기 시작한다.<br>애플리케이션의 단위가 작아짐에 따라 재사용의 수준은 기하급수적으로 상승하기 때문이다.</p></blockquote><h2>규칙 2 else 예약어 금지</h2><ul><li>읽기 힘든 지저분한 코드가 나오기 쉽다.</li><li>조건문은 곧잘 코드 중복의 원흉이 되기도 한다.</li><li><code>STRATEGY 패턴</code>은 다형성을 이용해 분기를 막는다. 상태 분기가 몇군데 걸쳐 중복되 있다면 <code>STRATEGY 패턴</code> 적용을 고민하라.</li><li>간단한 경우라면 <code>보호절(guard clause)</code>와 <code>조기 반환(early return)</code>으로 대체 가능하다. [무슨 말이징~?]</li><li><code>널 객체 패턴 (null object pattern)</code>을 시도해보면 특정 상황에서 도움이 된다.</li></ul><blockquote><p>의미 없는 분기를 금하고, 분기가 있다면 여러 패턴을 이용해 else 조건문을 줄이라는 말인것 같다.</p></blockquote><h2>규칙 3 원시값과 문자열의 포장</h2><ul><li>어떤 메소드가 int 값을 매개 변수로 받는다면, 그 메서드 이름은 해당 매개 변수의 의도를 나타내기 위해 모든 수단과 방법을 가리지 말자.</li><li>원시형 변수로는 컴파일러가 의미적으로 맞는 프로그램 작성을 안내할 수 없다. 객체로라면 아주 사소하더라도 컴파일러와 프로그래머에게 그 값이 어떤 값이며, 왜 쓰고 있는지에 대한 정보를 전하는 셈이다.</li></ul><blockquote><p>원시값이나 문자열은 포장해서 그 사용법과 의미를 정확하게 전달하자.</p></blockquote><h2>규칙 4 한 줄에 한 점만 사용</h2><ul><li>코드 한 줄에서라도 점이 하나 이상 있으면, 그 곳에서 다른 동작이 일어나고 있다는 뜻이다.</li><li>어쩌면 두 객체를 동시에 다루고 있을 수도 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">boardRepresentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">   <span class="keyword">for</span> (Location l : squares())</span><br><span class="line">      buf.append(l.current.representation.substring(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">// 이곳..</span></span><br><span class="line">   <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>처음에 이해가 잘 안되어 어떤 부분인지 유심히 봤는데, 해당 부분이다. 리팩토링 포인트임을 숙지하자.</p></blockquote><h2>규칙 5 축약 금지</h2><ul><li>메서드의 이름이 길어진다면, 책임 소재의 오류나 클래스의 부재라는 신호탄이다.</li><li>클래스와 메서드 이름은 한두 단어로 유지하려고 노력하고 문맥이 중복되는 이름을 자제하자.</li><li>클래스 이름이 Order라면, 메소드를 shipOrder라고 이름 지을 필요가 없다. 짧게 ship으로 표현하면, 클라이언트에서는 order.ship()으로 호출된다.</li><li>이 훈련을 위해 모든 엔티티는 한두 단어로 된 이름을 축약 없이 가져야 한다.</li></ul><blockquote><p>의미 없는 이름 짓기를 피하자.</p></blockquote><h2>규칙 6 모든 엔티티를 작게 유지</h2><ul><li><p>50줄 이상 되는 클래스와 파일이 10개 이상인 패키지는 없어야 한다는 뜻이다.</p></li><li><p>50줄 이상의 클래스는 보통 한 가지 일 이상을 하는 것이며, 따라서 코드의 이해와 재사용을 점점 더 어렵게 끌고 간다.</p></li><li><p>50줄 짜리 클래스는 스크롤 하지 않고도 한 화면에 볼 수 있다는 부가적인 혜택도 있으며, 한 눈에 파악하기도 쉽다.</p></li><li><p><code>클래스를 작성할때 난감한 경우는 같이 있어야 말이되는 동작의 묶음이 있을 때다.</code> 이는 패키지를 최대한 활용해야 하는 곳이기도 하다.</p></li><li><p>클래스가 점점 작아지고 하는일이 줄어들며 패키지 크기를 제한함에 따라 패키지가 하나의 목적을 달성하기 위해 모인 연관 클래스들의 집합을 나타낸다는 사실을 알아차리게 된다.</p></li><li><p>패키지도 클래스 처럼 응집력 있고 단일한 목표가 있어야 한다.</p></li><li><p>패키지를 작게 유지하면 패키지 자체가 진정한 정체성을 지니게 된다.</p></li></ul><h2>규칙 7 2개 이상의 인스턴스 변수를 가진 클래스 사용 금지</h2><ul><li>대부분의 클래스가 간단하게 하나의 상태 변수를 처리하는 일을 맡아 마땅하지만 몇몇 경우 둘이 필요할 때가 있다.</li><li>새로운 인스턴스 변수를 하나 더 기존 클래스에 추가하면 클래스의 응집도는 즉시 떨어진다.</li></ul><blockquote><p>심화 내용인것 같다. 여러 관련 인스턴스 변수는 사실 <code>일급 콜렉션</code>안에서 연관되어 있다는 내용인데 이를 이용해 클래스를 쪼갤수 있다는 것이다.<br>사실 이해가 잘 안된다. 여러번 봐야 겠다 <a href="https://developerfarm.wordpress.com/2012/01/31/object_calisthenics_8/" target="_blank" rel="noopener">규칙 7</a></p></blockquote><h2>규칙 8 일급 콜렉션 사용</h2><ul><li>콜렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.</li><li>콜렉션은 그 자체로 포장돼 있으므로 콜렉션과 관련된 동작은 근거지가 마련된 셈이다.</li></ul><blockquote><p>필터에 대한 내용과 클래스를 그룹으로 묶고 원소 규칙을 적용하는 등 여러가지 일을 할 수 있단다…<br>점점 이해가 안되기 시작한다. 이것 또한 다시 보기 <a href="https://developerfarm.wordpress.com/2012/02/01/object_calisthenics_/" target="_blank" rel="noopener">규칙 8</a></p></blockquote><h2>규칙 9 게터/세터/속성 사용 금지</h2><ul><li>말이 필요 없다… <a href="https://developerfarm.wordpress.com/2012/02/01/object_calisthenics_10/" target="_blank" rel="noopener">규칙 9</a></li><li>7,8,9는 넘나 한방에 이해 안되는 것들…</li></ul><h1>끝으로</h1><blockquote><p>프로젝트 구현시 이를 지켜 TDD, 리팩토링과 함께 묶어 연습을 시작해야 할 때인것 같다!</p></blockquote><p>By CodeSquade</p><ul><li>1단계 메소드 분리 연습 - 규칙 1, 2</li><li>2단계 객체 분리 연습 - 규칙 3, 6, 7, 8</li><li>3단계 객체 지향, 클린 코드 - 규칙 4, 5, 9</li></ul><h1>Reference</h1><blockquote><ul><li><a href="https://medium.com/@codesquad_yoda/%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-tdd-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-oop%EB%A5%BC-%EC%97%B0%EC%8A%B5%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80-7ecc9ddb5d45" target="_blank" rel="noopener">CodeSquad</a></li><li><a href="https://developerfarm.wordpress.com/2012/02/03/object_calisthenics_summary/" target="_blank" rel="noopener">developerFarm 개발자 농장</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;효과적으로 TDD, 리팩토링, OOP 연습해보기 (?)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jungha-cho.github.io/2018/03/30/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="OOP" scheme="http://jungha-cho.github.io/tags/OOP/"/>
    
      <category term="객체 지향" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>객체지향설계-블랙잭(10)</title>
    <link href="http://jungha-cho.github.io/2018/03/30/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(10)/"/>
    <id>http://jungha-cho.github.io/2018/03/30/객체지향설계-블랙잭(10)/</id>
    <published>2018-03-30T04:09:10.000Z</published>
    <updated>2018-03-30T10:57:33.283Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 지향 설계 연습하기 - 블랙잭 (10)</h1><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github source code</a></p><h1>들어가며</h1><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h1>UML 6번째 버전입니다.</h1><p><img src="/images/blackjack_v6.JPG" alt="blackjack_v6.JPG"></p><ul><li>6번째 UML이 완성 됐습니다.</li></ul><blockquote><ul><li>Card는 Deck으로 합성 연관, Deck,은 Dealer까지 합성 관계로 묶여 있습니다.</li><li>User 추상 클래스는, Hand 인터페이스를 구현합니다.</li><li>Rule 인터페이스는 다형성을 사용하기 위해 STATEGY 패턴으로 User 추상 클래스에 변수화해서 사용합니다.</li><li>Dealer와 Player는 User 추상 클래스를 상속하며, User로 인스턴스화 되게끔 구성해 다형성을 이용할수 있습니다.</li><li>따라서 모든 접근은 User 추상 클래스를 이용해 접근 되며 Board는 User와 Aggregation 관계에 있습니다. 결국 모든 유저는 main 클래스에서 생성되서 게임이 시작되니깐요.</li></ul><blockquote><ul><li>UML Class Diagram을 작성해본지 얼마 되지 않아 위 UML이 제가 작성한 코드와 다를 수도 있습니다.</li></ul></blockquote></blockquote><h1>소스코드</h1><h2>Suit, Denom, Card, Deck, Hand</h2><ul><li>큰 변화가 없는 Card 관련 클래스들 입니다.</li><li>Hand만 Interface로 바뀌었고, 의존성 종속성이 없어졌습니다.</li></ul><script src="//gist.github.com/9e1ea6c0a259eeb20c59d02c8b09d0b0.js"></script><h2>Rule, DealerRule, PlayerRule</h2><ul><li>다형성을 이용하기 위해 룰을 인터페이스화 시켜서 각각 딜러 룰과 플레이어 룰을 만들었지만, 의도치 않게 중복 코드가 발생했습니다.</li><li>Board에서 Rule을 적용하려다 보니 불가피하게 중복 코드가 발생했는데요.</li><li>이 <code>문제</code>는 해결을 뒤로 미뤄야 할것 같습니다…</li></ul><script src="//gist.github.com/cf08989d7ba5bf55c700d029e24ef261.js"></script><h2>User, Dealer, Player</h2><ul><li>격변의 시기를 거친 유저 추상 클래스와 딜러, 플레이어 입니다.</li><li>유저와 딜러는 모든 메소드와 변수를 <code>구현 (interface)</code>과 <code>추상 클래스 상속 (abstract)</code>으로 구현 됩니다.</li><li>유일한 차이점은 <code>딜러는 덱 (deck)을 가지고 있다.</code> 뿐이죠.</li></ul><script src="//gist.github.com/95eb5bd6b68112857a67669e8a19b0fd.js"></script><h2>Board, Main 클래스</h2><ul><li>처음 생성되어 실제 게임 로직이 구현될 Board와 Main 클래스 입니다.</li><li>Board 클래스를 작성하면서 설계된 <code>Class, Interface, Abstract Class</code>를 사용했는데요.</li><li>역시, 부실한 설계와 잦은 변경때문에 한계점이 분명히 드러났습니다.</li><li>목표했던, User 추상 클래스를 통해 게임의 모든 통제권을 <code>상속</code>받아 사용하려 했는데, Board 클래스에서 불가피하게 일부 구현된 기능이 몇가지 있습니다.</li><li>다형성을 이용했던 User 변수는 딜러와 플레이어의 구분이 되질 않아 순회를 통해서 찾아야 했구요.</li><li>블랙잭 룰의 요구 분석 및 상세 설계가 진행 되지 않아, hit 조건과 stay 조건을 board에서 검사하는 불상사가 일어났습니다.</li></ul><script src="//gist.github.com/5fc711e55335a855531a77249a0df189.js"></script><h2>실행</h2><ul><li>아직 bust시 게임 종료와 상세 규칙, 딜러 규칙, 플레이어 규칙 등 조건이 분기 되진 않았지만, 게임의 뼈대는 제대로 동작하고 있는걸 확인 할 수 있습니다.</li></ul><p><img src="/images/blackjack_play1.JPG" alt="blackjack_play1.JPG"><br><img src="/images/blackjack_play2.JPG" alt="blackjack_play2.JPG"></p><blockquote><ul><li>모든 소스 코드는 <a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github.com/jungha-cho/blackjack</a>에서 확인 할 수 있습니다.</li></ul></blockquote><h1>끝으로</h1><ul><li>한동안 BlackJack 게임은 더이상 리팩토링하지 않으려고 합니다.</li><li>전편에도 말씀드렸듯 분명한 요구 분석과 명세서가 작성되지 않은 상태에서 게임을 구현하다보니, 우당탕탕 수정에 수정만 거듭되고, 부랑자 같은 코드가 탄생하는걸 직접 겪으니, 한가지 책이 떠올라서 책을 읽고 제가 개발하려하는 프로그램에 방향성을 잡는법을 익히고 다시 접근해야 될 것 같습니다.</li><li>책은 <a href="http://korean.joelonsoftware.com/" target="_blank" rel="noopener">조엘 온 소프트웨어</a> 입니다. 회사와 팀, 개발 프로세스 등 방대한 양을 다루고 있지만, 내부에 명세서와 관련된 내용이 꽤 있었던 걸로 기억이 나서 다시 읽어보려구요.</li></ul><h1>Reference</h1><blockquote><ul><li>[]</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 지향 설계 연습하기 - 블랙잭 (10)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/BlackJack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github source code&lt;/a&gt;
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="디자인 패턴" scheme="http://jungha-cho.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="헤드 퍼스트 디자인 패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C-%ED%8D%BC%EC%8A%A4%ED%8A%B8-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>객체지향설계-블랙잭(9)</title>
    <link href="http://jungha-cho.github.io/2018/03/29/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(9)/"/>
    <id>http://jungha-cho.github.io/2018/03/29/객체지향설계-블랙잭(9)/</id>
    <published>2018-03-29T14:04:00.000Z</published>
    <updated>2018-03-29T14:27:32.173Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 지향 설계 연습하기 - 블랙잭 (9)</h1><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github source code</a></p><h1>들어가며</h1><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h1>UML 5번째 버전입니다.</h1><p><img src="/images/blackjack_v5.JPG" alt="blackjack_v5.JPG"></p><ul><li>각각의 룰이 따로 적용될 수 있게 룰을 두개로 뜯고, 다형성을 이용한 STRATEGY 패턴을 적용해 보기로 했습니다.</li><li>물론, 스트래이트지 패턴이 확장 가능한 부분을 캡슐화하고 확장성을 증가 시켜주지만 여기서는 연습겸 적용시켜봤습니다.</li></ul><h1>소스코드</h1><h2>카드 이넘 관련</h2><ul><li>Card, Suit, Denomination은 큰 변화가 없습니다.</li></ul><h2>Rule과 User의 다형성</h2><ul><li>STRATEGY 패턴을 적용해 봤습니다.</li></ul><script src="//gist.github.com/789afa23997044db818293fca45c1759.js?file=Rule.java"></script><script src="//gist.github.com/789afa23997044db818293fca45c1759.js?file=DealerRule.java"></script><script src="//gist.github.com/789afa23997044db818293fca45c1759.js?file=PlayerRule.java"></script><ul><li>Rule 인터페이스를 구현하는 DealerRule.java, PlayerRule.java를 만들어 룰 알고리즘 군을 생성했습니다.</li></ul><script src="//gist.github.com/789afa23997044db818293fca45c1759.js?file=User.java"></script><ul><li>User 추상 클래스는 이 Rule 인터페이스를 멤버 변수로 가지고 있으면서, Player와 Dealer가 각각 자기의 알고리즘군인 DealerRule, PlayerRule을 생성해 구현하죠.</li></ul><script src="//gist.github.com/789afa23997044db818293fca45c1759.js?file=Player.java"></script><script src="//gist.github.com/789afa23997044db818293fca45c1759.js?file=Dealer.java"></script><ul><li>이렇게 짜여잔 구조는 Main 클래스에서 이렇게 사용합니다.</li></ul><script src="//gist.github.com/789afa23997044db818293fca45c1759.js?file=BlackJackGameMain.java"></script><ul><li>각각 Dealer와 Player는 User 변수로 합쳐져 GameBoard로 전달 됩니다.</li><li>GameBoard를 볼까요?</li></ul><script src="//gist.github.com/789afa23997044db818293fca45c1759.js?file=GameBoard.java"></script><ul><li>GameBoard에서는 딜러와 유저의 구분 없이 모든 유저를 수용하고, GameStart에서 이를 사용합니다.</li><li><code>이렇게 구성하게 되면, DealerRule, PlayerRule 외에 어떠한 룰이 추가되더라도 기존 로직에는 변경없이 사용 가능한 STRATEGY 패턴입니다.</code></li></ul><blockquote><p>여기서 <code>문제</code>가 발생했습니다.<br>다형성을 이용해 구분 없이 각자가 적용될 Rule을 들고 있는것 까진 좋은데, User에서 Dealer를 구분할 수가 없습니다.<br>BlackJack에서 카드덱은 Dealer만 가지고 있으니까요. 유저는 딜러에게 카드를 요청해야 하니까요…<br>이 <code>문제</code>는 다음에 해결 하기로 했습니다…</p></blockquote><ul><li>나머지 Hand.java와 Deck.java 입니다.</li></ul><script src="//gist.github.com/789afa23997044db818293fca45c1759.js?file=Deck.java"></script><script src="//gist.github.com/789afa23997044db818293fca45c1759.js?file=Hand.java"></script><ul><li><p>실행 화면을 볼까요?<br><img src="/images/blackjack_v5_run.JPG" alt="blackjack_v5_run.JPG"></p></li><li><p>처음 세줄은 각각의 유저에게 적용되는 룰이 보여집니다.</p></li><li><p>딜러를 찾았네요… 여기가 향후 해결해야될 <code>문제</code>입니다…</p></li><li><p>딜러에게 카드를 요청한 후 각자 핸드에 있는 두장의 카드를 표시해 줍니다.</p></li></ul><h1>끝으로</h1><blockquote><p>진도를 많이 빼면서 여기 저기 손보고 수정된 곳이 많은데, 지금 같이 진행하고 있는 <code>헤드퍼스트디자인패턴</code>에 나오는 디자인 원칙이 하나도 지켜지지 않았습니다.<br>특히, abstract 클래스를 남발했고, 해당 추상 클래스 내에서도 이유없이 구현 메소드를 사용하고 있습니다.<br>의미 없는 캡슐화는 성공한 것 같아 보이지만, 상속보다는 구성을 활용한다. 또는 구현이 아닌 인터페이스에 맞춰 프로그래밍 한다. 라는 원칙이 지켜지질 않습니다.</p><blockquote><p>괜찮습니다. 코드는 계속 발전할꺼니깐요. 또 업그레이드 버전으로 찾아오겠습니다.</p></blockquote></blockquote><blockquote><ul><li>이렇게 자꾸 헤메는게, 저 스스로 구현의 명세를 정하지 않고, 막 코딩, 막 생각으로 구현하다보니 와당창창 하는것 같습니다. <code>조엘 온 소프트웨어</code> 책이 있는데, 다시 읽어 보고 오겠습니다.</li></ul></blockquote><h1>Reference</h1><blockquote><ul><li>[]</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 지향 설계 연습하기 - 블랙잭 (9)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/BlackJack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github source code&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="디자인 패턴" scheme="http://jungha-cho.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="헤드 퍼스트 디자인 패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C-%ED%8D%BC%EC%8A%A4%ED%8A%B8-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>문득 궁금해 졌습니다. 객체 지향이란 무엇이며, 이를 채용하는 언어는 어떠한 특성이 있을까?</title>
    <link href="http://jungha-cho.github.io/2018/03/29/%EB%AC%B8%EB%93%9D-%EA%B6%81%EA%B8%88%ED%95%B4-%EC%A1%8C%EC%8A%B5%EB%8B%88%EB%8B%A4-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%9D%B4%EB%A5%BC-%EC%B1%84%EC%9A%A9%ED%95%98%EB%8A%94-%EC%96%B8%EC%96%B4%EB%8A%94-%EC%96%B4%EB%96%A0%ED%95%9C-%ED%8A%B9%EC%84%B1%EC%9D%B4-%EC%9E%88%EC%9D%84%EA%B9%8C/"/>
    <id>http://jungha-cho.github.io/2018/03/29/문득-궁금해-졌습니다-객체-지향이란-무엇이며-이를-채용하는-언어는-어떠한-특성이-있을까/</id>
    <published>2018-03-29T05:59:35.000Z</published>
    <updated>2018-03-29T07:06:58.854Z</updated>
    
    <content type="html"><![CDATA[<h1>들어가며</h1><p>객체 지향이란 무엇이며 객체 지향 언어가 가지고 있는 특성이 무엇인지, 또 interface, abstract, 상속, implements 등 여러 특성에 대해 진지하게 또 깊게 알고싶어 졌음.</p><h1>먼저, 누군가가 정의한 객체 지향의 정의</h1><blockquote><p><code>객체 지향 프로그래밍 이란 캡슐화, 다형성, 상속을 이용하여 코드 재사용을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해 객체들을 연결시켜 프로그래밍 하는 것</code></p></blockquote><blockquote><p>인용</p><blockquote><p>이는 개인적인 의견이 아니라 객체지향 용어를 발명한 사람의 의견 입니다. Bjarne Stroustrup 은 그의 문서 Why C++ is not just an Object Oriented Programming Language: 섹션 3 에서 지금의 널리 사용되는 “객체지향” 이라는 용어를 제시하였습니다.</p></blockquote></blockquote><blockquote><p>언어 또는 기술은 다음을 직접 지원 한다면 객체 지향 이다.</p><blockquote><ol><li>추상화 - 클래스나 객체를 제공한다.</li><li>상속 - 이미 존재하는 것으로 부터 새로운 추상화를 만들어 낼 능력을 제공한다.</li><li>런타임 다형성 - 수행 시간에 바인딩 할 수 있는 어떠한 폼을 제공한다.</li></ol></blockquote></blockquote><h1>OOP와 non-OOP</h1><h2>non-OOP</h2><script src="//gist.github.com/5c2fcb64f6c4d9712a81d7f142af0d87.js?file=non-OOP.c"></script><ul><li>함수는 필요한 것을 가진 코드 블록으로 정의됨</li><li>각 함수 이름은 애플리케이션에서 유일한 이름</li></ul><h3>접근 방법</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = function(arg1, arg2); <span class="comment">// 직접 접근</span></span><br></pre></td></tr></table></figure><h3>함수는 기본적으로 상태를 가지지 않음</h3><ul><li>호출 될때 마다 새로운 실행으로 취급</li><li>지역 변수는 초기화</li></ul><h2>OOP</h2><script src="//gist.github.com/5c2fcb64f6c4d9712a81d7f142af0d87.js?file=OOP.java"></script><ul><li>클래스 메소드는 클래스 정의에서 경계점으로 규정됨.</li><li>클래스 이름이 애플리케이션에서 유일해야 함</li><li>각각의 클래스 내에서는 유일한 이름을 가지는 다수의 함수를 가질 수 있음</li><li><code>공통 함수/메소드 이름을 허용하는 것은 다형성에서 필요로 하는 공유 능력을 위해 존재</code></li></ul><h3>접근 방법</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable = <span class="keyword">new</span> SomeClass();</span><br><span class="line">variable = variable.function(arg1, arg2); <span class="comment">// 객체를 통한 간접 접</span></span><br></pre></td></tr></table></figure><h3>OOP는 다수의 복제본을 가짐</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SomeClass var1 = <span class="keyword">new</span> SomeClass();</span><br><span class="line">SomeClass var2 = <span class="keyword">new</span> SomeClass();</span><br><span class="line">SomeClass var3 = <span class="keyword">new</span> SomeClass();</span><br></pre></td></tr></table></figure><h3>OOP는 상태를 가짐</h3><ul><li>Class 내부 변수로 상태를 가지며, 이는 모두 클래스 내부에서 저장되거나 컨트롤 됨</li></ul><h1>번역 글의 결론</h1><p>많은 사람들이 OOP의 의미를  서로 다른 단어로 묘사합니다. 문제는 그 단어들이 오역되기 쉽다는 것이죠. 루이스 캐롤의 험프티-덤프티가 자칭한 유리창 너머로 볼때 처럼.</p><blockquote><p><code>내가 이 단어를 사용할 때는 내가 선택한 뜻을 의미해, 더도 덜도 아니야</code></p></blockquote><p>OOP의 창작자가 사용한 단어를 사용할 때, 그 단어에 다른 뜻을 적용한다면, 다른 사람은 여러분의 단어를 또 다른 뜻으로 적용합니다. 그것은 원래와 전혀 관계 없는 것으로 끝이 납니다.</p><p>객체지향과 비객체지향을 구별하는 데에느 단지 세가지 기능이 있습니다. 이것들은 캡슐화, 상속, 다형성 입니다. 이거 이외에는 헛소리 입니다. 객체지향 프로그래밍은 프로그래밍 언어에서 이 기능들을 이용하는 것입니다. 높은 재사용성과 낮은 유지보수 비용은 보장될 수 없습니다. 전적으로 이 기능들을 어떻게 구현하느냐에 달려 있습니다.</p><p>몇몇 사람들은 내가 OOP에 대해 너무 단순한 관점을 가졌다고 비난합니다. “필요이상으로 단순화 시켰다거나”, “필요이상으로 복잡화 했다 거나” 라고 하는 대신에 말이죠. KISS 원칙의 오래된 추종자로써 나는 다른 사람들을 가르치기 쉬운 더욱 적절한 관점을 알고 있습니다.</p><p>출처: <a href="http://vandbt.tistory.com/10" target="_blank" rel="noopener">http://vandbt.tistory.com/10</a> [소프트웨어 디자인- Design Software by vandbt]</p><h1>객체 지향의 5가지 특성</h1><h2>Object</h2><p><code>데이터를 가지고 있습니다.</code> - 데이터는 객체의 상태를 기술하는 정보를 저장합니다.<br><code>행위의 집합을 가지고 있습니다.</code> - 이 행위들은 메세지를 받았을 때 객체가 어떻개 해야하는지 알고 있는 것 입니다.<br><code>개체를 구분하는 아이덴티티를 가지고 있습니다.</code> - 어떠한 객체를 다른 객체와 구분하는 것을 가능케 합니다.</p><h2>Class</h2><ul><li><code>클래스는 객체를 생성할때 사용하는 청사진</code> - 실제 객체에 대한 코드를 절대로 직접 작성할 수 없으며, 그저 객체를 만드는데 사용되는 패턴을 작성할 뿐이다.</li></ul><h2>Encapsulation, 통으로 참고</h2><p>여러분의 객체는 속성과 메소드로 만들어져 있습니다. 일부 속성과 메소드는 객체의 외부에서 접근할 수 있고 이것을 인터페이스 interface 라고 합니다. 다른 속성,메소드는 객체 자신만의 사적인 용도로 예약되어 있고 이것을 구현 implement 이라고 합니다. 구현으로 부터 인터페이스를 분리하는 것은 객체-지향 프로그램을 설계할 때 가장 중요한 결정 입니다.</p><p>구현으로 부터 인터페이스를 나누는 일의 가치를 살펴보자면, 자동차를 연상하면 쉬울 것입니다. 자동차의 인터페이스는  핸들, 가속 페달, 브레이크로 간단하고 규격화 되어 있습니다. 운전방법을 한번 배우기만 하면 됩니다. 반면에 자동차의 내부 동작은 점화, 실린더, 연료 분사 등등 매년 역동적으로 변경됩니다. 여러분이 각기 다른 타입의 자동차의 점화 시스템을 직접 통제해야 한다면, 새차를 운전하기란 매우 어렵다는 걸 알게 될겁니다.</p><p>잘-설계된 클래스 Well-Designed Class 는 이런 특성을 가지고 있습니다. 인터페이스는 여러분의 클래스와 어떻게 상호작용 해야 하는지 완벽하게 묘사합니다. 그리고 클래스의 대부분의 속성은 감추어 진다는 것을 의미합니다. 사용자는 데이터를 수정하기 위해서 메소드를 사용할 것입니다.</p><p>출처: <a href="http://vandbt.tistory.com/39" target="_blank" rel="noopener">http://vandbt.tistory.com/39</a> [소프트웨어 디자인- Design Software by vandbt]</p><h2>Inheritance</h2><p><code>&quot;상속의 진가는 강력한 추상 구조화 이다.&quot;</code></p><ul><li>새로운 종류의 서브클래스를 작성하면, 여려분은 부모 super class 에 이미 내장된 기능들을 사용할 수 있습니다.</li><li>상속의 진가는 추상화를 구조화 한다는데 있습니다.</li></ul><h2><code>Polymorphism</code></h2><ul><li><code>다형성은 객체-지향 프로그래밍의 기반 원칙입니다. &quot;많은 형태 many shapes&quot; 라는 뜻을 가진 그리스어에서 유래한 말로, 다형성은 캡슐화, 상속과 함께 작동해서 객체-지향 프로그램의 흐름 제어 flow of control 를 단순화 합니다.</code></li></ul><blockquote><blockquote><p>다형성으로 조건문을 제거하라 Replace Conditional with Polymorphism(293)<br>객체 전문용어 가운데 가장 멋지게 들리는 말 중의 하나가 다형성(polymorphism)이다. 다형성의 진가는 동작이 그 타입에 따라 변하는 객체를 가지고 있을 때, 명시적으로 조건문을 사용하지 않아도 되도록 한다는 데 있다.<br>리팩토링, 마틴 파울러 지음/윤성준,조재박 옮김, 대청, p.293<br>마틴 파울러의 리팩토링의 Replace Conditional with Polymorphism(293)</p></blockquote></blockquote><h1>끝으로</h1><p><code>멘붕</code></p><h1>Reference</h1><blockquote><ul><li><a href="http://vandbt.tistory.com/10" target="_blank" rel="noopener">OOP란 무엇인가 - 번역</a></li><li><a href="http://vandbt.tistory.com/39" target="_blank" rel="noopener">다섯가지 기반 개념</a></li><li><a href="http://vandbt.tistory.com/10" target="_blank" rel="noopener">소프트웨어 디자인- Design Software by vandbt</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;p&gt;객체 지향이란 무엇이며 객체 지향 언어가 가지고 있는 특성이 무엇인지, 또 interface, abstract, 상속, implements 등 여러 특성에 대해 진지하게 또 깊게 알고싶어 졌음.&lt;/p&gt;
&lt;h1&gt;먼저, 누군
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="OOP" scheme="http://jungha-cho.github.io/tags/OOP/"/>
    
      <category term="객체 지향" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5/"/>
    
      <category term="객체 지향 언어" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%96%B8%EC%96%B4/"/>
    
  </entry>
  
  <entry>
    <title>객체지향설계-블랙잭(8)</title>
    <link href="http://jungha-cho.github.io/2018/03/29/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(8)/"/>
    <id>http://jungha-cho.github.io/2018/03/29/객체지향설계-블랙잭(8)/</id>
    <published>2018-03-29T04:53:00.000Z</published>
    <updated>2018-03-29T06:23:23.206Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 지향 설계 연습하기 - 블랙잭 (8)</h1><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github source code</a></p><h1>들어가며</h1><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h1>UML 4번째 버전입니다.</h1><p><img src="/images/blackjack_v4.JPG" alt="blackjack_v4.JPG"></p><ul><li>허허 <a href="https://jungha-cho.github.io/2018/03/29/UML-%EA%B8%B0%ED%98%B8-%EC%A0%95%EB%A6%AC/">UML 기호 정리</a> 후 제가 그린 UML이 완벽하게 잘못되 있다는걸 늦게 깨닳았습니다.</li></ul><h2>Denomination, Suit의 Card 클래스와 관계</h2><p>카드는 모양과 끗수를 반드시 가지고 있어야 합니다. 두 개는 카드에 필수적인 존재입니다. 의미적으로 보면 세개의 관계가 <code>Composition</code> 강집합 관계인것 처럼 보입니다. 다만 enum과 class의 관계에에서 특정 enum의 레퍼런스를 유지하는 관계는 <code>dependency</code>로 표현한다는 stackoverflow의 의견이 있어 조금 헷갈리지만, <code>dependency</code>로 표현 했습니다.</p><h2>Card와 Deck의 관계</h2><p>Deck은 카드의 52장 모음 입니다. 덱의 존재 가치는 카드 52장의 합으로 의미가 부여되고, Deck 내부 생성자에서 Card를 new 키워드로 52장을 생성하기 때문에 <code>Life Cycle</code> 또한 같다고 보여져 <code>Composition</code> 관계로 설정했습니다.</p><h2>Deck과 Dealer의 관계</h2><p>Deck은 딜러의 존재 가치입니다. 딜러가 카드를 나눠주기 위해 카드 52장을 가지고 있고, 해당 카드 모음을 Deck이라고 지칭하며, 한 게임에서 한개의 덱은 딜러만 들고 있을수 있습니다. Dealer의 생성자에서 Deck을 new 키워드로 생성함으로 <code>Composition</code> 관계로 설정 했습니다.</p><h2>Hand</h2><p>이부분에서 상당히 헤맸고, 아직도 헤매고 있습니다. <code>Hand</code>는 각 유저가 들고 있는 카드로 표현되는 추상적인 개념인데, <code>Hand</code>는 <code>Card</code>의 모음으로 유지 됩니다. 다만, Card 자체의 레퍼런스는 <code>Hand</code>에서 유지되는게 아닌 <code>Deck</code>에서 유지되는데, <code>Hand</code>는 <code>Deck</code>의 존재를 모르므로, <code>Card</code>와 <code>라이프 사이클</code>이 같지 않은 <code>aggregation</code> 관계로 설정 했습니다.</p><h2>User, Rule</h2><p>User 또한 추상적인 개념으로 생각했습니다. 비슷한 개념으로 Human, 오스트랄로피테쿠스(?) 처럼 사람의 특성 시대적 표현 또는 인간 이라는 인류 전체적 단어로 설정된것 처럼, <code>User</code> 또한 게임이라는 틀안에서 모든 사람을 지칭하는 단어로 생각했고, 추상 클래스로 잡았습니다. 또, <code>User</code>는 게임 내에서 <code>Hand</code>를 가지고 있어, <code>상속</code>받아 사용했으며 <code>Rule</code>이라는 규칙에 얽메이므로 <code>Interface</code>를 구현했습니다.</p><h2>Dealer, Player</h2><p>딜러와 플레이어는 의외로 간단했습니다. 딜러와 플레이어는 기본적으로 <code>룰</code>을 적용받고, <code>Hand</code>를 가지고 있지만 유일한 차이점은 <code>딜러는 Deck을 가지고 있다.</code> 입니다.</p><h1>Source Code는 바뀐게 없습니다.</h1><script src="//gist.github.com/5362c6a83e87ade07cc19cc8070b7127.js"></script>    <h1>끝으로</h1><blockquote><p><a href="https://jungha-cho.github.io/2018/03/29/UML-%EA%B8%B0%ED%98%B8-%EC%A0%95%EB%A6%AC/">UML 기호 정리</a>를 통해 UML 표현법과 각 의미에 대해 배웠으며, 해당 개념을 적용했습니다.<br>아직도 헷갈리는 부분과 저 스스로 납득이 되지 않는 부분이 여러모로 많습니다.<br>더욱더 치열하게 분석을 진행해 보겠습니다.<br>다음편은 드디어 블랙잭 게임을 구현해 볼수 있길 고대하겠습니다.</p></blockquote><h1>Reference</h1><blockquote><ul><li><a href="http://geniusduck.tistory.com/entry/UML-%EA%B8%B0%EB%B3%B8%ED%8E%B8-%EA%B8%B0%EB%B3%B8-%ED%91%9C%EA%B8%B0-%ED%98%95%EC%8B%9D-%EB%B0%8F-%EA%B4%80%EA%B3%84%ED%91%9C%ED%98%84%EB%B2%95" target="_blank" rel="noopener">UML</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 지향 설계 연습하기 - 블랙잭 (8)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/BlackJack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github source code&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="디자인 패턴" scheme="http://jungha-cho.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="헤드 퍼스트 디자인 패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C-%ED%8D%BC%EC%8A%A4%ED%8A%B8-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>UML 기호 정리</title>
    <link href="http://jungha-cho.github.io/2018/03/29/UML-%EA%B8%B0%ED%98%B8-%EC%A0%95%EB%A6%AC/"/>
    <id>http://jungha-cho.github.io/2018/03/29/UML-기호-정리/</id>
    <published>2018-03-29T02:56:55.000Z</published>
    <updated>2018-03-29T05:13:34.375Z</updated>
    
    <content type="html"><![CDATA[<h1>기호 정리 이유</h1><p><a href="https://jungha-cho.github.io/2018/03/29/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(7)/">블랙잭</a> 게임을 객체 지향적으로 설계해 보던 중 UML을 그려보게 됐는데, 학부때 맛만 본 기억과 인터넷 자료들을 편집해 그리다 보니… 거꾸로 쓰고… 잘못쓰고… 완전 개판이 났다.<br>따라서 이번 편을 통해 UML의 <code>클래스 다이어그램</code>의 기호를 한번 정리해 보고자 한다.</p><h1>Relationship ( 관계 표현 )</h1><p>여러 레퍼런스 사이트에서 아래 사진을 많이 채용하고 있어, 해당 사진으로 이해해보려 한다.<br>interface, abstract, class의 구분은 충분히 가능하므로 해당 포스트에서는 관계 표현법만 정리해 보겠다.</p><p><img src="/images/relationship.jpg" alt="relationship.jpg"></p><h2>서로 의미 있는 클래스는 크게 4가지로 분류 된다.</h2><ul><li>Association과 Dependency의 관계 구분에서 두 개의 구분 법중 가장 큰 기준은 <code>레퍼런스</code>를 유지하고 있느냐 아니냐 이다.</li></ul><blockquote><p>A, B라는 클래스가 있을때, A 클래스를 B 클래스가 메소드 내에서 new로 인스턴스화 시킨다면, 메소드가 끝날때 레퍼런스가 없어진다.<br>다만, B 클래스에서 A 클래스 변수를 정의하고 new 생성자로 인스턴스화 시킨다면, B 클래스에 레퍼런스가 종속되기 때문에, <code>Dependency</code> 관계라고 볼 수 있다.</p></blockquote><h1>Association 연관 관계</h1><ul><li>association 예제</li></ul><script src="//gist.github.com/743aea5912549cde2714ca2989500d39.js?file=association1.java"></script><ul><li>B와 A는 연관이 있다.<br><img src="/images/association.JPG" alt="association.JPG"></li></ul><blockquote><p>연관 관계에서 중요하게 볼점은 <code>연관 관계의 방향</code>과 <code>멀티 플리시티</code>이다.</p><blockquote><p>양방향 연관관계란, 서로의 존재를 알고 있다는 뜻이다. A와 B는 서로의 참조 값을 가지고 있다.<br>단방향 연관관계란, 한쪽은 다른 한쪽의 존재를 모른다. A만 B의 참조 값을 가지고 있다.</p></blockquote></blockquote><h1>Dependency 의존 관계</h1><ul><li>dependency 예제</li></ul><script src="//gist.github.com/743aea5912549cde2714ca2989500d39.js?file=dependency1.java"></script><ul><li>B가 A에게 의존한다.<br><img src="/images/dependency1.JPG" alt="dependency1.JPG"></li></ul><blockquote><ol><li>한 클래스의 메소드가 다른 클래스의 객체를 인자로 받아 그 메소드를 사용한다. (일반적인 경우)</li><li>한 클래스의 메소드가 또 다른 클래스의 객체를 반환한다.</li><li>다른 클래스의 메소드가 또 다른 클래스의 객체를 반환한다. 이때 이 메소드를 호출하여 반환되는 객체의 메소드를 사용한다.</li></ol></blockquote><h1>Association 연관 관계의 세부 구분</h1><ul><li>일반적인 연관 관계란 앞에서 살펴본 Association 연관 관계로 표현 된다.</li></ul><h1>Association 연관 관계의 특수 구분</h1><ul><li>Association의 특수 구분은 Composition과 Aggregation의 특별한 형태로 구분 된다.</li><li>특수 연관 관계의 구분은 <code>Life Cycle</code>이 같은지 다른지 이다.</li></ul><h2>Aggregation 집합 연관</h2><ul><li>aggregation 예제</li></ul><script src="//gist.github.com/743aea5912549cde2714ca2989500d39.js?file=aggregation.java"></script><ul><li>집합 연관 관계<br><img src="/images/aggregation.JPG" alt="aggregation.JPG"></li></ul><h2>Composition 합성 연관</h2><ul><li>composition 예제</li></ul><script src="//gist.github.com/743aea5912549cde2714ca2989500d39.js?file=composition.java"></script><ul><li>합성 연관 관계<br><img src="/images/composition.JPG" alt="composition.JPG"></li></ul><h1>inheritance 상속 관계</h1><script src="//gist.github.com/743aea5912549cde2714ca2989500d39.js?file=inheritance.java"></script><p><img src="/images/inheritance.JPG" alt="inheritance.JPG"></p><h1>interface 구현 관계</h1><script src="//gist.github.com/743aea5912549cde2714ca2989500d39.js?file=interface.java"></script><p><img src="/images/interface.JPG" alt="interface.JPG"></p><h1>끝으로</h1><blockquote><p>association 연관 관계의 특수 연관 관계인 aggregation과 composition의 관계 구분 법에서 재밌는 글을 봤다.<br><code>Life Cycle</code>을 구분하는 방법으로, 사람을 빗대어 표현했는데, 사람과 가같은 라이프 사이클인 팔과 다리 몸통 등 신체의 일부는 강한 집합 <code>Composition</code> 관계이고,<br>부수적으로 착용하는 옷, 안경, 핸드폰 등은 연관 관계가 있지만 라이프 사이클이 다른 <code>Aggregation</code> 관계라는 것이다.</p></blockquote><h1>Reference</h1><blockquote><ul><li><a href="http://geniusduck.tistory.com/entry/UML-%EA%B8%B0%EB%B3%B8%ED%8E%B8-%EA%B8%B0%EB%B3%B8-%ED%91%9C%EA%B8%B0-%ED%98%95%EC%8B%9D-%EB%B0%8F-%EA%B4%80%EA%B3%84%ED%91%9C%ED%98%84%EB%B2%95" target="_blank" rel="noopener">UML-기본편-기본-표기-형식-및-관계표현법</a></li><li><a href="http://weicomes.tistory.com/179" target="_blank" rel="noopener">UML-기본 표기 형식 및 관계 표현법</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;기호 정리 이유&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://jungha-cho.github.io/2018/03/29/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="UML" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/UML/"/>
    
    
      <category term="StartUML" scheme="http://jungha-cho.github.io/tags/StartUML/"/>
    
      <category term="UML" scheme="http://jungha-cho.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>객체지향설계-블랙잭(7)</title>
    <link href="http://jungha-cho.github.io/2018/03/29/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(7)/"/>
    <id>http://jungha-cho.github.io/2018/03/29/객체지향설계-블랙잭(7)/</id>
    <published>2018-03-28T15:50:01.000Z</published>
    <updated>2018-03-29T06:23:24.962Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 지향 설계 연습하기 - 블랙잭 (7)</h1><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github source code</a></p><h1>들어가며</h1><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h1>UML 3번째 버전입니다.</h1><p><img src="/images/blackjackv3.jpg" alt="UMLV3"></p><ul><li>블랙잭의 실제 룰 및 게임을 구현할 게임 판에서는 Dealer와 Player 두 객체의 최소한의 접근을 통해 게임 룰을 구현하고 싶었음.</li><li>따라서, 짜낼 수 있는 모든 생각을 동원해 추상화, 인터페이스를 이용했고, 객체가 가지는 실제 특성을 상속 및 인터페이스 구현에 집어 넣고 싶었음.</li><li>오늘까지 완성된 3번째 버전의 UML은… 주어진 목적은 달성했지만, 깔끔하지 못한것 같음.</li><li><code>개인 평가를 하자면, Rule 부분이 엉성하게 설계된것 같고, abstract, interface의 사용이 적절했는지 판단이 안됨.</code></li></ul><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">Github - BlackJack v4</a></p><h1>Source Code</h1><script src="//gist.github.com/5362c6a83e87ade07cc19cc8070b7127.js"></script>     <h1>끝으로</h1><blockquote><p>골몰히 보면서 이리 돌려보고 저리 돌려보고 있지만, 이게 맞는 설계인지, 아닌지 감도 잡히지 않습니다.</p><blockquote><p>디자인 패턴 책에서는 확장성, 의존성 분리 등등 문제에 맞는 해결 법을 제시하고 있지만,<br>저는 블랙잭 게임에서 문제를 정의하고 있지 못하고 있는것 같습니다.<br>따라서, 순수하게 객체로써 가져야할 행동들, 변수들을 정의해가면서 바꿔봤습니다.<br>따라서, UML은… 상식을 벗어날 수도 있습니다… 자신이 없네요.<br>이게 끝이 아닌 지속적으로 발전시켜 나갈 블랙잭 및 객체지향, 패턴 공부일테니 더 치열하게 고민해 봐야 될것 같습니다.</p></blockquote></blockquote><h1>Reference</h1><blockquote><ul><li><a href="http://geniusduck.tistory.com/entry/UML-%EA%B8%B0%EB%B3%B8%ED%8E%B8-%EA%B8%B0%EB%B3%B8-%ED%91%9C%EA%B8%B0-%ED%98%95%EC%8B%9D-%EB%B0%8F-%EA%B4%80%EA%B3%84%ED%91%9C%ED%98%84%EB%B2%95" target="_blank" rel="noopener">UML</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 지향 설계 연습하기 - 블랙잭 (7)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/BlackJack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github source code&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="디자인 패턴" scheme="http://jungha-cho.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="헤드 퍼스트 디자인 패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C-%ED%8D%BC%EC%8A%A4%ED%8A%B8-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>디자인패턴-Command (2)</title>
    <link href="http://jungha-cho.github.io/2018/03/27/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-Command-(2)/"/>
    <id>http://jungha-cho.github.io/2018/03/27/디자인패턴-Command-(2)/</id>
    <published>2018-03-27T10:56:40.000Z</published>
    <updated>2018-03-27T12:38:40.329Z</updated>
    
    <content type="html"><![CDATA[<h1>Command 패턴의 정의</h1><ul><li>커맨드 패턴을 이용하면 요구 사항을 객체로 캡슐화 가능하다.</li><li>매개 변수를 써서 여러 가지 다른 요구 사항을 집어넣을 수 있다.</li><li>요청 내역을 큐에 저장하거나 로그로 기록할 수 있으며, 작업 취소 기능도 지원한다.</li></ul><blockquote><p>Meta Command 패턴?</p><blockquote><p>메타 커맨드 패턴은 명령들로 이루어진 매크로를 만들어서 여러 개의 명령을 한 번에 실행 가능 하다.</p></blockquote></blockquote><h1>다이어그램</h1><p><img src="/images/commandv2.JPG" alt="commandv2"></p><h1>커맨드 패턴 활용법</h1><p>커맨드를 이용하면 컴퓨테이션의 한 부분을 패키지로 묶어서 일급 객체 형태로 전달하는 것도 가능하다.<br>말이 좀 어렵지만, 책에서는 Thread Pool을 이용해 설명하고 있다. 작업큐는 execute 커맨드를 이용해 큐에 넣는 곳과 빼는곳이 있는데 빼는곳에서는 여러개의 스레드가 기다리고 있다가, 순서대로 작업을 처리한다. 하지만 스레드는 작업의 내용을 알고 처리하진 않는다.</p><p>이용법들</p><ul><li>Command 인터페이스에 logging 메소드를 추가해 로그를 기록하게 한다.</li><li>store 메소드를 추가해 특정 작업까지 수행했다는 체크 포인트를 만들고, 종료 후 다시 시작할때 체크 포인트 부터 시작하게 구현 할 수 있다.</li></ul><h1>업무 적용?</h1><p>업무에 사용되는 Java 기반 Client 프로그램은 작업의 과정은 똑같지만, 작업 내용은 세세하게 달라지는 부분이 있다. 커맨드 패턴을 공부하면서 해당 부분이 번뜩 떠올랐으며, 작업 처리 프로세스와 작업 종류를 분리해 작업 종류의 확장성과 의존성 분리의 이점을 가져올 수 있을 것 같다는 생각이 들었다. Invoker와 Receiver를 분리 시키는 Command 패턴 처럼 말이다.</p><h1>Reference</h1><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Command 패턴의 정의&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;커맨드 패턴을 이용하면 요구 사항을 객체로 캡슐화 가능하다.&lt;/li&gt;
&lt;li&gt;매개 변수를 써서 여러 가지 다른 요구 사항을 집어넣을 수 있다.&lt;/li&gt;
&lt;li&gt;요청 내역을 큐에 저장하거나 로그
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="헤드퍼스트디자인패턴" scheme="http://jungha-cho.github.io/categories/Book/%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"/>
    
      <category term="Command" scheme="http://jungha-cho.github.io/categories/Book/%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/Command/"/>
    
    
      <category term="헤드퍼스트디자인패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"/>
    
      <category term="디자인패턴" scheme="http://jungha-cho.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"/>
    
      <category term="Command" scheme="http://jungha-cho.github.io/tags/Command/"/>
    
  </entry>
  
  <entry>
    <title>디자인패턴-Command (1)</title>
    <link href="http://jungha-cho.github.io/2018/03/27/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-Command/"/>
    <id>http://jungha-cho.github.io/2018/03/27/디자인패턴-Command/</id>
    <published>2018-03-27T07:54:09.000Z</published>
    <updated>2018-03-27T12:10:29.846Z</updated>
    
    <content type="html"><![CDATA[<h1>Command 패턴</h1><p>메소드 호출을 캡슐화한다. 메소드 호출을 캡슐화하면 호출하는 쪽에선 메소드 내용에 신경쓰지 않아도 되고, 호출 당한 쪽은 일만 잘 하면 된다.</p><ul><li><code>커맨드 객체</code>을 이용해서 메소드 호출이 캡슐화 되기 때문에 달라지는 부분을 달라지지 않는 부분으로 부터 분리 시킬수 있고, 느슨한 결합이 완성된다.</li></ul><h1>Simple Source Code</h1><ul><li>Command interface, 일반적으로 execute 메소드 하나만 가진다.</li></ul><script src="//gist.github.com/b00353f60e9a724206c2a5403d040a72.js?file=Command.java"></script>    <ul><li>컴퓨터 객체, 간단하게 Power on, off</li></ul><script src="//gist.github.com/b00353f60e9a724206c2a5403d040a72.js?file=Computer.java"></script>    <ul><li>컴퓨터의 동작을 정의하는 클래스 이지만, command interface를 구현해 동작을 캡슐화 함.</li></ul><script src="//gist.github.com/b00353f60e9a724206c2a5403d040a72.js?file=ComputerOnCommand.java"></script>    <ul><li>SimpleRemoteControl은 컴퓨터를 원격으로 키고 끌수 있는 리모컨을 구현.</li><li>Computer와 ComputerOnCommand와는 어떤 의존성도 없으며 Command Interface를 통해 실행됨.</li></ul><script src="//gist.github.com/b00353f60e9a724206c2a5403d040a72.js?file=SimpleRemoteControl.java"></script>    <ul><li>테스트!</li></ul><script src="//gist.github.com/b00353f60e9a724206c2a5403d040a72.js?file=RemoteControlTest.java"></script>    <p><img src="/images/commandv1.jpg" alt="commandv1"></p><h1>Github</h1><blockquote><ul><li><a href="https://github.com/JungHa-Cho/HeadFirstDesignPattern/tree/master/src/main/java/head/first/design/pattern/rule/command" target="_blank" rel="noopener">Github</a></li></ul></blockquote><h1>Reference</h1><blockquote><ul><li>에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠, 『 Head First Desgin Pattern』, 서환수 옮김, O’Reilly(1999.6.24).</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Command 패턴&lt;/h1&gt;
&lt;p&gt;메소드 호출을 캡슐화한다. 메소드 호출을 캡슐화하면 호출하는 쪽에선 메소드 내용에 신경쓰지 않아도 되고, 호출 당한 쪽은 일만 잘 하면 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;커맨드 객체&lt;/code&gt;을 이용해
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="헤드퍼스트디자인패턴" scheme="http://jungha-cho.github.io/categories/Book/%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"/>
    
      <category term="Command" scheme="http://jungha-cho.github.io/categories/Book/%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/Command/"/>
    
    
      <category term="헤드퍼스트디자인패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"/>
    
      <category term="디자인패턴" scheme="http://jungha-cho.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"/>
    
      <category term="Command" scheme="http://jungha-cho.github.io/tags/Command/"/>
    
  </entry>
  
  <entry>
    <title>디자인패턴-Singleton</title>
    <link href="http://jungha-cho.github.io/2018/03/27/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-Singleton/"/>
    <id>http://jungha-cho.github.io/2018/03/27/디자인패턴-Singleton/</id>
    <published>2018-03-27T06:40:37.000Z</published>
    <updated>2018-03-27T08:30:59.315Z</updated>
    
    <content type="html"><![CDATA[<h1>Singleton</h1><p>유일무이한 하나의 객체를 뜻하는 패턴, 스레드 풀이라던지, 로그를 출력하거나 정리하는 객체, 프로세스를 감시하는 객체 등등을 뜻한다. 다만 유일하게 존재해야 하는 이유는 여러가지로 성능, 이상 동작, 자원 절약 등등이 있다.</p><p>라고 쓰여 있지만, 딱히 와닿지 않는다. 역시 개발자는 코드를…</p><h1>Old Singleton</h1><h2>OldSingleton1.java</h2><ul><li>싱글턴일까?</li></ul><script src="//gist.github.com/7edda092b2a29977180678e2e377f184.js?file=OldSingleton1.java"></script>    <h2>OldSington2.java</h2><ul><li>싱글턴!</li></ul><script src="//gist.github.com/7edda092b2a29977180678e2e377f184.js?file=OldSingleton2.java"></script>    <h1>싱글턴의 정의</h1><p><code>싱글턴 클래스는 하나의 인스턴스만 생성되며, 언제든, 어디서든 접근 가능하도록 만들기 위한 패턴</code></p><h1>조건</h1><ul><li>싱글턴 클래스는 자기 자신을 하나만 생성해 관리 하도록 구성한다.</li><li>싱글턴 클래스는 다른 어떤 곳에서도 싱글턴 클래스의 인스턴스를 생성하지 못하도록 막는다.</li></ul><h1>OldSingleton은 어느 실행 환경에서도 안전할까?</h1><p>MultiThread 환경에서는 OldSingeton의 <code>if (uniqueInstance == null)</code>이 문제가 될 수도 있다.<br>이 될 수도 있다라는 말이 굉장히 애매하게 들리지만, 실제로 잘 돌아갈 수도 있고, 어떨때엔 굉장한 문제 동작을 뿜어낸다.<br>업무에 쓰이는 Java 프로그램은 멀티 스레드 기반으로 동작을 하는데, 새로운 플랫폼에 다시 개발을 진행하면서 프로그램 전역 변수를 관리하는 클래스가 멀티스레드 환경에서 오동작하는 것을 굉장히 오랜 시간 추적해 잡아낸 적이 있다. 그때도 똑같이 잘 되다가, 오동작하고, 잘되다가 오동작 했으며, 컴파일시 잡히는 오류는 아니기에 굉장히 고생했던 기억이다.</p><h1>싱글턴의 여러가지 모양새</h1><ul><li>처음부터 초기화, JVM에서 유일하게 생성해 준다.</li></ul><script src="//gist.github.com/7edda092b2a29977180678e2e377f184.js?file=Singleton3.java"></script>    <ul><li>DCL ( Double Checking Locking )</li><li>volatile 키워드의 자세한 내용은 레퍼런스를 참조</li></ul><script src="//gist.github.com/7edda092b2a29977180678e2e377f184.js?file=Singleton4.java"></script>    <blockquote><ul><li>volatile은 해당 키워드가 선언된 변수의 읽기 쓰기만 동기화 하지만, synchronized는 특정 작업 전체를 동기화 가능하다.</li><li>int a = b + 10 을 예로 들면 특정 스레드는 b의 값에 10을 더한 값을 들고 갈 수도 아닐수도 있다.</li></ul></blockquote><h1>Reference</h1><blockquote><ul><li><a href="http://blog.javarouka.me/2012/04/volatile-keyword-in-java.html" target="_blank" rel="noopener">Volatile</a></li><li>에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠, 『 Head First Desgin Pattern』, 서환수 옮김, O’Reilly(1999.6.24).</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Singleton&lt;/h1&gt;
&lt;p&gt;유일무이한 하나의 객체를 뜻하는 패턴, 스레드 풀이라던지, 로그를 출력하거나 정리하는 객체, 프로세스를 감시하는 객체 등등을 뜻한다. 다만 유일하게 존재해야 하는 이유는 여러가지로 성능, 이상 동작, 자원 절약 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="헤드퍼스트디자인패턴" scheme="http://jungha-cho.github.io/categories/Book/%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"/>
    
      <category term="SINGLETON" scheme="http://jungha-cho.github.io/categories/Book/%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/SINGLETON/"/>
    
    
      <category term="헤드퍼스트디자인패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"/>
    
      <category term="SINGLETON" scheme="http://jungha-cho.github.io/tags/SINGLETON/"/>
    
  </entry>
  
  <entry>
    <title>Win 검색에 지친 나를 위해</title>
    <link href="http://jungha-cho.github.io/2018/03/27/Win-%EA%B2%80%EC%83%89%EC%97%90-%EC%A7%80%EC%B9%9C-%EC%82%AC%EB%9E%8C%EC%9D%84-%EC%9C%84%ED%95%B4/"/>
    <id>http://jungha-cho.github.io/2018/03/27/Win-검색에-지친-사람을-위해/</id>
    <published>2018-03-27T02:59:33.000Z</published>
    <updated>2018-03-28T16:13:26.900Z</updated>
    
    <content type="html"><![CDATA[<h1>Windows 7, 10의 검색 기능</h1><p>워낙 많은 프로그램을 깔고, 웹도 개인용, 회사용, 개인 스케줄용 웹을 3가지, 메신저도 사내용, 슬랙, 카카오톡…<br>또 편집기 (vscode, atom, notepad++), Intellij, eclipse 그리고 각종 DB 툴… 더해서 커맨드창까지<br>어마어마하게 많은 양을 사용하는데, 한가지에 집중해서 그 프로그램의 기능을 세부적으로 알아가고 더 잘 사용했으면 좋겠지만<br>성격상 새로운 툴과 새로운 경험을 접하는 것이 더 재미있고 좋아하기 때문에 자연스럽게 <code>Windows에 수 많은 프로그램</code>이 깔려 있습니다.</p><p>이래 저래 하드하게 프로그램을 사용하다 보면 끄고 키고 하는일이 비일비재 한데, 이 검색 기능이 Windows 10에 들어오면서 부터 이상합니다. Intellij 를 키고 싶어 윈도우 키를 누른 후 검색을 하면 최상단에 Intellij 폴더를 찾고, shell을 열고 싶어 Xshell, Putty 등을 검색하면 프로그램이 없고… 이를 수정해 보기 위해 Windows 자체 검색 기능의 인덱스를 검색해 보는둥 갖은 방법을 썻지만 상황은 더 악화되어 갔고… 귀찮아져버려서 마우스로 프로그램을 키는 지경까지 이르렀습니다.</p><h1>Github에서 발견!</h1><p>평소 이래 저래 오픈 소스 프로그램을 즐겨 찾아보고 사용해 보는지라 Github에서 떠돌아 다닌던 중 <a href="https://github.com/hainproject/hain/" target="_blank" rel="noopener">hain</a> 프로그램을 만났습니다. <a href="https://github.com/hainproject/hain/releases" target="_blank" rel="noopener">다운로드</a>는 여기에서 받으실 수 있으며, 지금은 Git Repository가 업데이트 되지 않는 상황이라, 최신 릴리즈가 진행이 되지 않고 있지만, 윈도우 검색 기능은 충분히 대처 가능합니다.</p><h1>사용법</h1><p><img src="/images/hain1.png" alt="hain"></p><p>hain 설치 후 <code>Alt+Space Bar</code> 불러올 수 있으며, 사용법은 충분히 직관적이며 사용하기 편합니다.<br>또한 /hpm 으로 검색하면 npm 기반 플러그인 생태계를 이용 가능하며, 저는 <code>Google-search</code> 기능을 설치해 Hain으로 바로 구글 검색을 하고 있습니다.</p><blockquote><p>MAC OS는 기본 기능인 Finder외 Forklift, Alfred 등 유용항 툴이 많습니다.</p></blockquote><hr><h1>Reference</h1><blockquote><ul><li><a href="https://github.com/hainproject/hain/" target="_blank" rel="noopener">hain Github</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Windows 7, 10의 검색 기능&lt;/h1&gt;
&lt;p&gt;워낙 많은 프로그램을 깔고, 웹도 개인용, 회사용, 개인 스케줄용 웹을 3가지, 메신저도 사내용, 슬랙, 카카오톡…&lt;br&gt;
또 편집기 (vscode, atom, notepad++), Intel
      
    
    </summary>
    
      <category term="Tools" scheme="http://jungha-cho.github.io/categories/Tools/"/>
    
      <category term="생산성" scheme="http://jungha-cho.github.io/categories/Tools/%EC%83%9D%EC%82%B0%EC%84%B1/"/>
    
      <category term="Windows" scheme="http://jungha-cho.github.io/categories/Tools/%EC%83%9D%EC%82%B0%EC%84%B1/Windows/"/>
    
    
      <category term="github" scheme="http://jungha-cho.github.io/tags/github/"/>
    
      <category term="Open Source" scheme="http://jungha-cho.github.io/tags/Open-Source/"/>
    
      <category term="Hain" scheme="http://jungha-cho.github.io/tags/Hain/"/>
    
  </entry>
  
  <entry>
    <title>객체지향설계-블랙잭(6)</title>
    <link href="http://jungha-cho.github.io/2018/03/27/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(6)/"/>
    <id>http://jungha-cho.github.io/2018/03/27/객체지향설계-블랙잭(6)/</id>
    <published>2018-03-27T01:56:30.000Z</published>
    <updated>2018-03-28T00:50:50.930Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 지향 설계 연습하기 - 블랙잭 (6)</h1><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github source code</a></p><h3>0. 들어가며</h3><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h3>1. UML 수정</h3><blockquote><p>UML은 전혀 사용해보지 않은 사람으로써, 학부때 맛만 봤다는 것을 알린다… 따라서 아래 UML은 전혀 사실과 다를 수도 있다.<br>UML에 대한 댓글 환영합니다.</p></blockquote><p><img src="/images/BLACKJACKV2.JPG" alt="UMLV2"></p><p>UML 수정 했습니다.<br>아레 레퍼런스에 있는 UML 참고 블로그에서 하나씩 읽어본 결과, DENOMINATION, SUIT, CARD, DECK, HAND, DEALER, PLAYER는 강집합 관계인걸로 판단했습니다. 끗수와 모양은 카드의 존재 가치이고, 카드가 없으면 끗수와 모양도 없습니다. (블랙잭 게임 내에서) 또 덱은 카드가 없으면, 딜러와 플레이어는 핸드와 덱이 없으면 존재 가치가 없습니다. <code>Hand에 있는 Card가 애매한데</code> Card를 직접 Hand 내에서 객체 생성 및 의존성이 있는 것은 아니지만, 리스트에 카드를 담아 놓으므로 연관성은 있어 보입니다. 핸드 클래스 내에서 카드는 있어도 되고 없어도 되지만, 핸드의 필수 요소 입니다. 하지만, 카드가 없다 해도 Hand가 없어지진 않습니다. 다만, <code>게임 관례상 핸드에 카드가 없는 경우는 없습니다.</code> 따라서 Hand 클래스의 부분처럼 보여, Hand와 Card의 관계를 Aggregation으로 설정했습니다.</p><h2>Reference</h2><blockquote><ul><li><a href="http://geniusduck.tistory.com/entry/UML-%EA%B8%B0%EB%B3%B8%ED%8E%B8-%EA%B8%B0%EB%B3%B8-%ED%91%9C%EA%B8%B0-%ED%98%95%EC%8B%9D-%EB%B0%8F-%EA%B4%80%EA%B3%84%ED%91%9C%ED%98%84%EB%B2%95" target="_blank" rel="noopener">UML</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 지향 설계 연습하기 - 블랙잭 (6)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/BlackJack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github source code&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="디자인 패턴" scheme="http://jungha-cho.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="헤드 퍼스트 디자인 패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C-%ED%8D%BC%EC%8A%A4%ED%8A%B8-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>객체지향설계-블랙잭(5)</title>
    <link href="http://jungha-cho.github.io/2018/03/26/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(5)/"/>
    <id>http://jungha-cho.github.io/2018/03/26/객체지향설계-블랙잭(5)/</id>
    <published>2018-03-26T13:15:50.000Z</published>
    <updated>2018-03-27T00:19:59.264Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 지향 설계 연습하기 - 블랙잭 (5)</h1><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github source code</a></p><h3>0. 들어가며</h3><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h3>1. 또 다시 6일만에…</h3><p>시간이 없기도 했지만, 뭔가 제대로 설계 및 구현 해보고 싶은 욕심에 진도가 더 이상 나가질 않는다.<br>2018-03-26 시간으로 <a href="https://github.com/JungHa-Cho/HeadFirstDesignPattern" target="_blank" rel="noopener">헤드 퍼스트 디자인 패턴</a>을 Factory 까지 다시 끝냈으며, 현재까지 진도가 나간 부분을 바탕으로 블랙잭 구현에 적용해 보고자 한다.</p><h3>2. 패턴 원칙, 지금까지 배운것들까지만.</h3><p><code>디자인 원칙 1 - 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로 부터 분리 시킨다</code><br><code>디자인 원칙 1 - 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다.</code><br><code>디자인 원칙 2 - 구현이 아닌 인터페이스에 맞춰서 프로그래밍 한다.</code><br><code>디자인 원칙 3 - 상속보다는 구성을 활용한다.</code><br><code>디자인 원칙 4 - 서로 상호작용 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.</code><br><code>디자인 원칙 5 - 추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하도록 만들지 않도록 한다.</code></p><p>말은 쉽지… 처음이 다 어렵겠지만, 지금 더더욱더 어렵게 느껴지는것 같다.<br>몇일간 블랙잭 프로젝트를 조금 더 다듬어 보고자 패턴 책을 다시 읽었지만, 바뀌는건 없는것 같다.<br>무엇인가 큰 그림이 그려지지 않는것 같아서 UML을 그려 보았다.</p><h3>3. UML</h3><blockquote><p>UML은 전혀 사용해보지 않은 사람으로써, 학부때 맛만 봤다는 것을 알린다… 따라서 아래 UML은 전혀 사실과 다를 수도 있다.</p></blockquote><p><img src="/images/BLACKJACK_v1.JPG" alt="UMLV1"></p><blockquote><p>이제 이 UML을 바탕으로 블랙잭 프로젝트에서 객체 지향을 적용해보며 가지고 놀 생각이다.<br>지금은 엉망이지만, 앞으로 업데이트될 도식과 블랙잭 프로젝트를 기대하며… 잠이와서… 그만…<br>전체적인 개발 능력의 깊이를 숙성시키기 위한 프로젝트는 계속된다.</p></blockquote><h2>Reference</h2><blockquote><ul><li><a href="http://geniusduck.tistory.com/entry/UML-%EA%B8%B0%EB%B3%B8%ED%8E%B8-%EA%B8%B0%EB%B3%B8-%ED%91%9C%EA%B8%B0-%ED%98%95%EC%8B%9D-%EB%B0%8F-%EA%B4%80%EA%B3%84%ED%91%9C%ED%98%84%EB%B2%95" target="_blank" rel="noopener">UML</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 지향 설계 연습하기 - 블랙잭 (5)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/BlackJack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github source code&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="디자인 패턴" scheme="http://jungha-cho.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="헤드 퍼스트 디자인 패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C-%ED%8D%BC%EC%8A%A4%ED%8A%B8-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>장애응대-SOCKET편 (1)</title>
    <link href="http://jungha-cho.github.io/2018/03/21/%EC%97%85%EB%AC%B4-%EC%9D%B4%EC%95%BC%EA%B8%B0-%EC%9E%A5%EC%95%A0%ED%8E%B8%20(1)/"/>
    <id>http://jungha-cho.github.io/2018/03/21/업무-이야기-장애편 (1)/</id>
    <published>2018-03-21T00:33:43.000Z</published>
    <updated>2018-03-26T13:16:16.430Z</updated>
    
    <content type="html"><![CDATA[<h1>업무 이야기, 장애편 (1)</h1><h3>0. 업무 환경</h3><ul><li>현재 근무 중인 회사는 서비스 회사이며, 회사 자체 IDC에 서비스 서버를 두고 고객사에 CLIENT JAVA 프로그램을 설치해 회사 서버와 TCP/IP, SOCKET으로 자료를 주고 받는다.</li><li>CLIENT JAVA 프로그램 담당으로 주로 CLIENT 프로그램 <code>개발/유지보수/고객사 장애 응대</code> 등을 담당하고 있다.</li><li>실제 고객사 환경은 엄청나게 다양하며, 간간히 SPARC, HP-UX 또는 kernel 버전이 jre 1.6도 안깔리는 구식 환경 등등 모두 처음 보는 환경에서 업무를 응대 했어야 했다.</li><li>근 몇달새 차세대 프로젝트가 마무리되어 배포되고 서비스가 런칭되어, CLIENT도 발맞춰 변경되었는데, 서비스 초기 극도의 불안정성과 버그 또는 장애가 발생하며, 수만은 장애를 응대하게 됐다.</li><li>장애를 분석하고, 고객사에게 해결책을 제시했던 것 또한 자산이기에 기록하기로 했다.</li></ul><h3>1. CLIENT JAVA 프로그램</h3><p>Java <code>Write Once, Run Anywhere</code>라는 슬로건으로 설명 되듯이, 하나의 소스코드로 리눅스, 윈도우 등 고객사 환경에 가리지 않고 실행 된다. 다만, 고객사의 Data Base는 CLIENT가 제공하지 않는데 여기가 포인트다. 다양한 고객사의 Data Base 환경 때문에 엄청나게 많은 장애가 이 부분에서 발생한다. 당장 지금 기억나는 것만 해도 Oracle의 물리적 저장 공간 제한 때문에 쿼리가 실패하고, 고객사가 테이블에 걸어논 트리거 때문에 CLIENT 프로그램의 쿼리가 같이 실패하고, MySQL의 특정 버전에서는 Auto_Increment가 테이블에 생성된 데이터에 맞춰 자동으로 보정되지 않아서 서버를 내렸다 올리면 Insert 쿼리가 실패하는 등 수많은 고객사 장애를 맞이했다.</p><p>어떤 작업을 진행하고 기록을 남기는 DB 작업이 실패했다 함은 과금, 통계 등 신뢰성에 금이 가는 것이기 때문에 고객사와의 수많은 실랑이와 줄다리기가 벌어졌다. 지금은 그 사이 어느 쯤에선가에서 Data Base는 고객사의 관리 영역 이므로 Data Base 장애가 CLIENT 프로그램 장애로 오염되는 것을 칼같이 찝어주고 분쟁점을 최소화 하고 있다. 다만, Data Base 장애 이외에 서비스가 새로 런칭하면서 새롭게 바뀐 CLIENT 프로그램 또한 초반에는 수많은 버그와 에러를 뿜어댓다. 이제 이 장애편을 포스팅 하면서 이때까지 경험한 장애를 기록하고자 한다.</p><h3>2. SOCKET</h3><p>입사 후 인계 받은 CLIENT JAVA 프로그램은 <a href="http://java.net" target="_blank" rel="noopener">java.net</a> 패키지의 레거시 소켓 함수를 사용하고 있었고, 예외 처리 및 이에 해당하는 로직은 모두 비즈니스 로직과 연계되어 있었다. 이 소켓 부분에서 깔끔하게 또는 시원하게 해결되는 장애가 아니라 쿰쿰한, 찝찝한 장애들이 많이 발생했는데, 대표적인 것으로 HEARBEAT 패킷이 전달 되었는데도, 특정 상황이 되면 소켓이 끊겨 클라이언트와 서버가 재접속 되는 상황이 발생했다.</p><blockquote><p>소켓은 여러가지 옵션을 제공하는데, 자세한 내용은 <a href="http://cbts.tistory.com/125" target="_blank" rel="noopener">소켓 옵션</a>을 참조 바란다.</p></blockquote><ul><li>HEART BEAT 패킷은 소켓이 제공하는 keepAlive 옵션 외에 실제 데이터를 클라이언트와 서버가 서로 약속한 양식에 맞춰 주고 받은뒤 소켓이 정상적으로 동작하는 것을 확인하는 작업이다.</li><li>30초마다 한번씩, 1분이 넘어가도 HEART BEAT 패킷이 오지 않으면, 서로 소켓을 끊기로 약속 되어 있다.</li></ul><h3>3. CLIENT 로그에는 HEART BEAT 패킷이 SEND가 정상적으로 진행 됐다는게 찍혀 있어요…</h3><p>CLIENT 로그에는 HEART BEAT 패킷이 정상적으로 SEND 되었다는게 찍혀 있었다. 하지만, ACK 응답이 1초 내에 오는 일반적인 상황과는 달리 SEND 로그만 찍혀 있다. 누가 봐도 SERVER에서 안줬네 라는 말이 나오는 상황이지만, 실제 내용은 달랐다.</p><p><img src="/images/client-server-socket.JPG" alt="SOCKET"></p><ul><li>각각의 소켓은 RecvQueue와 SendQueue가 있으며 해당 큐의 사이즈는 Byte 기준으로 각각의 OS마다 디폴트 용량이 다르다.</li><li>클라이언트는 자신의 소켓 SendQueue에 Write 하면 OS단에서 전송하고, RecvQueue에서 수신받는 패킷에 대한 Read만 수행하면 된다.</li><li>각각 클라이언트와 서버의 RecvQueue SendQueue를 실시간으로 확인하고 싶으면 아래 명령어를 따라해보자.</li></ul><blockquote><p>CentOS 6.9 기준, IP는 확인하고 싶은 연결의 IP를 입력하면 된다.</p><blockquote><p><code>watch -n 0.1 &quot;ss -t | grep 192.168.0.1&quot;</code></p></blockquote></blockquote><ul><li><p>눈으로 모니터링을 하다보면, 주사기 같다는 생각을 하게 된다. 한쪽에서 주사기를 꾹 누르면 주사기 입구에서 내용물을 쭈욱 뱉어내듯이, SendQueue로 Write만 하면 반대편 RecvQueue로 전달되고 Read가 읽혀 RecvQueue에 있는 데이터를 빼줘야만, 서로 연결된 Send, Recv Queue가 원활히 순환한다.</p></li><li><p><code>여기서 문제는, 한쪽에서 Read 작업이 늦어지게 되면, 보내는쪽도 같이 데이터 순환이 밀리게 된다.</code></p></li><li><p>이 문제점 때문에 흔히 얘기하는 Peak 타임, 즉 서버 사용량이 많아 지는 시간대에는 Read 작업이 밀리게 되고, Client는 정상적으로 HEART BEAT 패킷을 Write 했지만, 서버에서는 밀림 현상 때문에 HEART BEAT 패킷을 받지 못해 소켓이 끊어진 것으로 판단해 연결을 끊어 버린 것이다.</p></li></ul><h3>4. 해결책</h3><ul><li>Socket의 비즈니스 로직 의존도를 낮춰야 한다.</li><li>Socket에서 Read한 데이터는 Queue를 사용해서 쌓아 둔다던가, I/O 속도가 빠른 DB 등을 캐쉬 형태로 사용한다던가, Socket과 비즈니스는 확실하게 분리 시켜야 된다.</li></ul><h4>처음 작성해 보는 장애 정리 포스팅인데, 좀 장황한것 같다.</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;업무 이야기, 장애편 (1)&lt;/h1&gt;
&lt;h3&gt;0. 업무 환경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재 근무 중인 회사는 서비스 회사이며, 회사 자체 IDC에 서비스 서버를 두고 고객사에 CLIENT JAVA 프로그램을 설치해 회사 서버와 TCP/IP, S
      
    
    </summary>
    
      <category term="업무" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/"/>
    
      <category term="장애" scheme="http://jungha-cho.github.io/categories/%EC%97%85%EB%AC%B4/%EC%9E%A5%EC%95%A0/"/>
    
    
      <category term="Socket" scheme="http://jungha-cho.github.io/tags/Socket/"/>
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
      <category term="DataBase" scheme="http://jungha-cho.github.io/tags/DataBase/"/>
    
      <category term="MyBatis" scheme="http://jungha-cho.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>디자인패턴-STRATEGY</title>
    <link href="http://jungha-cho.github.io/2018/03/20/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-STRATEGY/"/>
    <id>http://jungha-cho.github.io/2018/03/20/디자인패턴-STRATEGY/</id>
    <published>2018-03-20T11:22:13.000Z</published>
    <updated>2018-03-27T08:30:50.019Z</updated>
    
    <content type="html"><![CDATA[<h1>헤드퍼스트디자인패턴 - STRATEGY</h1><p><a href="https://github.com/JungHa-Cho/HeadFirstDesignPattern" target="_blank" rel="noopener">github.com</a></p><h3>0. 다시 시작</h3><ul><li>블랙잭 구현 중 막장 설계 및 스파게티 코드가 나오는것을 보고 손놨던 헤드 퍼스트 디자인 패턴 책을 다시 펼처본다.</li><li>책을 읽으며 생각을 정리하는 방식으로 블로깅</li></ul><h3>1. STRATEGY란</h3><p>EXTENDS, 자바에서 익숙하게 보이는 키워드이며 상속을 의미한다.<br>도입부에선 이 상속의 문제점을 짚고 있다.</p><p>오리는 추상 개념이며, 실제 오리의 종류는 여러 가지이다.<br>청동 오리, 식용 오리 등등… 학명으로 따지자면 수십가지 일 것이다.<br>다만 이러한 오리라는 추상 개념을 자바에 가져왔을때, 고무 오리, 나무 오리 등등은 오리 추상 클래스를<br>상속받는다면, 고무 오리, 나무 오리가 날아다니고 꽥꽥 소리 지를거라는 문제점을 지적하고 있다.</p><p>이는 중간 해결점에서 Flyable, Quackable이라는 인터페이스로 해결하고자 하지만, 이 또한 올바르지 않으며<br>오히려 최악의 방법이라 지적하고 있다.</p><p>인터페이스를 활용해 고무 오리가 날아다니고 나무 오리가 꽥꽥 꺼리는 상황은 방지 할 수 있지만, 코드 재사용성 측면에서 최악이라 꼬집고 있다.</p><p><code>캡슐화, 사용자에게 필요 없는 정보는 뒷단에 숨겨 보이지 않게 한다.</code><br><code>캡슐화, 설계 단계에서 자주 바뀔것 같은 부분과 바뀌지 않을 부분을 구분하여 캡슐화한다.</code></p><p>헤드퍼스트에서 얘기하는 원칙 중 구현이 아닌 인터페이스에 맞춰 프로그래밍한다는 디자인 원칙이 소개 된다.<br>풀어보자면, 클래스는 변수와 함수의 집합이며 나 또한 한 객체를 만들때 해당 객체가 동작할때 필요한 변수와 함수를 직접 클래스에 프로그래밍 했다. 설계와 훗일은 생가지도 않은채…</p><p>이렇게 되면 항상 내가 만든 클래스가 어떤 클래스에 종속되고 코드를 더 작성하거나 변경하는 것 외에는 행동을 변경할 여지가 없었다. 책에서는 이부분을 구현이 아닌 인터페이스에 맞춰서 프로그래밍 하라고 원칙을 세우고 있다.</p><p>여기서 인터페이스란 중의적 의미로 꼭 자바의 interface 키워드만을 사용하라고 강조하는 것이 아니라, abstract, interface 등 상위 형식을 사용해 프로그래밍하라는 의미이며, 이는 객체를 변수에 대입할때 상위 형식을 구현한 형식이라면 어떤 객체든 집어넣을수 있기 때문에 유연성이 커진다는 것이다.</p><p>책에서는 애니멀 객체를 상속받은 개 클래스와 고양이 클래스를 예로 들고 있다. 애니멀 객체는 makeSound() 메소드를 가지고 있으며, 개와 고양이 클래스는 이 메소드를 상속받아 올바른 행동만 구현 한다면 dog 객체를 Animal 상위 형식으로 만들어 사용할 수 있다.</p><p><code>처음 부터 완벽한 소프트웨어는 있을 수 도 있지만, 개발 라이프 사이클 어느 단계에서라도 디자인 원칙을 적용해 리팩토링 가능하다.</code></p><h2>끝으로</h2><ul><li>BLACKJACK 게임을 디자인 패턴 및 객체 지향적 설계를 적용해 공부해 보고 있던 도중, 짜파게티… 또는 한심한 코드가 나와 손을 놨던, 디자인 패턴 책을 다시 읽어 보며 정리를 해봤다.</li><li>또다시 읽으니 새로운 내용이 보이며, 실 업무에 적용을 해보고 싶은 욕구가 든다.</li></ul><h1>Reference</h1><blockquote><ul><li>에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠, 『 Head First Desgin Pattern』, 서환수 옮김, O’Reilly(1999.6.24).</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;헤드퍼스트디자인패턴 - STRATEGY&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/HeadFirstDesignPattern&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github.com&lt;/
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="헤드퍼스트디자인패턴" scheme="http://jungha-cho.github.io/categories/Book/%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"/>
    
      <category term="STRATEGY" scheme="http://jungha-cho.github.io/categories/Book/%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/STRATEGY/"/>
    
    
      <category term="헤드퍼스트디자인패턴" scheme="http://jungha-cho.github.io/tags/%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"/>
    
      <category term="STRATEGY" scheme="http://jungha-cho.github.io/tags/STRATEGY/"/>
    
  </entry>
  
  <entry>
    <title>객체지향설계-블랙잭(4)</title>
    <link href="http://jungha-cho.github.io/2018/03/20/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(4)/"/>
    <id>http://jungha-cho.github.io/2018/03/20/객체지향설계-블랙잭(4)/</id>
    <published>2018-03-20T08:23:10.000Z</published>
    <updated>2018-03-26T13:18:11.165Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 지향 설계 연습하기 - 블랙잭 (4)</h1><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github source code</a></p><h3>0. 들어가며</h3><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h3>약 6일만에 다시 시작했다.</h3><h3>생각 없이 상관 관계를 생각하며, 코드를 짜다보니, 또 짜파게티가 된것 같다.</h3><h3>코딩전 설계의 시작점에서 어떻게 설계를 시작해야하는지 참고할만한 문서는 없을까?</h3><ul><li>Rule.java</li></ul><script src="//gist.github.com/fcfb50aedb66df76aef19cc1a56ea57a.js?file=Rule.java"></script>   <ul><li>User.java</li></ul><script src="//gist.github.com/fcfb50aedb66df76aef19cc1a56ea57a.js?file=User.java"></script>   <ul><li>Hand.java</li></ul><script src="//gist.github.com/fcfb50aedb66df76aef19cc1a56ea57a.js?file=Hand.java"></script>   <ul><li>Player.Java</li></ul><script src="//gist.github.com/fcfb50aedb66df76aef19cc1a56ea57a.js?file=Player.java"></script>   <ul><li>Dealer.java</li></ul><script src="//gist.github.com/fcfb50aedb66df76aef19cc1a56ea57a.js?file=Dealer.java"></script>    <h4>2018-03-21 GIST 테스트 및 전환</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 지향 설계 연습하기 - 블랙잭 (4)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/BlackJack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github source code&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/tags/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 4장 클래스와 인터페이스 (1)</title>
    <link href="http://jungha-cho.github.io/2018/03/15/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-4%EC%9E%A5-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-1/"/>
    <id>http://jungha-cho.github.io/2018/03/15/이펙티브자바-4장-클래스와-인터페이스-1/</id>
    <published>2018-03-15T07:33:51.000Z</published>
    <updated>2018-03-26T13:16:24.671Z</updated>
    
    <content type="html"><![CDATA[<h1>이펙티브자바 4장 클래스와 인터페이스 (1)</h1><h3>규칙 13. 클래스와 멤버의 접근 권한은 최소화하라</h3><blockquote><p>잘 구현된 모듈은 내부의 속성, 데이터, 구현 세부 사항을 잘 감추고 API로만 서로 통신한다. 이 개념은 정보 은닉 또는 캡슐화라는 용어로 통용되어 사용된다.</p></blockquote><h3>각 클래스와 멤버는 가능한 한 접근 불가능하도록 만들라.</h3><p>private : 선언된 최상위 레벨 클래스 내부에서만 접근 가능<br>package-private : 같은 패키지 내의 아무 클래스나 사용할 수 있다. 기본 접근 권한(default access)<br>protected : 선언된 클래스 및 그 하위 클래스만 사용할 수 있다. 선언된 클래스와 같은 패키지에 있는 클래스에서도 사용이 가능하다.<br>public : 어디에서도 사용 가능 하다.</p><h4>public static final 배열은 길이가 0이 아닌 이상 언제나 변경 가능 하다.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 보안 문제를 초래할 수 있는 코드</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123; ... &#125;;</span><br></pre></td></tr></table></figure><h4>해결 방법 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES =</span><br><span class="line">     Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br></pre></td></tr></table></figure><h4>해결 방법 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">  <span class="keyword">return</span> PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>어떤 자료형으로 반환해야 클라이언트가 편한가?</h4><h4>어느 쪽이 좀더 나은 성능을 보장할 것인가?</h4><h3>요약</h3><ul><li>접근 권한은 가능한한 낮춘다.</li><li>최소한의 public API를 설계한 다음, 이외 모든 클래스, 인터페이스, 멤버들은 API에서 제외하라.</li><li>public static final 필드를 제외한 어떤 필드도 public 필드로 선언하지 마라.</li><li>public static final 필드가 참조하는 객체는 변경 불가능한 객체로 만들라.</li></ul><blockquote><p>Joshua Bloch, Effective Java 2rd, 이병준, insight(2014), p96</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;이펙티브자바 4장 클래스와 인터페이스 (1)&lt;/h1&gt;
&lt;h3&gt;규칙 13. 클래스와 멤버의 접근 권한은 최소화하라&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;잘 구현된 모듈은 내부의 속성, 데이터, 구현 세부 사항을 잘 감추고 API로만 서로 통신한다
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Interface" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/Interface/"/>
    
    
      <category term="Interface" scheme="http://jungha-cho.github.io/tags/Interface/"/>
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/tags/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
  </entry>
  
  <entry>
    <title>객체 지향 설계 연습하기 - 블랙잭 (3)</title>
    <link href="http://jungha-cho.github.io/2018/03/14/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(3)/"/>
    <id>http://jungha-cho.github.io/2018/03/14/객체지향설계-블랙잭(3)/</id>
    <published>2018-03-14T08:30:00.000Z</published>
    <updated>2018-03-26T13:18:15.032Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 지향 설계 연습하기 - 블랙잭 (1)</h1><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github source code</a></p><h3>0. 들어가며</h3><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h3>1. 리팩토링</h3><ul><li>Card</li><li>Suit와 Denomination의 구현체로 변경</li><li>추상화 개념에서 한개의 카드는 한 개의 무늬와 끗수를 가짐</li><li>체크 메소드를 통해 카드를 확인하는 행동을 구현</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> personal.cjh.BlackJack.card;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.tuple.ImmutablePair;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 카드 클래스</span></span><br><span class="line"><span class="comment"> * 카드 구현체 입니다.</span></span><br><span class="line"><span class="comment"> * 카드는 추상 개념이 아니라 실제 구현된 구현물체라서 클래스로 변경했습니다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Suit suit;</span><br><span class="line">  <span class="keyword">private</span> Denomination denomination;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 새로운 카드를 만들때 호출되는 생성자</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> suit 한벌 중 한개의 모양</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> denomination 끗수</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Card</span><span class="params">(Suit suit, Denomination denomination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.suit = suit;</span><br><span class="line">    <span class="keyword">this</span>.denomination = denomination;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 카드 인스턴스의 모양과 끗수를 리턴</span></span><br><span class="line"><span class="comment">   * 카드를 확인하는 행동을 check 메소드로 추상화</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 변경 불가능한 한쌍으로 리턴합니다.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ImmutablePair&lt;Suit, Denomination&gt; <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImmutablePair&lt;Suit, Denomination&gt;(suit, denomination);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Denomination</li><li>변동 없음</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> personal.cjh.BlackJack.card;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.tuple.ImmutablePair;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 카드 클래스</span></span><br><span class="line"><span class="comment"> * 카드 구현체 입니다.</span></span><br><span class="line"><span class="comment"> * 카드는 추상 개념이 아니라 실제 구현된 구현물체라서 클래스로 변경했습니다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Suit suit;</span><br><span class="line">  <span class="keyword">private</span> Denomination denomination;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 새로운 카드를 만들때 호출되는 생성자</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> suit 한벌 중 한개의 모양</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> denomination 끗수</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Card</span><span class="params">(Suit suit, Denomination denomination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.suit = suit;</span><br><span class="line">    <span class="keyword">this</span>.denomination = denomination;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 카드 인스턴스의 모양과 끗수를 리턴</span></span><br><span class="line"><span class="comment">   * 카드를 확인하는 행동을 check 메소드로 추상화</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 변경 불가능한 한쌍으로 리턴합니다.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ImmutablePair&lt;Suit, Denomination&gt; <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImmutablePair&lt;Suit, Denomination&gt;(suit, denomination);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Suit</li><li>변동 없음</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> personal.cjh.BlackJack.card;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Enumeration Suit.</span></span><br><span class="line"><span class="comment"> * 한벌, 한세트를 뜻함</span></span><br><span class="line"><span class="comment"> * 스페이드, 다이아몬드, 클로버, 하트</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Suit &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * SPADE, DIAMOND, CLOVER, HEART</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  SPADE(<span class="string">"SPADE"</span>), DIAMOND(<span class="string">"DIAMOND"</span>), CLOVER(<span class="string">"CLOVER"</span>), HEART(<span class="string">"HEART"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String Property;</span><br><span class="line"></span><br><span class="line">  Suit(String property) &#123;</span><br><span class="line">    <span class="keyword">this</span>.Property = property;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 속성을 출력합니다.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the property</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Property;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Deck</li><li>덱은 Card의 변경에따라 다소 변경이 있음</li><li>Card 객체를 직접 사용함에 따라 코드가 직관적으로 바뀜</li><li>DrawCard 메소드는 카드 객체를 반환하고, Card를 받은 유저가 check 메소드 호출을 통해 끗수와 무늬를 확인</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> personal.cjh.BlackJack.deck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> personal.cjh.BlackJack.card.Card;</span><br><span class="line"><span class="keyword">import</span> personal.cjh.BlackJack.card.Denomination;</span><br><span class="line"><span class="keyword">import</span> personal.cjh.BlackJack.card.Suit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 덱 클래스 입니다.</span></span><br><span class="line"><span class="comment"> * 덱 또한 여러장의 카드를 모아논 것이기 때문에 클래스를 이용했습니다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Card&gt; deck = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 덱을 생성할때 새로운 카드를 deck list에 넣습니다.</span></span><br><span class="line"><span class="comment">   * 덱은 각각의 덱별로 블랙잭 카드 개수인 52장씩 생성됩니다.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Deck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Suit.values().length; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Denomination.values().length; j++) &#123;</span><br><span class="line">        deck.add(<span class="keyword">new</span> Card(Suit.values()[i], Denomination.values()[j]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 덱에서 카드를 드로우 합니다.</span></span><br><span class="line"><span class="comment">   * 실제로 드로우 하는 주최는 딜러가 될것이며, 유저는 딜러에게 요청만 하게 됩니다.</span></span><br><span class="line"><span class="comment">   * Deck 리스트에서 랜덤으로 하나 출력 후 해당 카드는 삭제 합니다.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 카드 객체로 반환</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Card <span class="title">drawCard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = random.nextInt(deck.size());</span><br><span class="line">    Card card = deck.get(index);</span><br><span class="line">    deck.remove(index);</span><br><span class="line">    <span class="keyword">return</span> card;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 덱 리스트 변수에 접근하기 위한 메소드</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 덱 리스트를 반환합니다</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Card&gt; <span class="title">getDeck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> deck;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>테스트</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> personal.cjh.BlackJack.deck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.CoreMatchers.instanceOf;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.core.Is.is;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.tuple.ImmutablePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.tuple.Pair;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> personal.cjh.BlackJack.card.Card;</span><br><span class="line"><span class="keyword">import</span> personal.cjh.BlackJack.card.Denomination;</span><br><span class="line"><span class="keyword">import</span> personal.cjh.BlackJack.card.Suit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeckTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 인스턴스로_생성된_덱의_유효성_검사() &#123;</span><br><span class="line">    <span class="comment">// GIVEN</span></span><br><span class="line">    Deck deck = <span class="keyword">new</span> Deck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WHEN</span></span><br><span class="line">    <span class="keyword">boolean</span> nullPointCheck = deck == <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> instanceCheck = deck <span class="keyword">instanceof</span> Deck;</span><br><span class="line">    <span class="keyword">boolean</span> deckSizeCheck = deck.getDeck().size() == deck.getDeck().size();</span><br><span class="line"></span><br><span class="line">    deck.drawCard();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// THEN</span></span><br><span class="line">    assertFalse(nullPointCheck);</span><br><span class="line">    assertTrue(instanceCheck);</span><br><span class="line">    assertTrue(deckSizeCheck);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 덱에서_카드를_뽑았을때_덱의_상태변화를_검사한다() &#123;</span><br><span class="line">    <span class="comment">// GIVEN</span></span><br><span class="line">    Deck deck = <span class="keyword">new</span> Deck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WHEN</span></span><br><span class="line">    <span class="keyword">int</span> beforeDeckSize = deck.getDeck().size();</span><br><span class="line">    Card card = deck.drawCard();</span><br><span class="line">    <span class="keyword">int</span> afterDeckSize = deck.getDeck().size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// THEN</span></span><br><span class="line">    assertFalse(beforeDeckSize == afterDeckSize);</span><br><span class="line">    assertTrue(beforeDeckSize == <span class="number">52</span>);</span><br><span class="line">    assertTrue(afterDeckSize == <span class="number">51</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 덱에서_카드를_뽑았을때_카드의_유효성을_검사한다() &#123;</span><br><span class="line">    <span class="comment">// GIVEN</span></span><br><span class="line">    Deck deck = <span class="keyword">new</span> Deck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WHEN</span></span><br><span class="line">    Card card = deck.drawCard();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// THEN</span></span><br><span class="line">    assertTrue(card != <span class="keyword">null</span>);</span><br><span class="line">    assertThat(card, instanceOf(Card.class));</span><br><span class="line">    assertThat(card.check(), instanceOf(ImmutablePair.class));</span><br><span class="line">    assertThat(card.check().left, instanceOf(Suit.class));</span><br><span class="line">    assertThat(card.check().right, instanceOf(Denomination.class));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 덱이_싱글톤인지_검사한다() &#123;</span><br><span class="line">    <span class="comment">// GIVEN</span></span><br><span class="line">    Deck deck = <span class="keyword">new</span> Deck();</span><br><span class="line">    Deck deck2 = <span class="keyword">new</span> Deck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WHEN</span></span><br><span class="line">    <span class="keyword">boolean</span> beforeDrawCheck = (deck.getDeck() == deck.getDeck());</span><br><span class="line">    deck.drawCard();</span><br><span class="line">    <span class="keyword">boolean</span> afterDrawCheck = (deck.getDeck() == deck.getDeck());</span><br><span class="line">    <span class="keyword">boolean</span> isEqual = (deck.getDeck() == deck2.getDeck());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// THEN</span></span><br><span class="line">    assertTrue(beforeDrawCheck);</span><br><span class="line">    assertTrue(afterDrawCheck);</span><br><span class="line">    assertFalse(isEqual);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> getCard_함수를_사용했을때_덱안의_카드가_정상적으로_줄어드는지_검사() &#123;</span><br><span class="line">    <span class="comment">// GIVEN</span></span><br><span class="line">    Deck deck = <span class="keyword">new</span> Deck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WHEN</span></span><br><span class="line">    <span class="keyword">boolean</span> initSizeEqual = (deck.getDeck().size() == <span class="number">52</span>);</span><br><span class="line">    Card card = deck.drawCard();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// THEN</span></span><br><span class="line">    assertThat(card.check().getLeft(), instanceOf(Suit.class));</span><br><span class="line">    assertThat(card.check().getRight(), instanceOf(Denomination.class));</span><br><span class="line">    assertThat(deck.getDeck().size(), is(<span class="number">51</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">51</span>;</span><br><span class="line">    <span class="keyword">while</span> (deck.getDeck().size() != <span class="number">0</span>) &#123;</span><br><span class="line">      Card cd = deck.drawCard();</span><br><span class="line">      printCard(cd.check(), count);</span><br><span class="line">      assertThat(deck.getDeck().size(), is(--count));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCard</span><span class="params">(Pair&lt;Suit, Denomination&gt; card, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">"COUNT : "</span>);</span><br><span class="line">    sb.append(count);</span><br><span class="line">    sb.append(<span class="string">" Suit : "</span>);</span><br><span class="line">    sb.append(card.getLeft());</span><br><span class="line">    sb.append(<span class="string">" Suit Prop : "</span>);</span><br><span class="line">    sb.append(card.getLeft().getProperty());</span><br><span class="line">    sb.append(<span class="string">" Denomination : "</span>);</span><br><span class="line">    sb.append(card.getRight());</span><br><span class="line">    sb.append(<span class="string">" Denomination Prop : "</span>);</span><br><span class="line">    sb.append(card.getRight().getProperty());</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">    sb.setLength(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>마무리</h4><ul><li>카드쪽에서 고민이 많았는데 abstract, interface 대신 Suit와 Denomination을 구현한 클래스를 사용함으로써 전체적인 코드가 직관적으로 바뀜</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 지향 설계 연습하기 - 블랙잭 (1)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/BlackJack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github source code&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/tags/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
  </entry>
  
  <entry>
    <title>객체 지향 설계 연습하기 - 블랙잭 (2)</title>
    <link href="http://jungha-cho.github.io/2018/03/12/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(2)/"/>
    <id>http://jungha-cho.github.io/2018/03/12/객체지향설계-블랙잭(2)/</id>
    <published>2018-03-12T08:15:00.000Z</published>
    <updated>2018-03-26T13:18:17.112Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 지향 설계 연습하기 - 블랙잭 (2)</h1><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github source code</a></p><h3>0. 들어가며</h3><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h3>1. 초기 설계 - 문장으로 나열해 보기</h3><h3>1.0 큰 틀</h3><ul><li>필요한 객체는 게임판, 딜러, 유저, 덱, 게임 규칙</li><li>게임판은 카드가 올려져있는 실제 게임 판을 의미 한다.</li><li>딜러는 카드를 나눠주고 규칙을 적용하고, 돈을 주거나 받는다.</li><li>덱은 카드만 랜덤으로 뽑아 출력 한다.c</li><li>게임 규칙은 딜러가 사용할 수 있고, 유저도 사용 가능하다.</li><li>딜러 규칙, 사용자 규칙 또한 나눠져 있다.</li></ul><h3>1.1 딜러</h3><ul><li>딜러는 유저에게 카드를 준다.</li><li>딜러는 카드덱에 유일하게 접근 가능하다.</li><li>딜러도 카드덱에서 다음장에 나올 카드를 모른다.</li></ul><h3>1.2 유저</h3><ul><li>유저는 딜러에게 카드를 요청한다.</li><li>유저는 각 게임의 턴마다 카드를 요청할 수 있다.</li><li>유저는 각 게임의 턴마다 서랜더를 요청할 수 있다.</li></ul><h3>1.3 큰 틀의 그림</h3><p><img src="/images/BackJack-RealModel.JPG" alt="블랙잭의실제모델"></p><ul><li>규칙은 모두에게 적용되지만, 유저와 딜러는 적용되는 규칙이 다르다.</li><li>덱은 딜러만 가지고 있으며, 유저는 딜러에게 덱을 요청한다.</li><li>블랙잭의 덱은 52장이다.</li></ul><h3>2. Java로 BlackJack Deck을 구현하기</h3><ul><li>Suit</li><li>Suit, 스페이드, 다이아몬드, 클로버, 하트 4가지로 고정되어 있는 값.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> personal.cjh.BlackJack.card;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Enumeration Suit.</span></span><br><span class="line"><span class="comment"> * 한벌, 한세트를 뜻함</span></span><br><span class="line"><span class="comment"> * 스페이드, 다이아몬드, 클로버, 하트</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Suit &#123;</span><br><span class="line">  SPADE(<span class="string">"SPADE"</span>), DIAMOND(<span class="string">"DIAMOND"</span>), CLOVER(<span class="string">"CLOVER"</span>), HEART(<span class="string">"HEART"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String Property;</span><br><span class="line"></span><br><span class="line">  Suit(String property) &#123;</span><br><span class="line">    <span class="keyword">this</span>.Property = property;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Property;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Denomination</li><li>끗수를 뜻함</li><li>스페이드의 모든 끗수를 한벌, 한 세트라고 명함</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> personal.cjh.BlackJack.card;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 끗수 Enum</span></span><br><span class="line"><span class="comment"> * 블랙잭 게임의 끗수, 즉 숫자 1~10, J, Q, K, A를 표시하는 Enumeration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Denomination &#123;</span><br><span class="line">  ACE(<span class="string">"1"</span>), TWO(<span class="string">"2"</span>), THREE(<span class="string">"3"</span>), FOUR(<span class="string">"4"</span>),</span><br><span class="line">  FIVE(<span class="string">"5"</span>), SIX(<span class="string">"6"</span>), SEVEN(<span class="string">"7"</span>), EIGHT(<span class="string">"8"</span>),</span><br><span class="line">  NINE(<span class="string">"9"</span>), TEN(<span class="string">"10"</span>), JACK(<span class="string">"10"</span>), QUEEN(<span class="string">"10"</span>),</span><br><span class="line">  KING(<span class="string">"10"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String Property;</span><br><span class="line"></span><br><span class="line">  Denomination(String property) &#123;</span><br><span class="line">    <span class="keyword">this</span>.Property = property;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Property;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Card</li><li>Suit 한개와 Denomination 끗수 한개를 가지는 한장의 카드</li><li>interface, abstract, class 등등 모든 상황을 고려해 Card를 작성해 보려 했지만 사용자 즉, 이 코드를 사용하는 코더 입장에서 사용하기 불편한 점이 많아, 속성을 줄임</li><li>추상화 측면에서 Card는 Suit 한가지와 Denomination 한가지를 가져야 하지만, 해당 클래스는 없음.</li><li>이부분이 리팩토링 포인트가 될듯</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> personal.cjh.BlackJack.card;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.tuple.ImmutablePair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ImmutablePair&lt;Suit, Denomination&gt; <span class="title">getCard</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Deck</li><li>Suit 4가지는 각각 한세트의 끗수를 가지며 각각의 카드가 모여 52개의 카드를 생성함</li><li>52개의 카드 갯수는 BlackJack 게임 기준</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> personal.cjh.BlackJack.deck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.tuple.ImmutablePair;</span><br><span class="line"><span class="keyword">import</span> personal.cjh.BlackJack.card.Card;</span><br><span class="line"><span class="keyword">import</span> personal.cjh.BlackJack.card.Denomination;</span><br><span class="line"><span class="keyword">import</span> personal.cjh.BlackJack.card.Suit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deck</span> <span class="keyword">extends</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ImmutablePair&lt;Suit, Denomination&gt;&gt; deck = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Deck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Suit.values().length; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Denomination.values().length; j++) &#123;</span><br><span class="line">        ImmutablePair&lt;Suit, Denomination&gt; temp</span><br><span class="line">            = <span class="keyword">new</span> ImmutablePair&lt;&gt;(Suit.values()[i], Denomination.values()[j]);</span><br><span class="line">        deck.add(temp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ImmutablePair&lt;Suit, Denomination&gt; <span class="title">getCard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = random.nextInt(deck.size());</span><br><span class="line">    ImmutablePair&lt;Suit, Denomination&gt; card = deck.get(index);</span><br><span class="line">    deck.remove(index);</span><br><span class="line">    <span class="keyword">return</span> card;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;ImmutablePair&lt;Suit, Denomination&gt;&gt; getDeck() &#123;</span><br><span class="line">    <span class="keyword">return</span> deck;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Test</li><li>이제 최종 딜러가 사용할 Deck 클래스를 테스트 해보자.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> personal.cjh.BlackJack.deck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.CoreMatchers.instanceOf;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.core.Is.is;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.tuple.Pair;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> personal.cjh.BlackJack.card.Denomination;</span><br><span class="line"><span class="keyword">import</span> personal.cjh.BlackJack.card.Suit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeckTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 덱이_싱글톤인지_검사한다() &#123;</span><br><span class="line">    <span class="comment">// 첫번째 덱을 생성한다.</span></span><br><span class="line">    Deck deck = <span class="keyword">new</span> Deck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 첫번째 덱의 getDeck 함수를 써서 받은 덱이 같은 덱인지 확인</span></span><br><span class="line">    assertTrue(deck.getDeck() == deck.getDeck());</span><br><span class="line">    assertFalse(deck == <span class="keyword">null</span>);</span><br><span class="line">    assertTrue(deck <span class="keyword">instanceof</span> Deck);</span><br><span class="line">    assertTrue(deck.getDeck().size() == deck.getDeck().size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 카드를 뽑는다.</span></span><br><span class="line">    deck.getCard();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 카드를 뽑아도 같은 객체인지 검사한다.</span></span><br><span class="line">    assertTrue(deck.getDeck() == deck.getDeck());</span><br><span class="line">    assertFalse(deck == <span class="keyword">null</span>);</span><br><span class="line">    assertTrue(deck <span class="keyword">instanceof</span> Deck);</span><br><span class="line">    assertTrue(deck.getDeck().size() == deck.getDeck().size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 두번째 덱을 만든다.</span></span><br><span class="line">    Deck deck2 = <span class="keyword">new</span> Deck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 두번째 덱의 getDeck 함수를 써서 받은 덱이 같은 덱인지 확인</span></span><br><span class="line">    assertTrue(deck2.getDeck() == deck2.getDeck());</span><br><span class="line">    assertFalse(deck2 == <span class="keyword">null</span>);</span><br><span class="line">    assertTrue(deck2 <span class="keyword">instanceof</span> Deck);</span><br><span class="line">    assertTrue(deck2.getDeck().size() == deck2.getDeck().size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 카드를 뽑는다.</span></span><br><span class="line">    deck2.getCard();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 카드를 뽑아도 같은 객체인지 검사한다.</span></span><br><span class="line">    assertTrue(deck2.getDeck() == deck2.getDeck());</span><br><span class="line">    assertFalse(deck2 == <span class="keyword">null</span>);</span><br><span class="line">    assertTrue(deck2 <span class="keyword">instanceof</span> Deck);</span><br><span class="line">    assertTrue(deck2.getDeck().size() == deck2.getDeck().size());</span><br><span class="line"></span><br><span class="line">    assertFalse(deck.getDeck() == deck2.getDeck());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> getCard_함수를_사용했을때_덱안의_카드가_정상적으로_줄어드는지_검사() &#123;</span><br><span class="line">    Deck deck = <span class="keyword">new</span> Deck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 블랙잭 덱은 최초 52장이다.</span></span><br><span class="line">    assertThat(deck.getDeck().size(), is(<span class="number">52</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 카드 뽑기</span></span><br><span class="line">    Pair&lt;Suit, Denomination&gt; card = deck.getCard();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 뽑은 카드가 각 Enum의 객체가 맞는지 검사</span></span><br><span class="line">    assertThat(card.getLeft(), instanceOf(Suit.class));</span><br><span class="line">    assertThat(card.getRight(), instanceOf(Denomination.class));</span><br><span class="line"></span><br><span class="line">    assertThat(deck.getDeck().size(), is(<span class="number">51</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 순환을 돌면서 정상적으로 DECK 사이즈가 줄어드는지 검사</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">51</span>;</span><br><span class="line">    <span class="keyword">while</span> (deck.getDeck().size() != <span class="number">0</span>) &#123;</span><br><span class="line">      Pair&lt;Suit, Denomination&gt; cd = deck.getCard();</span><br><span class="line">      printCard(cd, count); <span class="comment">// 카드 덱 출력을 보기 위한 함수 출력</span></span><br><span class="line">      assertThat(deck.getDeck().size(), is(--count));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCard</span><span class="params">(Pair&lt;Suit, Denomination&gt; card, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">"COUNT : "</span>);</span><br><span class="line">    sb.append(count);</span><br><span class="line">    sb.append(<span class="string">" Suit : "</span>);</span><br><span class="line">    sb.append(card.getLeft());</span><br><span class="line">    sb.append(<span class="string">" Suit Prop : "</span>);</span><br><span class="line">    sb.append(card.getLeft().getProperty());</span><br><span class="line">    sb.append(<span class="string">" Denomination : "</span>);</span><br><span class="line">    sb.append(card.getRight());</span><br><span class="line">    sb.append(<span class="string">" Denomination Prop : "</span>);</span><br><span class="line">    sb.append(card.getRight().getProperty());</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">    sb.setLength(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>테스트 결과</h3><p><img src="/images/decktestresult.JPG" alt="테스트결과"></p><h3>결론</h3><ul><li>추상화, 인터페이스를 멀리하며 코딩하던 입장으로써, 여러가지 생각을 하며 실제 객체를 코드에 반영하는 일이 어렵다는걸 다시한번 느낌</li><li>썩 마음에 드는 코드는 아님</li><li>Card 클래스는 리팩토링해 조금더 유연하고 추상화 측면에서 만족스런 결과물을 뽑고 싶음</li><li>enum의 유용함을 느낌</li><li>abstract, interface를 사용하는 방법은 알지만 왜, 어떨때 적절히 사용해야 하는지 모르는것을 느낌</li></ul><h1>조금 중구난방에 헤메고 있다………………………</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 지향 설계 연습하기 - 블랙잭 (2)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/BlackJack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github source code&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/tags/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
  </entry>
  
  <entry>
    <title>객체 지향 설계 연습하기 - 블랙잭 (1)</title>
    <link href="http://jungha-cho.github.io/2018/03/12/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD(1)/"/>
    <id>http://jungha-cho.github.io/2018/03/12/객체지향설계-블랙잭(1)/</id>
    <published>2018-03-12T07:09:00.000Z</published>
    <updated>2018-03-26T13:18:19.410Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 지향 설계 연습하기 - 블랙잭 (1)</h1><p><a href="https://github.com/JungHa-Cho/BlackJack" target="_blank" rel="noopener">github source code</a></p><h3>0. 들어가며</h3><ul><li>업무에 Java를 사용하고 있지만, 깊은 이해도가 부족하다는걸 절감.</li><li>단순 객체 생성 및 비즈니스 로직 구현에만 매달리고 있음. 회의감이 듦.</li><li>신규 개발 뿐만 아니라 유지 보수 및 리팩토링시 객체 지향의 묘미를 살려보고자 함</li><li>객체 지향적 시야와 사고는 연습뿐이라는 것을 여러 커뮤니티에서 수집</li><li>객체 지향 설계 연습을 통해 객체 지향적 시야와 이해력을 높이고지 함</li></ul><h3>1. 왜? 블랙잭?</h3><ul><li>여러 커뮤니티에서 추천</li><li>아래 내용은 개인적인 생각</li><li>규칙이 단순, 게임 룰에 따라 게임의 흐름이 단순</li><li>하지만, 플레이어 딜러 카드 등등 연관성이 종속적이라 설계 연습에 주효</li></ul><h2><a href="https://namu.wiki/w/%EB%B8%94%EB%9E%99%EC%9E%AD(%EC%B9%B4%EB%93%9C%EA%B2%8C%EC%9E%84)" target="_blank" rel="noopener">나무위키 참조</a></h2><h3>2. 블랙잭 게임 룰</h3><h4>2.1 룰의 배경</h4><ul><li><p>무늬 SPADE, CLOVER, HEART, DIAMOND</p></li><li><p>숫자 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, K, Q, J, A</p></li><li><p>K, Q, J는 10점, A는 1 혹은 11, 둘 중 어느쪽으로 계산될 수 있다. ( 카지노 마다 룰이 다르다.)</p></li><li><p>참여 인원은 2~8명, 2~8명 중 딜러를 정하거나 임의 딜러를 투입</p></li><li><p>배팅 배당률은 배팅한 만큼 받는게 기본. 100원을 배팅해 이기면 200원을 얻고 지면 100원을 잃는다.</p></li><li><p>딜러의 첫 번째 카드를 엎어 놓은 것 이외에는 모든 참가자의 카드가 공개된다.</p></li></ul><h4>2.2 기본 룰</h4><ul><li>카드에 써있는 숫자 그대로 숫자를 더해 21을 만들면 된다.</li><li>첫 시작시 카드 두장을 지급 받는다.</li><li>처음 받은 두장이 21이 될 경우 __블랙잭__이라고 하며 보통 베팅액의 2배1.5배를 얻는다.</li><li>딜러가 블랙잭인 경우에는 참가자가 베팅한 돈의 전부를 받는다.</li><li>딜러와 참가자가 동시에 블랙잭인 경우에 참가자는 대개 베팅한 돈을 돌려받지만, 잃게 되는 경우도 있다.</li><li>21이 되지 않을 경우 얼마든지 카드를 뽑을 수 있다.</li><li>21 초과 ( 22 이상 )이 될 경우 __버스트__라고 하며, 딜러의 결과에 상관 없이 무조건 돈을 잃는다.</li><li>카드를 더 받지 않는 것이 유리하다고 판단되면 추가하지 않아도 된다. 예를 들면, Q와 9을 받아 19점인 경우에 1장을 더 추가하면 21점을 초과할 염려가 있기 때문에 그 상태에서 카드를 더 받지 않고 그칠 수 있다.</li><li>딜러는 참가자들의 추가가 모두 끝난 뒤에 자신이 카드를 추가할 것인지 여부를 결정한다.</li><li>정식 규칙에서 딜러는 가진 카드의 합계가 16점 이하이면 반드시 1장을 추가해야 하고, 17점 이상이면 추가할 수 없게 되어 있다.</li><li>딜러의 점수와 비교해서 동점이면 무승부, 딜러보다 높으면 이기고 낮으면 지게 된다.</li><li>합계가 21점을 초과하면 0점으로 간주되는데, 딜러가 21점을 초과한 경우도 0점이 되지만, 21점을 초과한 참가자의 베팅액을 딸 수 있다.</li></ul><h4>2.3 게임의 흐름</h4><ul><li>배팅 금액을 정한다.</li><li>딜러를 정해야 하며, 딜러는 딜러 기준 왼쪽으로 1장씩 2번을 돌려 각자 2장씩 가지게 한다.</li><li>딜러의 첫번째 카드 외 모든 유저의 카드는 오픈한다.</li><li>각자 판단 하에 카드를 요구한다.</li></ul><h4>2.4 게임 내 규칙</h4><p><strong>Hit - 히트</strong></p><ul><li>처음 2장의 카드 상태에서 카드를 더 뽑는 것을 __HIT__라고 한다.</li><li>제스쳐로는 검지 손가락으로 테이블을 톡 내려주면 된다.</li><li>21이 되지 않는 한 얼마든지 카드를 뽑을 수 있다.</li><li>21이 넘으면 무조건 진다.</li><li>카드 숫자 합이 17이 되지 않으면 무조건 카드를 뽑아야 하는데, 해당 규칙은 딜러에게도 해당한다.</li><li>따라서 딜러가 17이 되기 전까지는 무조건 카드를 받아야 한다.</li><li>내가 이기지 않아도, 딜러가 지면 이긴다.</li></ul><p><strong>stand, stay - 스탠드, 스테이</strong></p><ul><li>카드를 뽑지 않고 턴을 종료한다.</li><li>제스쳐는 손등을 위로 보이게 한뒤, 테이블을 한번 훝는다.</li></ul><p><strong>split - 스플릿</strong></p><ul><li>처음 받은 2장의 카드가 같은 숫자 또는 같은 그림일 경우, 패를 두개로 나누어 두개의 게임을 동시에 진행할수 있다.</li><li>이후 또 똑같은 숫자가 나오면 똑같이 계속 스플릿을 진행할 수 있다.</li><li>제스처로는 검지와 중지를 테이블에 향하여 친후 손가락을 떼면서 패를 나누는 듯한 제스쳐. 블랙잭용어는 기본적으로 딜러들이 다 알기때문에 ‘스플릿’ 이라고 말만해도 다 알아먹는다. 그러면 딜러가 확인차 자기 손가락으로 스플릿제스쳐를 취하면 맞다고 고개한번 끄덕거려주면 만사오케이. 그리고 애초에 스플릿이 아무때나 되는게 아니고 대부분 (8,8), (9,9) (A.A) 에만 하기때문에.</li><li>블랙잭은 기본이 카드를 두장 받는것이므로 각각 한장씩 더 받게 된다.스플릿은 A를 제외하고는 3번까지 가능하다.(즉 4개의 게임으로 나누는것까지 가능하다.) (A같은경우는 카지노마다 룰이 다르다.)</li><li>참고로 에이스를 스플릿해서 A,10이 나왔어도 블랙잭처럼 1.5배를 주는것은 아니고 그냥 21로 계산해서 1배만 준다. 다만, 딜러가 블랙잭이 나온경우 플레이어는 패하게되고, 딜러의 숫자합이 블랙잭이 아닌 21일경우 무승부로 인정되어 베팅금액을 다시 돌려준다.</li></ul><p><strong>Double Down - 더블 다운</strong></p><ul><li>돈을 두 배로 거는 것.</li><li>제스쳐로는 베팅금을 더 걸면서 검지와 중지 손가락 두개를 테이블을 향하여 톡 친다.</li><li>본래 합이 21이 넘지 않는 한 무제한으로 뽑을 수 있는 카드를 이후 단 하나만 더받는 조건으로 돈을 두 배로 걸 수 있다.</li><li>따라서 일반적으로 두 장을 합쳐서 한 10이나 11일 경우에 더블다운을 하는 시나리오가 일반적으로 제일 좋다.</li><li>좀더 확률상 높이자면 딜러가 버스트할 확률이 높은 상황 + 내 패가 10,11 정도면 더블을 성공할 확률이 매우 높아진다(확률상 숫자 10에 해당하는 10,J,Q,K가 나올 확률이 제일 높기 때문이고 설사 이 녀석들이 나오지 않는다 해도 딜러가 버스트 할 확률이 높기 때문이다).</li></ul><p><strong>bust - 버스트</strong></p><ul><li>카드 총합이 21을 넘는 경우.</li><li>플레이어가 버스트 당하면 경기 흐름에 상관없이 바로 배당금을 잃는다.</li><li>즉 12에서 10을 뽑아 22가 되는 사고로도 버스트 되어 패배한다.</li><li>이는 플레이어 뿐만 아니라 딜러에게도 해당되기 때문에 플레이어가 꼬인 패를 갖고 있다고 해서 그 판에 대해 아예 손을 놓을 수 없게 만드는 규칙이기도 하다.</li><li>특히 딜러는 매장 내에서 정한 ‘언더 오버’ 수치로 인해 언더 아래의 숫자인 패일 경우 반드시 뽑아야하기 때문에 살아있는 다른 플레이어들이 카드를 넘기는 순간에는 땀을 쥐게 된다.</li><li>딜러가 버스트 당하면 그 시점까지 살아있던 다른 플레이어들은 갖고 있는 패에 상관 없이 승리하기에 이미 죽은 플레이어는 자신의 머리를 잡는다.</li></ul><p><strong>black jack</strong></p><ul><li>게임내 가장 높은 가치.</li><li>Ace 한장과 10에 해당하는 패(10,J,Q,K)로 21을 이루는 경우 베팅금액의 1.5배를 돌려준다.</li><li>원래 이기는 룰대로 두배로 이기는 경우도 있다.</li><li>딜러도 블랙잭이 아닌 이상 무조건적인 승리.</li><li>Ace혹은 10에 해당하는 패를 스플릿 해서 진행한 경우 A + 10의 조합이 나오더라도 블랙잭으로 인정하지 않고 21로 계산한다.</li><li>에이텐은 플레이어에게 이로운 규칙이라서 카지노 측에서 적용시키기 꺼려하는 규칙이라고 하나, 일부에서는 그대로 적용해주는 곳도 있다고 한다.</li></ul><h4>2.5 추가 규칙</h4><p><strong>인셔런스(Insurance)</strong></p><ul><li>딜러가 오픈한 첫 카드가 에이스일 경우, 블랙잭이 나올 가능성에 대비해 보험을 들어두는 것을 말한다.</li><li>건 금액의 절반(절반은 상한일뿐이고 절반이하를 지불하는것도 가능하다.)을 인셔런스로 지불하게 되며 만약 딜러가 블랙잭일 경우 보험금의 2배를 보험수당으로 지불한다.</li><li>물론 기존의 베팅금은 딜러가 가져가게되므로 인셔런스 성공시 본전회수가 된다.</li><li>베팅금이 100원일경우 보험금은 50원해서 총 150원을 소모하게 되며, 베팅금 100원은 잃고 보험금 50원은 승리해 50원의 2배인 100원을 벌면 총 150원으로 처음과 동일한 본전치기가 된다.</li><li>만약 딜러가 블랙잭이 아닐 경우엔 보험으로 걸어둔 금액을 잃게 된다.</li><li>내 패가 19,20일 경우라면 보험금은 잃더라도 게임에는 승리할 확률이 무척 높으니 이경우에만 걸어볼만하다. 내가 19,20 이 아닐 경우에 인셔런스를 건다면, 내 패도 잃고 인셔런스도 잃는 경우가 매우 많다.</li><li>내 패가 19,20이 아닌 경우에는 깔끔하게 판돈만 잃을 생각으로 인셔런스를 걸지 않도록 하자.</li></ul><p><strong>푸시(Push)</strong></p><ul><li>특수적으로 넣는 경우가 있다.</li><li>원래 동점일경우 플레이어가 이기지만, 카지노측의 확률을 높이기 위함이다.</li><li>딜러와 플레이어의 총합이 같을 경우 베팅금을 그대로 다시 돌려받는다.</li><li>하지만, 블랙잭은 총합 21과는 다른 개념으로 블랙잭이 21보다 높은 가치이다.</li><li>애초에 딜러가 블랙잭이면 내가 블랙잭이 아닌이상 지기때문에 카드를 더 받아서 21을 만들어 볼 수도 없다 딜러가 플레이어들로부터 원금을 걷어갈때 푸시인 경우 딜러가 손마디로 테이블을 1~2회 두드리면서 푸시임을 플레이어에게 상기시켜준다.</li></ul><p><strong>이븐 머니(Even Money)</strong></p><ul><li><p>플레이어가 블랙잭이 나오고, 딜러의 보여진 패가 Ace인경우 딜러가 블랙잭이 나온 플레이어에게 이븐머니를 물어본다.</p></li><li><p>베팅한 금액과 동일한 금액을 승리수당으로 받고 게임을 종료할 것인지, 아니면 블랙잭의 효과(1.5배)를 그대로 유지하면서 게임을 계속 진행할 것인지에 대해 선택을 하는 것.</p></li><li><p>이븐머니를 선택할 경우 딜러의 블랙잭 여부와 상관없이 바로 1배의 승리수당을 받고.</p></li><li><p>해당플레이어의 게임을 종료, 이븐머니를 선택하지 않을 경우 계속해서 게임을 진행한다.</p></li><li><p>게임을 진행한 후 딜러가 블랙잭일경우 Push로 그냥 비겨버리고, 딜러가 블랙잭이 아닌 경우에는 일반적인 블랙잭처럼 1.5배의 수당을 받는다.</p></li><li><p>그런데 말로는 ‘이븐머니’ 라고 거창하지만 실상을 들여다보면 이븐머니를 선택하는것은 인셔런스를 택하는것과 다를바가없다. 쉬운 이해를 위해 내가 1000원을 걸어서 블랙잭이 나왔는데 인슈어런스를 선택하는상황을 가정해보자.</p></li><li><p>상황1. 인슈어런스하지않고 이븐머니를 결정한경우 - 이븐머니로 1000원을 받아서 1000원이 이익이다.</p></li><li><p>상황2. 인슈어런스했는데 딜러가 블랙잭인경우 - 인슈어런스로 1500원을받는데 여기서 500원은 내가 인슈어런스걸었던금액이므로 1000원이 이익이다.</p></li><li><p>상황3. 인슈어런스했는데 딜러가 블랙잭이 아닌경우 - 블랙잭(1.5배)으로 1500원을 따지만 인슈어런스로 지불한 500원은 딜러에게회수되므로 1000원이 이익이다.</p></li><li><p>결국 이븐머니를 택하는것은 인슈어런스를 고르는것과 다를바가없다. 다만 일반적인 인슈어런스는 많이 선택하지않는데비해 이븐머니는 선택률이 꽤나높다.</p></li><li><p>왜냐면 블랙잭나왔는데 한푼도 못따면(이븐머니안했는데 딜러도 블랙잭나와서 비기면) 기분 잡치니까…</p></li><li><p>하나의 예를 들면 안전한 1000원 vs 불안정하지만 0원이랑 1500원 중 골라잡는 쫄깃한 선택지다.</p></li></ul><p><strong>서렌더(Surrender)</strong></p><ul><li>플레이어가 게임을 포기하고, 베팅액의 절반을 돌려 받는 규칙이다. '다이’를 쳐도 조금이나마 돌려받을 수 있는 규칙이나, 딜러가 블랙잭을 터뜨렸을 경우 선언권이 막혀 그대로 패배한다.</li></ul><h1></h1><h4>2.6 딜러 규칙</h4><p>딜러는 플레이어의 패를 보고 히트할지 스테이할지를 결정하는 것이 아니라, 단순한 규칙에 따라 플레이 한다. 딜러가 기계적으로 플레이하게 만들어, 딜러의 주관적인 개입을 막는 것이 목적이다.</p><ul><li><p>16 이하면 무조건 히트, 17 이상이면 무조건 스테이</p></li><li><p>플레이어가 15에서 스테이했고, 딜러는 16일때, 딜러가 스테이하면 플레이어를 이길 수 있다. 하지만, 딜러는 의무적으로 버스트의 위험을 감수하고 무조건 히트해야 한다.</p></li><li><p>플레이어가 18에서 스테이했고, 딜러는 17일때, 딜러가 히트를 해서 A~4 의 카드가 나오면 비기거나 이길 수 있다. 하지만, 딜러는 히트할 수 없고, 스테이해야 한다.</p></li><li><p>당연하지만, 딜러는 스플릿, 더블다운, 서렌더, 인셔런스 등을 할 수 없다. 이것들은 플레이어를 위한 규칙이다.</p></li><li><p>딜러는 버스트 되지 않는 한, A 는 11로 카운트 한다. 예를 들어 A-6 이라면 17이 되며, 딜러 규칙에 의해서 무조건 스테이한다는 것을 의미한다.</p></li><li><p>단, 일부 카지노에서는 딜러가 소프트 17, 즉 A-6의 경우에도 히트하는 경우도 있다. 이를 Hit soft 17, 혹은 줄여서 h17 이라고 한다. 플레이 하기전 알아볼 것. [11]</p></li></ul><h1></h1><h4>2.7 기타 규칙</h4><p>실전에서는 보통 사용되지 않는 규칙들이며, 친선 게임이나 비디오게임 등에서 사용되는 규칙들이다. 비디오게임에서는 보통 아래와 같은 패에서는 더 높은 배당을 지급한다. 그냥 재미로 알아 두면 좋다.</p><p><strong>원아이드잭(One-eyed jack)</strong></p><ul><li>플레잉 카드를 잘 보면 스페이드J 와 하트J 는 얼굴이 옆면으로 되어 있어서 눈이 한쪽만 보인다.</li><li>그래서, 이 2장의 카드를 원아이드잭이라 부른다.</li><li>원아이드잭과 같은 무늬의 A 가 조합된 블랙잭은 더 등급이 높은 블랙잭으로 취급한다.</li></ul><p><strong>777</strong></p><ul><li>7 세장으로 21을 만드는 경우, 블랙잭과 동등 또는 그 이상의 등급으로 인정한다.슬롯머신에서 777 이 나오면 잭팟! 인생역전</li></ul><p><strong>파이브 카드 찰리(Five card Charlie)</strong></p><ul><li>3장을 히트해서 패가 5장이 되는 것을 의미하며, 버스트가 되지 않아야 한다.</li><li>이때 적용되는 규칙은 여러가지가 있는데, 어떤 것이든 플레이어에게 유리하다. 호주의 멜버른에 있는 '크라운 카지노’에서는 이 룰이 적용된다.</li><li>아래 n-카드 찰리 규칙 규칙 참고.</li></ul><p><strong>식스 카드 찰리(Six card Charlie)</strong></p><ul><li>4장을 히트해서 패가 6장이 되는 것을 의미하며, 역시 버스트가 되지 않아야 한다.</li><li>파이브카드 찰리는 그나마 자주 나오기에, 좀더 조건을 강화해서 6장을 기준으로 하는 경우이다.</li></ul><p><strong>n-카드 찰리 규칙</strong></p><ul><li><p>플레이어가 5장(or 6장)을 만들고, 딜러가 블랙잭이 아니라면 딜러의 패와 상관없이 플레이어가 이긴다. 단, 딜러가 블랙잭일 경우는 딜러가 승리한다.</p></li><li><p>반대로, 딜러가 5장(or 6장)이 되는 경우, 무조건 플레이어가 승리한다. 단, 버스트된 플레이어는 제외된다. 즉, 딜러 버스트와 동일하다.[13]</p></li><li><p>일부 비디오게임에서는 플레이어가 5장 이상일 경우, 카드 수에 따라 2배씩 계속 배당이 증가하기도 한다.</p></li><li><p>단 5장이면 2배, 6장이면 4배, 7장이면 8배의 배당을 지급한다. [14] 단, 이 경우는 무조건 승리하는 것은 아니며, 숫자합으로 딜러를 이겨야 한다. 딜러가 블랙잭이면 말짱 꽝</p></li></ul><p><strong>딜러 무제한 스테이 규칙</strong></p><ul><li>딜러는 자신의 숫자의 합이 플레이어보다 유리하면 언제든지 스테이할 수 있는 사기적인 규칙[15]. 일부 비디오게임에 적용되어 있다.</li></ul><h1></h1><p>끝으로 마지막 할말</p><p>나무 위키를 보며, 규칙을 익혔지만 생각보다 적용되는 룰이 많고 복잡하다…</p><p>본 문서는 <a href="https://namu.wiki/w/%EB%B8%94%EB%9E%99%EC%9E%AD(%EC%B9%B4%EB%93%9C%EA%B2%8C%EC%9E%84)" target="_blank" rel="noopener">나무 위키</a>의 블랙잭 자료가 출처임을 밝힙니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 지향 설계 연습하기 - 블랙잭 (1)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JungHa-Cho/BlackJack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github source code&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="OOP" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/"/>
    
      <category term="연습" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/OOP/%EC%97%B0%EC%8A%B5/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
    
      <category term="객체 지향 설계" scheme="http://jungha-cho.github.io/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84/"/>
    
      <category term="블랙잭" scheme="http://jungha-cho.github.io/tags/%EB%B8%94%EB%9E%99%EC%9E%AD/"/>
    
  </entry>
  
  <entry>
    <title>자바병렬프로그래밍-Chapter06-6.2.3-스레드풀</title>
    <link href="http://jungha-cho.github.io/2017/05/15/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Chapter06-6-2-3-%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80/"/>
    <id>http://jungha-cho.github.io/2017/05/15/자바병렬프로그래밍-Chapter06-6-2-3-스레드풀/</id>
    <published>2017-05-15T11:23:53.000Z</published>
    <updated>2018-03-26T07:56:43.823Z</updated>
    
    <content type="html"><![CDATA[<h1>Chapter 6 작업 실행</h1><h2>6.2.3 스레드 풀</h2><ul><li><code>스레드 풀 thread pool</code>은 작업을 처리할 수 있는 동일한 형태의 스레드를 <code>풀 pool</code>의 형태로 관리한다.</li><li>일반적으로 스레드 풀은 풀 내부의 스레드로 처리할 작업을 쌓아둬야 하기 때문에 <code>작업 큐 work queue</code>와 굉장히 밀접한 관련이 있다.</li><li>작업 스레드는 작업 큐에서 실행할 다음 작업을 가져오고, 작업을 실행하고, 가져와 실행할 다음 작업이 나타날 때까지 대기하는 일을 반복한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">풀 내부의 스레드를 사용해 작업을 실행하는 방법의 장점    </span><br><span class="line">* 매번 스레드를 생성하는 대신 재사용하기 떄문에 스레드를 계속해서 생성할 필요가 없다.</span><br><span class="line">* 여러 개의 요청을 처리하는데 필요한 시스템 자원이 줄어드는 효과가 있다.</span><br><span class="line">* 요청을 처리할 스레드가 이미 만들어진 상태로 대기하고 있기 떄문에 반응속도가 향상된다.</span><br><span class="line">* 스레드 풀의 크기를 적절히 조절해 두면 하드웨어 프로세서가 쉬지 않고 동작하도록 할 수 있다.</span><br><span class="line">* 하드웨어 프로세서가 동작중에 메모리를 전부 소모하거나, 서로 경쟁하느라 성능을 잠식하는 현상도 없다.</span><br></pre></td></tr></table></figure><hr><p>미리 정의된 스레드 풀은 다음과 같다.</p><p><code>newFixedThreadPool</code> : 처리할 작업이 등록되면 그에 따라 실제 작업할 스레드를 하나씩 생성한다. 생성할 수 있는 스레드의 최대 개수는 제한되어 있으며 제한된 개수까지 스레드를 생성하고 나면 더 이상 생성하지 않고 스레드 수를 유지한다.<br><code>newCachedThreadPool</code> : 캐시 스레드 풀은 현재 풀에 갖고 있는 스레드의 수가 처리할 작업의 수보다 많아서 쉬는 스레드가 많이 발생할 때 쉬는 스레드를 종료시켜 훨씬 유연하게 대응할 수 있으며, 처리할 작업의 수가 많아지면 필요한 만큼 스레드를 새로 생성한다. 반면에 스레드의 수는 제한을 두지 않는다.<br><code>newSingleThreadExecutor</code> : 단일 스레드로 동작하는 Executor로서 작업을 처리하는 스레드가 단 하나뿐이다. 만약 작업 중에 Exception이 발생해 비정상적으로 종료되면 새로운 스레드를 하나 생성해 나머지 작업을 실행한다. 등록된 작업은 설정된 큐에서 지정하는 <code>순서 (FIFO, LIFO, 우선순의)</code>에 따라 반드시 순차적으로 처리된다.<br><code>newScheduledThreadPool</code> : 일정 시간 이후에 실행하거나 주기적으로 작업을 실행할 수 있으며, 스레드의 수가 고정되어 있는 형태의 Executor.Timer 클래스의 기능과 유사하다.</p><p><code>newFixedThreadPool</code>과 <code>newCachedThreadPool</code> 팩토리 메소드는 일반화된 형태로 구현되어 있는 <code>ThreadPoolExecutor</code> 클래스의 인스턴스를 생성한다. 생성된 ThreadPoolExecutor 인스턴스에 설정 값을 조절해 필요한 형태를 갖추고 사용할 수도 있다.</p><ul><li>Executor는 execute 메소드로 등록해 두면 Executor 내부의 큐에 쌓이고, Executor 내부의 풀에 있는 스레드가 큐에 쌓여있는 작업을 하나씩 뽑아내 처리한다.</li><li>이처럼 작업별로 스레드를 생성 하는 전략 <code>thread-per-task</code>에서 풀을 기반으로 하는 전략 <code>pool-based</code>로 변경하면 안정성 측면에서 엄청난 단점을 얻을 수 있다.</li><li>바로 서버에 부하가 걸리더라도 더 이상 메모리가 부족해 죽는 일이 발생하지 않는다는 점이다.</li><li>부하에 따라 수천 개의 스레드를 생성해 제한된 양의 CPU와 메모리 자원을 서로 사용하려고 경쟁시키는 상황에 이르지 않기 때문에 성능이 떨어질 때도 점진적으로 서서히 떨어지는 특징을 갖는다.</li><li>또한 Executor를 사용하지 않을때 보다 성능을 튜닝하거나, 실행 과정을 관리하거나, 실행 상태를 모니터링 하거나, 실행 기록을 로그로 남기거나, 오류가 발생했을 때 처리하고자 할 때 여러 가지 방법을 동원해 쉽고 효과적으로 처리하기가 좋다.</li></ul><hr><h2>6.2.4 Executor 동작 주기</h2><ul><li>Executor를 구현하는 클래스는 대부분 작업을 처리하기 위한 스레드를 생성하도록 되어 있다.</li><li>JVM은 모든 스레드가 종료되기 전에는 종료하지 않고 대기하기 때문에 Executor를 제대로 종료시키지 않으면 JVM 자체가 종료되지 않고 대기하기도 한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executor는 작업을 비동기적으로 실행하기 때문에 앞서 실행시켰던 작업의 상태를 특정 시점에 정확하게 파악하기 어렵다.</span><br><span class="line">* 어떤 작업은 이미 완료됐을 수도 있다.</span><br><span class="line">* 몇 개의 작업은 아직 실행 중일 수 있다.</span><br><span class="line">* 다른 작업은 아직 큐에서 대기 상태에 머물러 있을 수도 있다.</span><br></pre></td></tr></table></figure><ul><li>따라서 종료 과정은 안전한 종료 방법 <code>gracefull</code> : 작업을 새로 등록하지는 못하고 시작된 모든 작업을 끝낼 때까지 기다림</li><li>강제적인 종료 방법 <code>abrupt</code> : 예를 들어 플러그가 빠져 전원이 꺼지는 경우가 있다.</li><li>물론 안전한 종료와 강제적인 종료 사이에 위치시킬 수 있는 여러가지 종료 방법이 있다.</li><li>Executor가 스레드 풀 서비스를 이용해 서비스를 제공한다는 측면에서는 안전한 방법이든 강제적인 종료 방법이든 종료 절차를 밟아야 할 필요가 있다.</li><li>또 종료 절차를 밟는 동안 실행 중이거나 대기 중이던 작업을 어떻게 처리했는지를 작업을 맡겼던 애플리케이션에게 알려줄 의무가 있다.</li><li>ExecutorService 인터페이스에는 동작 주기를 관리할 수 있는 여러 가지 메소드가 추가되어 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="comment">// .... 작업을 등록할 수 있는 몇 가지 추가 메소드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService는 세 가지 동작 주기를 가지고 있다.</span><br><span class="line">`실행 중 running` : ExecutorService를 처음 실행하면 running 상태로 동작한다.</span><br><span class="line">`종료 중 shutting down` : shutdown 메소드를 호출하면 안전한 종료 절차를 진행하며 종료 중 상태로 들어간다.</span><br><span class="line">                          이 상태에서는 새로운 작업을 등록받지 않으며, 이전에 등록되어 있던 작업까지는 모두 끝마칠 수 있다.</span><br><span class="line">`종료 terminated` : shutdownNow 메소드를 호출하면 강제 종료 절차를 진행한다. 현재 진행 중인 작업도 가능한 취소시키고, 실행되지 않고 대기중이던 작업은 더 이상 실행시키지 않는다.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleWebServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (!exec.isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Socket conn = socket.accept();</span><br><span class="line">                exec.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        handleRequest(conn);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!exec.isShutdown())</span><br><span class="line">                    log(<span class="string">"task submission rejected"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg, Exception e)</span> </span>&#123;</span><br><span class="line">        Logger.getAnonymousLogger().log(Level.WARNING, msg, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket connection)</span> </span>&#123;</span><br><span class="line">        Request req = readRequest(connection);</span><br><span class="line">        <span class="keyword">if</span> (isShutdownRequest(req))</span><br><span class="line">            stop();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dispatchRequest(req);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Request <span class="title">readRequest</span><span class="params">(Socket s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchRequest</span><span class="params">(Request r)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isShutdownRequest</span><span class="params">(Request r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LifecycleWebServer는 두 가지 방법으로 종료시킬 수 있다.</li><li>stop 메소드를 호출하거나 클라이언트 측에서 특정한 형태의 HTTP 요청을 전송 할때 종료 된다.</li></ul><hr><h2>6.2.5 지연 작업, 주기적 작업</h2><ul><li>Timer 클래스를 사용하면 특정 시간 이후에 원하는 작업을 실행하는 지연 작업이나 주기적인 작업을 실행할 수 있다.</li><li>하지만 Timer 클래스는 그 자체로 약간의 단점이 있기 때문에 가능하다면 ScheduledThreadPoolExecutor를 사용하는 방법을 이용하자.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Timer 클래스의 단점</span><br><span class="line">* Timer에 등록된 작업이 너무 오래 실행되면 등록된 다른 TimerTask 작업이 예정된 시각에 실행되지 못할 가능성이 있다.</span><br><span class="line">* TimerTask가 동작 하던 중 예상치 못한 Exception을 던지는 경우 예측하지 못한 상태로 넘어갈 수 있다.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfTime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> ThrowTask(), <span class="number">1</span>);</span><br><span class="line">        SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> ThrowTask(), <span class="number">1</span>);</span><br><span class="line">        SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>OutOfTime 클래스는 Timer 클래스가 내부적으로 어떻게 꼬일 수 있는지를 보여주고, 혼란은 또 다른 혼란을 낳는다는 말처럼 한 번 문제가 발생하면 작업을 등록하려는 애플리케이션에서 어떤 문제가 발생하는지 보여준다.</li><li>프로그램 코드만 보자면 6초 동안 실행되다가 종료될 것이라고 예상할 수 있겠지만, 실제로는 1초만 실행되다가 <code>Timer aleady cancelled</code>라는 메세지의 IllegalStateException을 띄우면서 바로 종료된다.</li><li>ScheduledThreadPoolExcutor는 이와 같이 오류가 발생하는 경우를 훨씬 안정적으로 처리해 주기 때문에 자바 5.0 이후에는 일부러 Timer 클래스를 사용할 필요가 없다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* BlockingQueue를 구현하면서 ScheduledThreadPoolExecutor와 비슷한 기능을 제공하는 DelayQueue 클래스를 사용하자.</span><br><span class="line">* DelayQueue는 큐 내부에 여러개의 Delayed 객체로 작업을 관리하며, 각각의 Delayed 객체는 저마다의 시간을 가지고 있다.</span><br><span class="line">* DelayQueue를 사용하면 Delayed 내부의 시간이 만료된 객체만 take 메소드로 가져갈 수 있다.</span><br><span class="line">* DelayQueue에서 뽑아내는 객체는 객체마다 저장되어 있던 시각 순서대로 정렬되어 뽑아진다.</span><br></pre></td></tr></table></figure><hr><h1>6.3 병렬로 처리할 만한 작업</h1><ul><li>Executor 프레임워크는 실행 정책은 쉽게 지정할 수 있지만, Executor를 사용하려면 실행하려는 작업을 항상 Runnable 인터페이스에 맞춰 구현해야 한다.</li><li>서버 애플리케이션에서 클라이언트의 요청 한 건을 처리하는 과정에서 병렬화해 처리하는 모습을 볼 수 있다.</li><li>특히 데이터베이스 서버 같은 경우에 이런 기법을 많이 사용한다.</li><li>다음 절에서 여러 가지 방법을 사용해 다양한 수준에서 병렬로 동작하는 몇 가지 버전의 컴포넌트를 만들어 보자</li></ul><hr><h2>6.3.1 예제: 순차적인 페이지 렌더링</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadRenderer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        renderText(source);</span><br><span class="line">        List&lt;ImageData&gt; imageData = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ImageInfo imageInfo : scanForImageInfo(source))</span><br><span class="line">            imageData.add(imageInfo.downloadImage());</span><br><span class="line">        <span class="keyword">for</span> (ImageData data : imageData)</span><br><span class="line">            renderImage(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>페이지 내용을 순차적으로 렌더링</li></ul><hr><h2>6.3.2 결과가 나올 때까지 대기: Callable과 Future</h2><ul><li>Executor 프레임워크는 작업을 표현하는 방법으로 Runnable 인터페이스를 사용한다.</li><li>run 메소드는 실행이 끝난 다음 뭔가 결과 값을 리턴해 줄 수 없다.</li><li>예외가 발생할 수 있다고 throws 구문으로 표현할 수도 없다.</li><li>만약 결과 값을 만들어 냈다면 어딘가 공유된 저장소에 저장해야 한다.</li><li>오류가 발생 했다면 로그 파일에 오류 내용을 기록하는 정도가 일반적인 처리 방법이다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">결과를 받아올 때까지 시간이 걸리는 작업이 꽤나 많다.</span><br><span class="line">* 데이터베이스에 쿼리를 보내 결과를 받는 경우도 그렇다.</span><br><span class="line">* 네트웍상의 데이터를 받아오는 경우도 그렇다.</span><br><span class="line">* 물론 아주 복잡한 계산을 하는 경우에도 그렇다.</span><br><span class="line"></span><br><span class="line">이처럼 결과를 얻는 데 시간이 걸리는 기능은 Runnable 대신 Callable을 사용하는 것이 모양새가 좋다.   </span><br><span class="line">Callable 인터페이스에서는 핵심 메소드인 call을 실행하고 나면 결과 값을 돌려받을 수 있으며, Exception도 발생시킬 수 있다. Executor에는 Callable 뿐만 아니라 Runnable이나 java.security.PrivilegedAction 등 여러 가지 유형의 작업을 실행 할 수 있는 기능이 들어 있다.</span><br></pre></td></tr></table></figure><p><code>Runnable과 Callable은 둘 다 어떤 작업을 추상화하기 위한 도구이다.</code></p><ul><li><p>작업은 일반적으로 유한한 성격을 갖고 있다.</p></li><li><p>시작하는 지점이 명확하고, 언젠가는 작업이 끝나게 되어 있다.</p></li><li><p>Executor에서 실행한 작업은 <code>생성 created</code>, <code>등록 submitted</code>, <code>실행 started</code>, <code>종료 completed</code>와 같은 네 가지의 상태를 통과한다.</p></li><li><p>작업은 상당한 시간 동안 실행됨으로 작업을 중간에 취소할 수 있는 기능이 있어야 한다.</p></li><li><p>Executor 프레임워크에 먼저 등록 됐지만 시작되지 않은 작업은 언제든지 실행하지 않도록 취소시킬 수 있어야 한다.</p></li><li><p>이미 시작한 작업은 그 내부 구조가 인터럽트를 처리하도록 잘 만들어져 있는 경우에 한해 취소시킬 수 있다.</p></li><li><p><code>Future는 특정 작업이 정상적으로 완료됐는지, 아니면 취소됐는지 등에 대한 정보를 확인할 수 있도록 만들어진 클래스이다.</code></p></li><li><p><code>Future</code>가 동작하는 사이클에서 염두에 둬야 할 점은 한 번 지나간 상태는 되돌릴 수 없다.</p></li><li><p>이렇게 사이클을 되돌릴 수 없다는 것은 ExecutorService와 동일하다. 일단 완료된 작업은 완료 상태에 영원히 머무른다.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get 메소드의 작업 진행 상태 ( 시작되지 않은 상태, 시작한 상태, 완료된 상태 )</span><br><span class="line">* 작업이 완료 상태에 들어가 있으면 get 메소드는 즉시 결과값을 리턴하거나 Exception을 발생시킨다.</span><br><span class="line">* 아직 작업이 시작하지 않았거나 작업이 실행되고 있는 상태이면 작업이 완료될 때까지 대기한다.</span><br><span class="line">* 작업 실행이 모두 끝난 상태에서 Exception이 발생했다면, get 메소드는 원래 발생했던 Exception을 ExecutionExceptio 예외 클래스에 담는다.</span><br><span class="line">* 작업이 중간에 취소 됐으면 get 메소드에서 CancellationException이 발생한다.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, CancellationException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExcutionException, CancellationException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Callable과 Future 인터페이스</p></li><li><p>ExecutorService 클래스의 submit 메소드는 모두 Future 인스턴스를 리턴한다.</p></li><li><p>따라서 Executor에 Runnable이나 Callable을 등록하면 Future 인스턴스를 받을 수 있고 받은 Future 인스턴스를 사용해 작업의 결과를 확인하거나 실행 도중에 작업을 취소할 수도 있다.</p></li><li><p>아니면 Rannable이나 Callable을 사용해 직접 FutureTask 인스턴스를 생성하는 방법도 있다. ( FutureTask 자체가 Runnable을 상속받고 있기 때문에 Executor에 넘겨 바로 실행시킬 수도 있고, 아니면 run 메소드를 직접 호출해 실행시킬 수도 있다. )</p></li><li><p>ExecutorService를 구현하는 클래스에서 AbstractExecutorService에 정의된 newTaskFor라는 메소드를 오버라이드할 수 있도록 되어 있으며, newTaskFor를 오버라이드해 등록된 Runnable이나 Callable에 따라 Future를 생성하는 기능에 직접 관여할 수 있다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ThreadPoolExecutor.newTaskFor 메소드의 기본 구현 내용</li><li>Executor에 Runnable이나 Callable을 넘겨 등록하는 것은 Runnable이나 Callable을 처음 생성했던 스레드에서 실제 작업을 실행할 스레드로 안전하게 공개하는 과정을 거치도록 되어있다.</li></ul><hr><h3>6.3.3 예제: Future를 사용해 페이지 렌더링</h3><ul><li>앞서 소개한 순차적 HTML 페이지 렌더링 프로그램의 병렬성을 높여 동작하도록 만들어 보자.</li><li>먼저 프로그램 내부에서 진행되는 작업을 둘로 나누자.</li><li>첫 번째는 텍스트를 이미지로 그려내는 작업이다.</li><li>두 번째는 HTML 페이지에서 사용한 이미지 파일을 다운로드 받는 작업이다.</li><li>텍스트를 그려넣는 작업은 CPU를 많이 사용하고, 이미지를 다운로드 받는 작업은 I/O 부분을 많이 사용한다.</li><li>따라서 작업을 이와 같이 둘로 나누면 단일 CPU를 사용하는 시스템에서도 성능을 향상시킬 수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureRenderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);</span><br><span class="line">        Callable&lt;List&lt;ImageData&gt;&gt; task = <span class="keyword">new</span> Callable&lt;List&lt;ImageData&gt;&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> List&lt;ImageData&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        List&lt;ImageData&gt; result = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</span><br><span class="line">                        <span class="keyword">for</span> (ImageInfo imageInfo : imageInfos)</span><br><span class="line">                            result.add(imageInfo.downloadImage());</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(task);</span><br><span class="line">        renderText(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;ImageData&gt; imageData = future.get();</span><br><span class="line">            <span class="keyword">for</span> (ImageData data : imageData)</span><br><span class="line">                renderImage(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// Re-assert the thread's interrupted status</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="comment">// We don't need the result, so cancel the task too</span></span><br><span class="line">            future.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ImageData</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ImageInfo</span> </span>&#123;</span><br><span class="line">        <span class="function">ImageData <span class="title">downloadImage</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">renderText</span><span class="params">(CharSequence s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> List&lt;ImageInfo&gt; <span class="title">scanForImageInfo</span><span class="params">(CharSequence s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">renderImage</span><span class="params">(ImageData i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>FutureRenderer 클래스에는 먼저 이미지를 다운로드 받는 기능의 Callable을 만들어 ExecutorService에 등록시킨다.</li><li>Callable이 등록되는 즉시 해당하는 작업에 대한 Future 인스턴스를 받을 수 있다.</li><li>메인 작업이 실행되는 과정에서 이미지 파일을 표현해야 하는 시점이 되면 Future.get 메소드를 호출해 해당하는 이미지 파일을 확보한다.</li><li>가장 낙관적으로 본다면 get 메소드를 호출하기 전에 이미지를 모두 다운로드했을 것이며, 메인 스레드는 필요한 이미지를 즉시 사용할 수 있다.</li><li>이상적이지 못한 경우라 해도 이미지를 다운로드 받는 기능이 이미 모두 시작된 상태이기 때문에 순차적인 방법보다 효율적이다.</li></ol><hr><h2>6.3.4 다양한 형태의 작업을 병렬로 처리하는 경우의 단점</h2><ul><li>주방에서 접시를 닦는 일을 두 명이 처리한다고 한다면, 접시를 닦는 작업은 상당히 효율적인 방법으로 둘로 구분할 수 있다. 한쪽에서는 접시를 닦고, 다른 한쪽에서는 접시를 말리면 된다. 하지만 특정 스레드에 일정한 유형의 작업을 모두 맡겨버리는 정책은 그다지 확장성이 좋지 않다.</li><li>만약 주방에 일할 사람이 여럿이 추가로 투입되면 작업 방법을 재구성하지 않는 한 모든 사람이 최대한 바쁘게 효과적으로 일 할 수 있도록 만들기가 어렵기 때문이다.</li></ul><p><code>작업을 잘게 쪼개는 의미를 찾으려면 병렬로 처리해서 얻을 수 있는 성능상의 이득이 이와 같은 부하를 훨씬 넘어서야 한다.</code></p><ul><li>FutureRenderer는 두 종류의 작업을 사용한다.</li><li>텍스트를 그려 넣는 작업을 처리하고 또 하나는 이미지 파일을 다운로드 받는 작업을 처리한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">프로그램이 해야 할 일을 작은 작업으로 쪼개 실행할 때 실제적인 성능상의 이점을 얻으려면, 프로그램이 하는 일을 대량의 동일한 작업으로 재정의해 병렬로 처리할 수 있어야 한다.</span><br></pre></td></tr></table></figure><hr><h2>6.3.5 CompletionService: Executor와 BlockingQueue의 연합</h2><ul><li>처리해야 할 작업을 갖고 있고, 이 작업을 모두 Executor에 등록해 실행시킨 다음 각 작업에서 결과가 나오는 즉시 그 값을 가져다 사용하고자 한다면, 등록한 각 작업별로 Future 객체를 정리해두고, 타임아웃에 0을 지정해 get 메소드로 호출하면 결과가 나왔는지 <code>폴링 polling</code>해 결과를 찾아올 수 있다. 이러한 방법으로 사용할 수도 있지만, 미리 만들어져 있는 방법이 있다.</li></ul><h3>CompletionService</h3><ul><li>CompletionService는 Executor의 기능과 BlockingQueue의 기능을 하나로 모은 인터페이스다.</li><li>필요한 Callable 작업을 등록해 실행시킬 수 있고, take나 poll과 같은 큐 메소드를 사용해 작업이 완료되는 순간 완료된 작업의 Future 인스턴스를 받아올 수 있다.</li><li>CompletionService를 구현한 클래스로는 ExecutorCompletionService가 있는데 등록된 작업은 Executor를 통해 실행한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    QueueingFuture(Callable&lt;V&gt; c) &#123; <span class="keyword">super</span>(c); &#125;</span><br><span class="line">    QueueingFuture(Runnable t, V r) &#123; <span class="keyword">super</span>(t, r); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        completionQueue.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ExecutorCompletionService에서 사용하는 QueueingFuture 클래스</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* ExecutorCompletionService의 구현 내용은 굉장히 직관적이다.</span><br><span class="line">* 생성 메소드에서 완료된 결과 값을 쌓아 둘 BlockingQueue를 생성한다.</span><br><span class="line">* FutureTask에는 done 메소드가 한 번씩 호출 된다.</span><br><span class="line">* 작업을 처음 등록하면 먼저 FutureTask를 상속받은 QueueingFuture라는 클래스로 변환하는데 QueueingFuture의 done 메소드에서는 결과를 BlockingQueue에 추가하도록 되어 있다.</span><br><span class="line">* take와 poll 메소드를 호출하면 그대로 BlockingQueue의 해당 메소드로 넘겨 처리한다.</span><br></pre></td></tr></table></figure><hr><h2>6.3.6 예제: CompletionService를 활용한 페이지 렌더링</h2><p>CompletionService를 잘 활용하면 앞서 소개했던 HTML 페이지 렌더링 프로그램의 성능을 두 가지 측면에서 훨씬 개선할 수 있다.</p><ol><li>전체 실행 시간 단축</li><li>응답 속도 높임</li><li>각각 이미지 파일을 다운로드 받는 작업을 생성한다.</li></ol><p>이렇게 각각 이미지를 받게 되면 이전 순서대로 다운 받던 부분을 병렬화 하는 것이고, 이미지 파일을 전부 다운로드 받는데 걸리는 전체 시간을 줄일 수 있다. 그리고 다운로드 받은 이미지는 CompletionService를 통해 찾아가도록 하면, 이미지 파일을 다운로드 받는 순간 해당하는 위치에 그림을 그려 넣을 수 있다. 이렇게 구조를 변경하면 사용자 입장에서는 페이지가 동적으로 최대한 빠르게 업데이트 되는 모습을 볼 수 있다.</p><hr><ul><li>CompletionService를 사용해 페이지 구성 요소를 받아오는 즉시 렌더링</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">    Renderer(ExecutorService executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; info = scanForImageInfo(source);</span><br><span class="line">        CompletionService&lt;ImageData&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;ImageData&gt;(executor);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ImageInfo imageInfo : info)</span><br><span class="line">            completionService.submit(<span class="keyword">new</span> Callable&lt;ImageData&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> ImageData <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> imageInfo.downloadImage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        renderText(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>, n = info.size(); t &lt; n; t++) &#123;</span><br><span class="line">                Future&lt;ImageData&gt; f = completionService.take();</span><br><span class="line">                ImageData imageData = f.get();</span><br><span class="line">                renderImage(imageData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ImageData</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ImageInfo</span> </span>&#123;</span><br><span class="line">        <span class="function">ImageData <span class="title">downloadImage</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">renderText</span><span class="params">(CharSequence s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> List&lt;ImageInfo&gt; <span class="title">scanForImageInfo</span><span class="params">(CharSequence s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">renderImage</span><span class="params">(ImageData i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2>6.3.7 작업 실행 시간 제한</h2><ul><li>간혹 실행 중인 작업이 일정한 시간이 지난 이후에도 종료되지 않고 결과를 받지 못했다면, 결과를 사용할 시간이 지나 더 이상 작업의 의미가 없을 경우도 있다.</li><li>이럴 때는 그냥 작업 결과를 버릴 수 밖에 없다.</li></ul><p><code>일정한 시간 이내에만 작업을 처리하도록 만들고자 할 떄 가장 중요한 부분은 결과를 만들어 내지 못하건 결과를 만들어 낼 수 없다고 결론을 내리건 간에 지정된 시간이 지나면 더 이상 기다려 줄 수 없다는 점이다.</code></p><p><code>타임아웃을 지정할 수 있는 Future.get 메소드를 사용하면 이와 같은 시간 제한 요구사항을 만족할 수 있다. 즉 결과가 나오는 즉시 리턴되는 것은 타임아웃을 지정하지 않는 경우와 같지만, 지정한 시간이 지나도 결과를 만들어 내지 못하면 TimeoutException을 던지면서 실행을 멈추게 되어 있다.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page <span class="title">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> endNanos = System.nanoTime() + TIME_BUDGET;</span><br><span class="line">    Future&lt;Ad&gt; f = exec.submit(<span class="keyword">new</span> FetchAdTask());</span><br><span class="line">    <span class="comment">// 광고를 가져오는 작업을 등록했으니, 원래 페이지를 작업한다.</span></span><br><span class="line">    Page page = renderPageBody();</span><br><span class="line">    Ad ad;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 남은 시간 만큼만 대기한다</span></span><br><span class="line">        <span class="keyword">long</span> timeLeft = endNanos - System.nanoTime();</span><br><span class="line">        ad = f.get(timeLeft, NANOSECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        ad = DEFAULT_AD;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        ad = DEFAULT_AD;</span><br><span class="line">        f.cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    page.setAd(ad);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>제한된 시간 안에 광고 가져오기</li></ul><hr><h2>6.3.8 예제: 여행 예약 포털</h2><ul><li><p>사용자가 여행 일자와 필요한 내용을 입력하면 포털 사이트에서 항공사, 호텔, 렌트카 등의 업체가 입력한 입찰 정보를 한군데 모아 보여준다.</p></li><li><p>업체에 따라 다르지만, 입찰 정보를 받아오는 작업은 이를테면 웹서비스의 형태로 구현되어 있을 수도 있고, 데이터 베이스에 직접 접속해서 받아와야 할 수도 있고, EDI 형태의 트랜잭션을 처리해야 할 수도 있다.</p></li><li><p>업체별로 입찰 정보를 가져오는 작업은 업체를 단위로 완전히 독립적인 작업이다.</p></li><li><p>단일 입찰 정보를 가져오는 일이 작업의 단위로써 적절하다고 볼 수 있고, 입찰 정보를 가져오는 작업을 병렬로 처리할 수 있다.</p></li><li><p>입찰 정보를 가져오는 작업은 n개를 생성해 스레드 풀에 등록하고, 등록한 작업마다 future 객체를 확보하고, 타임아웃을 지정한 get 메소드로 각각의 입찰 정보를 가져오도록 할 수 있다.</p></li><li><p>게다가 이런 작업을 더 쉽게 만들어 주는 기능이 있는데, 바로 InvokeAll 메소드이다.</p></li><li><p>invokeAll 메소드가 리턴되면 등록된 모든 작업은 완료되어 결과값을 가지고 있거나 취소되거나 두 가지 상태 가운데 하나이다.</p></li></ul><hr><h1>요약</h1><ul><li>애플리케이션을 작업이라는 단위로 구분해 실행할 수 있도록 구조를 잡으면 개발 과정을 간소화하고 병렬성을 확보해 병렬성을 높일 수 있다.</li><li>Executor 프레임워크를 사용하면 작업을 생성하는 부분과 작업을 실행하는 부분을 분리해 실행 정책을 수립할 수 있다.</li><li>원하는 형태의 실행 정책을 쉽게 만들어 사용할 수 있다.</li><li>스레드를 직접 사용하는 대신 Executor를 사용해보자.</li><li>애플리케이션이 하는 일을 개별 작업으로 구분해 처리할 때는 작업의 범위를 적절하게 잡아야 한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QuoteTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">TravelQuote</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelCompany company;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelInfo travelInfo;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TravelQuote <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> company.solicitQuote(travelInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;TravelQuote&gt; getRankedTravelQuotes &#123;</span><br><span class="line">    TravelInfo travelInfo, Set&lt;TravelCompany&gt; companies, Comparator&lt;TravelQuote&gt; ranking, <span class="keyword">long</span> time, TimeUnit unit) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;QuoteTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;QuoteTask&gt;();</span><br><span class="line">        <span class="keyword">for</span> (TravelCompany compan : companies)</span><br><span class="line">            tasks.add(<span class="keyword">new</span> QuoteTask(company, travelInfo));</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;TravelQuote&gt;&gt; futures = exec.invokeAll(tasks, time, unit);</span><br><span class="line"></span><br><span class="line">        List&lt;TravelQuote&gt; quotes = <span class="keyword">new</span> ArrayList&lt;TravelQuote&gt;(tasks.size());</span><br><span class="line">        Iterator&lt;QuoteTask&gt; taskIter = tasks.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;TravelQuote&gt; f : futures) &#123;</span><br><span class="line">            QuoteTask task = taskIter.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                quotes.add(f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                quotes.add(task.getFailureQuote(e.getCause()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                quotes.add(task.getTimeoutQuote(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Collections.sort(quotes, ranking);</span><br><span class="line">    <span class="keyword">return</span> quotes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 4장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Chapter 6 작업 실행&lt;/h1&gt;
&lt;h2&gt;6.2.3 스레드 풀&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;스레드 풀 thread pool&lt;/code&gt;은 작업을 처리할 수 있는 동일한 형태의 스레드를 &lt;code&gt;풀 pool&lt;/code&gt;의 형태로 관리
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="Thread Pool" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/Thread-Pool/"/>
    
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="Thread Pool" scheme="http://jungha-cho.github.io/tags/Thread-Pool/"/>
    
  </entry>
  
  <entry>
    <title>자바병렬프로그래밍-Chapter06-작업실행-task</title>
    <link href="http://jungha-cho.github.io/2017/05/15/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Chapter06-%EC%9E%91%EC%97%85%EC%8B%A4%ED%96%89-task.1/"/>
    <id>http://jungha-cho.github.io/2017/05/15/자바병렬프로그래밍-Chapter06-작업실행-task.1/</id>
    <published>2017-05-14T15:55:34.000Z</published>
    <updated>2018-03-26T07:56:51.155Z</updated>
    
    <content type="html"><![CDATA[<h1>자바병렬프로그래밍 06. 작업 실행 (Task, Thread, Executor, Future, Callable, ThreadPool)</h1><ul><li><code>대부분의 병렬 애플리케이션은 [작업 task]을 실행하는 구조가 효율적으로 구성되어 있다.</code></li><li>여기서 <code>작업 task</code>란 추상적이면서 명확하게 구분된 업무의 단위를 말한다.<ul><li>애플리케이션이 해야할 일을 작업이라는 단위로 분할하면 프로그램의 구조를 간결하게 잡을 수 있고, <code>트랜잭션</code>의 범위를 지정함으로써 오류에 효과적으로 대응할 수 있고, 작업 실행 부분의 병렬성을 자연스럽게 극대화할 수 있다.</li></ul></li></ul><h1>6.1 스레드에서 작업 실행</h1><ul><li>프로그램에서 일어나는 일을 <code>작업 task</code>의 단위로 재구성하고자 한다면, 가장 먼저 해야할 일은 작업의 범위를 정하는 일이 최우선이다.</li><li><code>작업 task</code>는 다른 <code>작업 task</code>의 상태, 결과, 부수 효과 등에 영향을 받지 않는 동립적인 동작이 갖추어 져야 한다.<ul><li>이런 독립성이 갖추어 져야 <code>병렬성</code>을 보장할 수 있다.</li><li>독립적인 작업이어야 적절한 자원이 확보된 상태에서 병렬로 실행이 가능하다.</li><li>작업을 스케줄링하거나 <code>부하 분산 load balancing</code>을 하고자 할 때 폭넓은 유연성을 얻으려면 각 작업이 애플리케이션의 전체적인 업무 내용 가운데 충분히 작은 부분을 담당하도록 구성되어 있어야 한다.</li></ul></li></ul><hr><ul><li><p>서버 애플리케이션</p><ul><li>부하가 걸리지 않은 일반적인 상황에서 항상 충분한 속도와 빠른 속도를 보여줘야 한다.</li><li>사용자는 원하는 서비스를 즉각적으로 받을 수 있기를 원한다.</li><li>애플리케이션에 부하가 가해지는 상황에서 그냥 죽어버려서는 안된다.</li><li>부하에 따라 성능이 점진적으로 떨어지도록 설계돼 있어야 한다.</li></ul></li><li><p>서버 애플리케이션이 위와 같은 특성을 갖게 하려면 작업의 단위를 적절하게 설정해야한다.</p></li><li><p><code>작업 실행 정책 task execution policy</code>을 면밀히 구성해야 한다.</p></li><li><p>서버 애플리케이션의 작업 단위 예제 - 웹 서버, 메일 서버, 파일 서버, EJB 컨테이너, 데이터베이스 서버</p></li></ul><h2>6.1.1 작업을 순차적으로 실행</h2><ul><li>작업을 실행하는 가장 간단한 방법은 단일 스레드에서 작업 목록을 순차적으로 실행하는 방법이다.</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket connection = socket.accept();</span><br><span class="line">            handleRequest(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket connection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// request-handling logic here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>80 포트에 접속하는 클라이언트 요청을 순차적으로 처리한다.</li><li>SingleThreadWebServer는 한 번에 하나의 요청만 처리할 수 있기 떄문에 실제 상황에서 성능이 엄청나게 떨어진다.</li><li>웹 서버에 대한 클라이언트의 요청을 처리하는 과정에는 대부분 약간의 연산과 I/O 작업이 대부분을 차지한다.</li></ul><h2>6.1.2 작업마다 스레드를 직접 생성</h2><ul><li>반응 속도를 훨씬 높일 수 있는 방법 가운데 하나는 요청이 들어올 때마다 새로운 스레드를 하나씩 만들어 실행시키는 방법이다.</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket connection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// request-handling logic here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ThreadPerTaskWebServer는 구조만 본다면 단일 스레드 구조와 크게 다르지 않다.</p></li><li><p>클라이언트가 접속할 때마다 반복문에서 해당 클라이언트의 요청 처리를 담당하는 새로운 스레드를 매번 생성한다는 차이점이 있다.</p></li><li><p>이렇게 변경하면 크게 세 가지 결과를 얻을 수 있따.</p></li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 작업을 처리하는 기능이 메인 스레드에서 떨어져 나온다. 따라서 메인 반복문은 다음 클라이언트의 접속을 기다리는 부분으로 굉장히 빨리 넘어갈 수 있다. 서버가 이렇게 구성되어 있으면 클라이언트는 이전 작업이 끝나기 이전에라도 언제든지 서버에 접속해 요청을 전송할 수 있기 때문에 서버의 응답 속도를 높여 준다.</span><br><span class="line"> 2. 동시에 여러 작업을 병렬로 처리할 수 있기 떄문에 두 개 이상의 요청을 받아 동시에 처리할 수 있다. 만약 서버의 하드웨어에 여러 개의 CPU가 장착되어 있다면 전반적으로 처리 속도를 향상시킬 수 있고, 각 작업에서 I/O 기능이 실행되기를 기다리는 부분이 있거나 락을 확보하기 위해 대기하는 부분 또는 기타 특정 자원을 사용하기 위해 대기하는 부분이 있는 경우에 서버의 처리 속도를 높여줄 수 있다.</span><br><span class="line">3. 실제 작업을 처리하는 스레드의 프로그램은 여러 클라이언트가 접속하는 경우 동시에 동작할 가능성이 매우 높기 때문에 스레드 안전성을 확보해야 한다.</span><br></pre></td></tr></table></figure><ul><li>순차 처리 방법보다 속도가 크게 향상되며 웬만한 부하까지는 견딜 수 있다.</li><li>다만 클라이언트가 접속해 요청을 전송하는 속도에 비해 요청을 처리해 응답을 넘겨주는 속도가 빨라야 한다는 제약이 있다.</li></ul><h2>6.1.3 스레드를 많이 생성할 때의 문제점</h2><ul><li><p>특정 상황에서 엄청나게 많은 대량의 스레드가 생성될 수 있다.</p></li><li><p>이떄 아래와 같은 단점이 발생한다.</p></li><li><p><code>스레드 라이프 사이클 문제</code> : 스레드를 생성하는 과정에 일정량의 시간이 필요하다. 기본적인 딜레이가 발생하고, JVM과 운영체제는 몇가지 기초적인 작업을 수행한다. 간단한 작업이라면 매번 새로운 스레드를 생성하는 일이 작업에서 많은 부분을 차지할 수 있다.</p></li><li><p><code>자원 낭비</code> : 실행 중인 스레드는 시스템 자원, 특히 메모리를 소모한다. 하드웨어에 실제로 장착되어 있는 프로세서보다 많은 수의 스레드가 만들어져 동작 중이라면, 실제로는 대부분의 스레드가 <code>대기(idle)</code> 상태에 머무른다. 이렇게 대기 상태에 머무르는 스레드가 많아지면 많아질수록 많은 메모리를 필요로 하며, JVM 가비지 콜렉터에 가해지는 부하가 늘어날 뿐만 아니라 CPU를 사용하기 위해 여러 스레드가 경쟁하는 모양새가 되기 떄문에 메모리 이외의 많은 자원을 소모한다.</p><ul><li>시스템에 꽂혀 있는 CPU 개수에 해당하는 스레드가 동작 중이라면, 스레드를 더 만들어 낸다 해도 성능이 직접적으로 개선되지 않을 수 있으며 오히려 악영향을 미칠 가능성도 있다.</li></ul></li><li><p><code>안정성 문제</code> : 모든 시스템에는 생성할 수 있는 스레드의 개수가 제한되어 있다. 플랫폼과 운영체제마다 다르고, JVM을 실행할 때 지정하는 인자나 Thread 클래스에 필요한 스택의 크기에 따라서 달랒기도 한다.</p></li><li><p><code>일정 수준까지는 스레드를 추가로 만들어 사용해서 성능상의 이점을 얻을 수 있지만, 특정 수준을 넘어간다면 성능이 떨어지게 된다.</code></p></li></ul><h1>6.2 Executor 프레임워크</h1><ul><li><p><code>작업 task</code>는 논리적인 업무의 단위이며, 스레드는 특정 작업을 비동기적으로 동작시킬 수 있는 방법을 제공한다.</p></li><li><p>앞서 하나의 스레드에서 여러 작업을 순차적으로 실행시키는 방법과 각 작업을 각각의 스레드에 실행시키는 방법을 살펴 봤다.</p></li><li><p>순차 방법은 응답 속도와 전체적인 성능이 문제였고, 두번째 방법은 자원 관리 측면에서 허점이 있다.</p></li><li><p><code>크기가 제한된 큐 bounded queue</code>를 사용하면 부하가 크게 걸리는 애플리케이션의 메모리를 모두 소모해 버리지 않도록 통제하는 방법이 있다.</p></li><li><p><code>스레드 풀 thread pool</code> 또한 스레드 관리 측면에서 이와 같은 통제력을 갖출 수 있도록 해주며, <code>Executor 프레임워크</code>의 일부분으로 유연하게 사용할 수 있는 스레드 풀이 있다.</p></li><li><p>작업을 실행하고자 할때는 Thread보다 Executor가 훨씬 추상화가 잘되어 있으며 사용하기 편하다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>굉장히 단순한 인터페이스 이지만, 아주 다양한 여러 가지 종류의 작업 실행 정책을 지원하는 유연하면서도 강력한 비동기적 작업 실행 프레임워크의 근간을 이루는 인터페이스이다.</p></li><li><p><code>Executor</code>는 <code>작업 등록 task submission</code>과 <code>작업 실행 task execution</code>을 분리하는 표준적인 방법이며, 각 작업은 Runnable 형태로 정의한다. Executor인터페이스를 구현한 클래스는 작업의 라이프 사이클을 관리하는 기능도 갖고 있고, 몇가지 통계값을 뽑아내거나 애플리케이션의 작업 실행 과정을 관리하고 모니터하는 기능도 갖고 있다.</p></li><li><p>Executor는 프로듀서-컨슈머 패턴에 기반하고 있다.</p></li></ul><h2>6.2.1 예제: Executor를 사용한 웹서버</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutionWebServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exec</span><br><span class="line">            = Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket connection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// request-handling logic here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>몇 가지 표준 Executor 가운데 100개의 고정된 스레드를 확보하는 풀을 사용했다.</li><li>Executor를 구현한 클래스를 다른 방법으로 사용하면 비슷한 기능에 다른 특성으로 동작하도록 손쉽게 동작할 수 있다.</li><li>스레드를 직접 생성하면 동작 특성을 쉽게 변경할 수 없지면, Executor는 가능하다.</li></ul><h2>6.2.2 실행 정책</h2><ul><li>작업을 등록하는 부분과 실행하는 부분을 서로 분리시켜두면 특정 작업을 실행하고자 할 때 코드를 많이 변경하거나 기타 여러 가지 어려운 상황에 맞닥뜨리지 않으면서도 <code>실행 정책 execution policy</code>를 언제든지 쉽게 변경할 수 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 작업을 어느 스레드에서 실행할 것인가?</span><br><span class="line">- 작업을 어떤 순서로 실행할 것인가? ( FIFO, LIFO, 기타 다양한 우선순위 정책 )</span><br><span class="line">- 동시에 몇 개 의 작업을 병렬로 실행할 것인가?</span><br><span class="line">- 최대 몇 개까지의 작업이 큐에서 실행을 대기할 수 있게 할 것인가?</span><br><span class="line">- 시스템에 부하가 많이 걸려서 작업을 거절해야 하는 경우, 어떤 작업을 희생양으로 삼아야 할 것이며, 작업을 요청한 프로그램에 어떻게 알려야 할 것인가?</span><br><span class="line">- 작업을 실행하기 직전이나 실행한 직후에 어떤 동작이 있어야 하는가?</span><br></pre></td></tr></table></figure><ul><li>실행 정책은 일종의 자원 관리 도구이다.</li><li>가장 최적화된 실행 정책을 찾으려면 하드웨어나 소프트웨어적인 자원을 얼마나 확보할 수 있는지 확인해야 한다.</li><li>애플리케이션의 성능과 반응속도가 요구사항에 얼마만큼 명시되어 있는지도 알아야 한다.</li><li>병렬로 실행되는 스레드의 수를 제한한다면 아마도 애플리케이션이 경쟁하느라 애플리케이션의 성능이 떨어지는 일은 별로 보기 어려울 것이다.</li><li>실행 정책과 작업 등록 부분을 명확하게 분리시켜두면 애플리케이션을 실제 상황에 적용하려 할 때 설치할 하드웨어와 기타 자원의 양에 따라 적절한 실행 정책을 임의로 지정할 수 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">프로그램 어디에서든 간에</span><br><span class="line">`new Thread(runnable).start();`</span><br><span class="line">와 같은 코드가 남아 있다면 조만간 이런 부분에 유연한 실행 정책을 적용할 준비를 해야할 것이며, 나중을 위해서 Executor를 사용해 구현하는 방안을 심각하게 고려해봐야 한다.</span><br></pre></td></tr></table></figure><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 6장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;자바병렬프로그래밍 06. 작업 실행 (Task, Thread, Executor, Future, Callable, ThreadPool)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;대부분의 병렬 애플리케이션은 [작업 task]을 실행하는 구조가 효율적으로
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="task" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/task/"/>
    
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="task" scheme="http://jungha-cho.github.io/tags/task/"/>
    
  </entry>
  
  <entry>
    <title>자바병렬프로그래밍-동시성concurrency과-병렬성Parallelism</title>
    <link href="http://jungha-cho.github.io/2017/05/13/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%8F%99%EC%8B%9C%EC%84%B1concurrency%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1Parallelism/"/>
    <id>http://jungha-cho.github.io/2017/05/13/자바병렬프로그래밍-동시성concurrency과-병렬성Parallelism/</id>
    <published>2017-05-13T03:15:15.000Z</published>
    <updated>2018-03-26T07:56:19.176Z</updated>
    
    <content type="html"><![CDATA[<h1>병렬프로그래밍 - 동시성 Concurrency 과 병렬성 Parallelism</h1><h2>무슨 차이?</h2><ul><li>사진 부터 보자</li></ul><p><img src="/images/parallelism-vs-concurrency.png" alt="parallelism-vs-concurrency"></p><ul><li><p><a href="http://alvinalexander.com/photos/parallelism-vs-concurrency-programming" target="_blank" rel="noopener">출처</a></p></li><li><p>Concurrent = two queues and one coffee machine.</p></li><li><p>Parallel = Two queues and two coffee machines.</p></li><li><p>동시성과 병렬성을 설명하는 한장의 그림이다.</p></li><li><p>Concurrency = 동시성, 동시 실행</p></li><li><p>Parallelism = 병렬성, 평행성, 병렬 실행, 평행 실행</p></li></ul><h2>먼저 Process와 Thread 부터</h2><h3>Process?</h3><ul><li>Process는 Program이 실행되고 있는 상태를 뜻한다.</li><li>Program은 하드 디스크에서 실행을 기다리고 있는 코드, 또는 실행 파일이다.</li><li>OS로 부터 할당받아 실행된다.</li></ul><h3>Thread?</h3><ul><li>하나의 Process내에서 실행되는 하나의 작업 단위이다.</li><li>메모리와 IO 장치 및 컴퓨터 자원들을 공유한다.</li></ul><h3>둘의 관계?</h3><ul><li>애플리케이션이 실행될 때 하나의 Process가 발생한다.</li><li>해당 Process가 어떠한 작업을 수행할 떄 컴퓨터 자원을 최대한 활용하기 위해 작업을 병렬로 수행해야 한다.</li><li>Thread를 이용해서 컴퓨터의 놀고 있는 자원을 최대한 사용하게 한다.</li><li>이를 Multi-Thread Programming이라 한다.</li><li>IO를 기다리게 하지 않고 다른 일을 하게 하거나, 놀고 있는 여분의 CPU 코어들을 최대한 사용하게 하는 것이 핵심이다.</li></ul><h1>그렇다면 동시성과 병행성은 무엇일까?</h1><h2>Parallelism</h2><ul><li><code>language에서 Parallelism이라 불리는 대표적인 예가 Thread 이다. Thread는 그야말로 동시에 평행적으로 실행 된다.</code></li></ul><h2>Concurrency</h2><ul><li><code>Concurrency는 Parallelism의 난해함을 풀어낸 방법이다. 대표적인 예로 Coroutine이 있다.</code><ul><li><code>Coroutine이란?</code><ul><li>유니티에서 코루틴은 서브루틴의 일종으로 진입시점이 여러개인 서브루틴을 말한다.</li></ul></li></ul></li><li>특정 라인이 수행된 다음 차근차근 수행되는 Sync 방식이 아니라 Async하게 코드를 실행시키고, 결과 값이 오거나 혹은 필요한 때에 다음 루틴을 실행 시키게 할 수 있어서 효율적으로 자원을 활용할 수 있다. 덤으로 코드가 Thread로 구현했을 때보다 훨씬 깔끔하게 나오고, Locking/UnLocking 메커니즘을 싹 걷어낼 수 있게 된다.</li></ul><h2>Concurrency의 개념을 적극적으로 도입한 Go Language</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(from <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(from, <span class="string">":"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        f(<span class="string">"direct"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> f(<span class="string">"goroutine"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">                fmt.Println(msg)</span><br><span class="line">        &#125;(<span class="string">"going"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">        fmt.Scanln(&amp;input)</span><br><span class="line">        fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Go 언어에서 Concurrency의 개념은 Goroutine으로 구현되어있다.</p></li><li><p>Goroutine은 multi-thread의 백단 dirty한 부분에 손 하나 대지 않고 쉽게 Async한 일들을 처리할 수 있게 해준다.</p></li><li><p>Goroutine은 자원을 Locking/Unlocking하는 코드들이 불필요하다.</p></li><li><p>아랫단의 일들을 golang의 runtime이 알아서 해주고 Thread를 여러개 실행 시키도록 셋팅하면 각 thread에 goroutine을 할당하여 자원을 관리하는 일까지도 언어단에서 알아서 해준다.</p></li><li><p>개발자들은 C/C++에서 thread를 사용하는 것과 마찬가지로 적절한 작업들에 goroutine을 호출시키고 channel을 이용해서 결과값들을 받아서 훨씬 수월하게 처리할 수 있다.</p></li><li><p>이러한 언어의 Concurrency는 기존에 C나 C++에서 다루었었던 멀티쓰레드와 자원 관리의 복잡함으로부터 개발자들을 해방시키는 역할을 해준다.</p></li><li><p>동시에 Multi-Thread로 해냈던 수준의 Async하고 parallel한 작업들을 흉내내거나 손쉽게 수행할 수 있도록 해준다.</p></li><li><p><a href="http://rapapa.net/?p=2704" target="_blank" rel="noopener">출처</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;병렬프로그래밍 - 동시성 Concurrency 과 병렬성 Parallelism&lt;/h1&gt;
&lt;h2&gt;무슨 차이?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;사진 부터 보자&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/parallelism-vs-concur
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="동시성과 병렬성" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EB%8F%99%EC%8B%9C%EC%84%B1%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1/"/>
    
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="동시성" scheme="http://jungha-cho.github.io/tags/%EB%8F%99%EC%8B%9C%EC%84%B1/"/>
    
      <category term="병렬성" scheme="http://jungha-cho.github.io/tags/%EB%B3%91%EB%A0%AC%EC%84%B1/"/>
    
      <category term="Concurrency" scheme="http://jungha-cho.github.io/tags/Concurrency/"/>
    
      <category term="Parallelism" scheme="http://jungha-cho.github.io/tags/Parallelism/"/>
    
  </entry>
  
  <entry>
    <title>자바병렬프로그래밍-Chapter05-효율적이고-확장성-있는-결과-캐시-구현</title>
    <link href="http://jungha-cho.github.io/2017/05/13/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Chapter05-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B4%EA%B3%A0-%ED%99%95%EC%9E%A5%EC%84%B1-%EC%9E%88%EB%8A%94-%EA%B2%B0%EA%B3%BC-%EC%BA%90%EC%8B%9C-%EA%B5%AC%ED%98%84/"/>
    <id>http://jungha-cho.github.io/2017/05/13/자바병렬프로그래밍-Chapter05-효율적이고-확장성-있는-결과-캐시-구현/</id>
    <published>2017-05-12T17:04:15.000Z</published>
    <updated>2018-03-26T07:56:30.320Z</updated>
    
    <content type="html"><![CDATA[<h1>5.6 효율적이고 확장성 있는 결과 캐시 구현</h1><p>거의 대부분의 서버 애플리케이션은 모두 어떤 형태이건 캐시를 사용한다. 이전에 처리했던 작업의 결과를 재사용할 수 있다면, 메모리를 조금 더 사용하기는 하지만 대기시간을 크게 줄이면서 처리 용량을 늘릴 수 있다.</p><ul><li>했던 일을 다시 반복하던 여러 사례에서 볼 수 있듯, 캐시 기능은 굉장히 만들기 쉬워 보인다.</li><li>하지만 캐시를 대충 만들면 단일 스레드로 처리할 때 성능이 높아질 수는 있겠지만, 나중에는 성능의 병목 현상을 확장성의 병목으로 바꾸는 결과를 얻을 수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 계산 가능한 인터페이스 A = arg, V = return</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computable</span> &lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스레드 안전성을 확보한 메모이제이션 = 캐시</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer1</span> &lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> HashMap&lt;A, V&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer1</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">String</span>, <span class="title">BigInteger</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigInteger <span class="title">compute</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// after deep thought...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Computable&lt;A, V&gt; 인터페이스는 A라는 입력 값과 V라는 결과 값에 대한 메소드를 정의하고 있다.</p></li><li><p>Computable 인터페이스를 구현한 ExpensiveFunction 클래스는 결과를 뽑아 내는 데 상당한 시간이 걸린다.</p></li><li><p>이런 상황에서 Computable에 한겹을 덧씌워 이전 결과를 기억하는 캐시 기능을 추가해 보자.</p></li><li><p><code>메모이제이션 memoization</code></p></li><li><p>HashMap은 스레드에 안전하지 않기 때문에 Memoizer1은 두 개 이상의 스레드가 HashMap에 동시에 접근하지 못하도록 Compute 메소드 전체를 동기화시켜 버리는 가장 단순한 정책을 취했다.</p></li><li><p>이 방법은 스레드 안전성을 쉽게 확보할 수 있지만 <code>확장성</code> 측면에서 문제가 생긴다.</p></li><li><p>어떤 스레드가 compute를 실행하는 연산 시간이 오래 기다린다면 compute를 실행하려 기다리는 스레드의 대기시간이 길어진다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer2</span> &lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;A, V&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer2</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Memoizer2는 HashMap 대신 ConcurrentHashMap을 사용하는데, Memoizer1에 비해 병렬 프로그래밍의 입장에서 엄청나게 개선됐다.</li><li>ConcurrentHashMap은 이미 스레드 안전성을 확보하고 있기 때문에 Map을 사용할 때 별다른 동기화 방법을 사용하지 않아도 된다.</li><li>따라서 Memoizer1에서 compute 메소드 전체를 동기화 하느라 생겼던 성능상의 큰 문제점을 이거에 해소했다.</li><li>Memoizer2는 Memoizer1에 비해 훨씬 개선된 병렬 프로그램의 모양새를 갖추고 있다.</li><li>여러개의 스레드가 동시 다발적으로 Memoizer2에 접근할 수 있다.</li><li><code>하지만 캐시라는 기능으로 볼 때 아직도 약간 미흡한 부분이 있다.</code></li><li><code>두 개 이상의 스레드가 동시에 같은 값을 넘기면서 compute 메소드를 호출해 같은 결과를 받아갈 가능성이 있기 때문이다.</code></li><li><code>메모이제이션 측면에서 보면 이런 상황은 단순히 효율성이 약간 떨어지는 것뿐이다.</code></li><li><code>캐시는 같은 결과를 두번 연산하는 일이 없게 하려는 목적이기 때문에 캐시 측면에서는 비효율적이다.</code></li><li><code>이런 측면에서 똑같은 결과를 두 개 이상 만들어 낼 수 있다는 것은 안전성 문제로 이어질 수 있다.</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Memoizer2의 문제는 특정 스레드가 compute 메소드에서 연산을 시작했을때 다른 스레드에서 현재 어떤 연산이 이루어지고 있는지 모르기 때문에 동일 연산을 시작할 수 있다.</span><br><span class="line">1. 특정 스레드가 f(27) 값을 알고 싶을 때, 스레드 X가 현재 f(27) 연산을 수행하고 있다는 것을 알아야 한다.</span><br><span class="line">2. f(27)을 다른 스레드가 계산하고 있을 때 f(27) 값을 얻을 수 있는 효과적인 방법을 찾아야 한다.</span><br><span class="line">3. 스레드 X가 작업을 끝낼때 까지 대기하고 있다가 작업이 끝나면 f(27)의 결과가 무엇인지 물어보는 것이다.</span><br><span class="line"></span><br><span class="line">이미 이러한 동작을 수행하는 클래스가 있다.</span><br><span class="line">1. FutureTask는 이미 끝났거나 끝날 예정인 연산 작업을 표현해 작업한다.</span><br><span class="line">2. FutureTask.get 메소드는 연산 작업이 끝나는 즉시 연산 결과를 리턴한다.</span><br><span class="line">3. 연산 도중이라면 작업이 끝날때까지 기다렸다가 그 결과를 알려준다.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer3</span> &lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer3</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(<span class="keyword">final</span> A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Callable&lt;V&gt; eval = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;V&gt;(eval);</span><br><span class="line">            f = ft;</span><br><span class="line">            cache.put(arg, ft);</span><br><span class="line">            ft.run(); <span class="comment">// call to c.compute happens here</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> LaunderThrowable.launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Memoizer3는 결과를 저장하는 Map을 기존 ConcurrentHashMap&lt;A, V&gt; 대신 ConcurrentHashMap&lt;A, Future<v>&gt;라고 정의한다.</v></p></li><li><p>Memoizer3는 먼저 원하는 값에 대한 연산 작업이 시작됐는지 확인해 본다. (Memoizer2는 연산이 끝난 결과를 검색한다.)</p></li><li><p>시작된 작업이 없으면 FutureTask를 하나 만들어 Map에 등록하고 연산을 시작한다.</p></li><li><p>시작된 작업이 있었으면 결과를 대기한다.</p></li><li><p><code>[Memoizer3는 캐시라는 측면에서 이제 거의 완벽한 모습을 갖췄다. 상당한 수준의 동시 사용성도 갖고 있고(ConcurrentHashMap이 제공하는 병렬성을 100% 활용한다.) 결과를 이미 알고 있다면 계산 결과 과정을 거치지 않고 결과를 즉시 가져갈 수 있고, 특정 스레드가 연산 작업을 진행하고 있다면 뒤이어 오는 스레드는 진행 중인 연산 작업의 결과를 기다리도록 되어 있다.]</code></p></li><li><p>하지만 아직 미흡한 점이 있는데, 여전히 여러 스레드가 같은 값에 대한 연산을 시작할 수 있다.</p></li><li><p>compute 메소드의 if문을 거의 동시에 실행한다면 모두 계산된 값이 없다고 판단하고 새로운 연산을 시작할 수 있다.</p></li><li><p>Memoizer3가 갖고 있는 허점은 Map에 결과를 추가할 때 단일 연산이 아닌 복합 연산을 사용하기 때문이고, 락을 사용해서는 단일 연산으로 구성할 수가 없다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer</span> &lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(<span class="keyword">final</span> A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Callable&lt;V&gt; eval = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;V&gt;(eval);</span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                cache.remove(arg, f);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> LaunderThrowable.launderThrowable(e.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Memoizer는 ConcurrentMap 클래스의 putIfAbsent 라는 단일 연산 메소드를 사용해 결과를 저장한다. 이것으로 Memoizer3에서 발생하던 허점은 완벽하게 보완했다.</li><li>실제 결과 값 대신 Future 객체를 캐시하는 방법은 이른바 <code>캐시 공해</code>를 유발할 수 있다.</li><li>특정 시점에 시도했던 연산이 취소되거나 오류가 발상했었다면 Future 객체 역시 취소되거나 오류가 발생했던 상황을 알려줄 것이다.</li><li><code>이러한 문제 해결을 위해 Memoizer는 연산이 취소되거나 RuntimeException이 발생한 경우에도 Future 객체를 제거한다.</code></li><li>거의 모든 문제가 해결 됐지만 Memoizer는 아직 캐시된 내용이 만료되는 기능은 갖고 있지 않다.<ul><li>이 부분은 FutureTask를 상속받아 만료된 결과인지 여부를 알 수 있는 새로운 클래스를 만들어 사용한다.</li><li>또한 결과 캐시를 주기적으로 돌아다니면서 만료된 결과 항목이 있는지 조사해 제거하는 기능을 구현하는 것으로 간단하게 해결할 수 있다.</li><li>만료 기능과 유사하게 캐시에 저장되는 항목의 개수나 크기 등을 제한해 너무 많은 메모리를 소모하지 않도록 제한하는 기능도 아직 담고 있지 않다.</li></ul></li></ul><p><code>이러한 병렬 캐시 기능을 이용해 앞전 예제인 인수분해 서블릿에 캐시 기능을 연결할 수 있다.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorizer</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;BigInteger, BigInteger[]&gt; c = <span class="keyword">new</span> Computable&lt;BigInteger, BigInteger[]&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> BigInteger[] compute(BigInteger arg) &#123;</span><br><span class="line">                    <span class="keyword">return</span> factor(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;BigInteger, BigInteger[]&gt; cache = <span class="keyword">new</span> Memoizer&lt;BigInteger, BigInteger[]&gt;(c);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger i = extractFromRequest(req);</span><br><span class="line">            encodeIntoResponse(resp, cache.compute(i));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            encodeError(resp, <span class="string">"factorization interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encodeIntoResponse</span><span class="params">(ServletResponse resp, BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encodeError</span><span class="params">(ServletResponse resp, String errorString)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BigInteger <span class="title">extractFromRequest</span><span class="params">(ServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(<span class="string">"7"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger[] factor(BigInteger i) &#123;</span><br><span class="line">        <span class="comment">// Doesn't really factor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger[]&#123;i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>1부 요약</h1><h2>아래 내용만 봐도 1부의 내용을 요악할 수 있다.</h2><pre><code>1. 상태가 바뀔 수 있다.  병렬성과 관련된 모든 문제점은 변경 가능한 변수에 접근하려는 시도를 적절하게 조율하는 것으로 해결할 수 있다. 변경 가능성이 낮으면 낮을수록 스레드 안전성을 확보하기가 쉽다.2. 변경 가능한 값이 아닌 변수는 모두 final로 선언하라.3. 불변 객체는 항상 그 자체로 스레드 안전하다.  불변 객체는 병렬 프로그램을 엄청나게 간편하게 작성할 수 있도록 해준다. 불변 객체는 간결하면서 안전하고, 락이나 방어적 복사 과정을 거치지 않고도 얼마든지 공유해 사용할 수 있다.4. 캡슐화하면 복잡도를 손쉽게 제어할 수 있다.  모든 값을 전역 변수에 넣어 두더라도 프로그램을 스레드 안전하게 작성할 수는 있다. 하지만 도대체 무엇 때문에 그런 짓을 하는가? 데이터를 객체 내부에 캡슐화하면 값이 변경되는 자유도를 쉽게 제어할 수 있다. 객체 내부에서 동기화하는 기법을 캡슐화하면 동기화 정책을 손쉽게 적용할 수 있다.5. 변경 가능한 객체는 항상 락으로 막아줘야 한다.6. 불변 조건 내부에 들어가는 모든 변수는 같은 락으로 막아줘야 한다.7. 불변 조건 내부에 들어가는 모든 변수는 같은 락으로 막아줘야 한다.8. 복합 연산을 처리하는 동안에는 항상 락을 보호하고 있어야 한다.9. 여러 스레드에서 변경 가능한 변수의 값을 사용하도록 되어 있으면서 적절한 동기화 기법이 적용되지 않은 프로그램은 올바른 결과를 내놓지 못한다.10. 동기화할 필요가 없는 부분에 대해서는 일부러 머리를 써서 고민할 필요가 없다. (동기화 할 필요가 없다고 이래저래 추측한 결론에 의존해서는 안된다.)11. 설계 단계에서부터 스레드 안전성을 염두에 두고 있어야 한다. 아니면 최소한 결과물로 작성된 클래스가 스레드에 안전하지 않다고 반드시 문서로 남겨야 한다.12. 프로그램 내부 동기화 정책에 대한 문서를 남겨야 한다.출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 5장 인용.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.6 효율적이고 확장성 있는 결과 캐시 구현&lt;/h1&gt;
&lt;p&gt;거의 대부분의 서버 애플리케이션은 모두 어떤 형태이건 캐시를 사용한다. 이전에 처리했던 작업의 결과를 재사용할 수 있다면, 메모리를 조금 더 사용하기는 하지만 대기시간을 크게 줄이면서
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="cache" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/cache/"/>
    
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="cache" scheme="http://jungha-cho.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>자바병렬프로그래밍-Chapter05-동기화클래스</title>
    <link href="http://jungha-cho.github.io/2017/05/12/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Chapter05-%EB%8F%99%EA%B8%B0%ED%99%94%ED%81%B4%EB%9E%98%EC%8A%A4/"/>
    <id>http://jungha-cho.github.io/2017/05/12/자바병렬프로그래밍-Chapter05-동기화클래스/</id>
    <published>2017-05-12T14:27:28.000Z</published>
    <updated>2018-03-26T07:55:45.623Z</updated>
    
    <content type="html"><![CDATA[<h1>5.5 동기화 클래스</h1><p>블로킹 큐는 다양한 컬렉션 클래스 가운데 특히나 눈에 띄는 특성이 많다.</p><ul><li>객체를 담을 수 있는 컬렉션 클래스</li><li>프로듀서-컨슈머 사이에서 take와 put 등의 블로킹 메소드를 사용해 작업의 흐름을 조절할 수 있다.</li></ul><p>상태 정보를 사용해 스레드 간 작업 흐름을 조절할 수 있도록 만들어진 클래스를 <code>동기화 클래스 synchronizer</code>라고 한다.</p><ul><li><p>또 다른 동기화 클래스의 예로는 <code>세마포어 semaphore</code>, <code>배리어 barrier</code>, <code>래치 latch</code> 등이 있다.</p></li><li><p>모든 동기화 클래스는 구조적인 특징을 갖고 있다.</p></li><li><p>동기화 클래스에 접근하려는 스레드가 어느 경우에 통과하고 어느 경우에는 대기하도록 멈추게 해야 하는지를 결정하는 상태 정보를 갖고 있고 그 상태를 변경할 수 있는 메소드를 제공하고, 동기화 클래스가 특정 상태에 진입할 떄까지 효과적으로 대기할 수 있는 메소드도 제공한다.</p></li></ul><h3>5.5.1 래치</h3><ul><li>래치는 스레드가 동작하는 과정을 늦출 수 있도록 해주는 동기화 클래스이다.</li><li>래치는 일종의 관문과 같은 형태로 동작한다.</li><li>래치가 터미널 상태에 이르기 전에는 관문이 닫혀 있고 어떤 스레드도 통과할 수 없다.</li><li>래치가 터미널 상태에 다다르면 관문이 열리고 모든 스레드가 통과한다.</li><li>한번 열린 관문은 계속해서 열린 상태로 유지된다.</li><li>이런 특성의 래치는 특정한 단일 동작이 완료되기 이전에는 어떤 기능도 동작하지 않도록 막아내야 하는 경우 요긴하다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 특정 자원을 확보하기 전에는 작업을 시작하지 말아야 하는 경우.</span><br><span class="line">2. 의존성을 갖고 있는 다른 서비스가 시작하기 전에는 특정 서비스가 실행되지 않도록 막아야 하는 경우.</span><br><span class="line">3. 특정 작업이 필요한 모든 객체가 실행할 준비를 갖출 때까지 기다리는 경우.</span><br></pre></td></tr></table></figure><ul><li>CountDownLatch 클래스의 countDown 메소드는 대기하던 이벤트가 발생했을 때 내부에 갖고 있는 이벤트 카운터를 하나 낮춘다.</li><li>await 메소드는 래치 내부의 카운터가 0이 될때까지, 대기하던 모든 이벤트가 호출될때 까지 대기한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>); <span class="comment">// 1초기화</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads); <span class="comment">// 쓰레드만큼</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        startGate.await(); <span class="comment">// start는 기다린다.</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            task.run(); <span class="comment">// 태스크 실행</span></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            endGate.countDown(); <span class="comment">// 끝나면 갯수를 낮춘다.</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        startGate.countDown();</span><br><span class="line">        endGate.await();</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>왜 TestHarness는 스레드가 만들어지는대로 바로 작업을 시작하도록 하지 않았을까?</li><li>n개의 스레드가 동시에 동작할 때 전체 작업 시간이 얼마나 걸리는지 확인하려고 만들어진 클래스이다.</li></ul><h3>5.5.2 FutureTask</h3><ul><li>FutureTask는 Future 인터페이스를 구현한다.</li><li>Future 인터페이스는 연산 결과를 알려준다.</li><li>FutureTask가 나타내는 연산 작업은 Callable 인터페이스를 구현하도록 되어있는데, 시작 전 대기, 시작됨, 종료됨과 같은 세 가지 상태를 가질 수 있다.<ul><li>종료된 상태는 정상적인 종료, 취소, 예외 상황 발생과 같이 연산이 끝나는 모든 종류의 상태를 의미한다.</li><li>FutureTask가 한번 종료됨 상태에 이르면 더 이상 상태가 바뀌지 않는다.</li></ul></li><li>Future.get 메소드도 실행 상태에 따라 동작 상태가 다르다.<ul><li>FutureTask의 작업이 종료 됐으면 get 메소드는 그 결과를 즉시 알려준다.</li><li>종료 상태에 이르지 못했다면 get 메소드는 끝날때 까지 대기한다.</li></ul></li><li>FutureTask는 실제로 연산을 실행했던 스레드에서 만들어 낸 결과 객체를 실행시킨 스레드에게 넘겨준다.</li><li>FutureTask 클래스에 명시된 것처럼 결과 객체는 안전한 공개 방법을 통해 넘겨주게 되어 있다.<ul><li>FutureTask는 Executor 프레임웍에서 비동기적인 작업을 실행하고자 할 때 사용된다.</li><li>기타 시간이 많이 필요한 모든 작업이 있을 떄 실제 결과가 필요한 시점 이전에 미리 작업을 실행시켜두는 용도로 사용한다.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Preloader</span> </span>&#123;</span><br><span class="line">    <span class="function">ProductInfo <span class="title">loadProductInfo</span><span class="params">()</span> <span class="keyword">throws</span> DataLoadException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;ProductInfo&gt; future =</span><br><span class="line">        <span class="keyword">new</span> FutureTask&lt;ProductInfo&gt;(<span class="keyword">new</span> Callable&lt;ProductInfo&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> DataLoadException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> loadProductInfo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(future);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; thread.start(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> DataLoadException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            Throwable cause = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> DataLoadException)</span><br><span class="line">                <span class="keyword">throw</span> (DataLoadException) cause;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> LaunderThrowable.launderThrowable(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ProductInfo</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataLoadException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>Preloader 클래스는 FutureTask를 사용해 결과 값이 필요한 시점 이전에 시간이 많이 걸리는 작업을 미리 실행시켜둔다.</li><li>시간이 많이 걸리는 작업을 미리 시작시켜두면 실제로 결과를 필요로 하는 시점이 됐을 때 기다리는 시간을 줄일 수 있다.</li></ul><h3>Callable</h3><p>Callable 인터페이스로 정의되어 있는 작업에서는 예외를 발생시킬 수 있으며 어디에서든 Error도 발생 시킬 수 있따.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 변수 t의 내용이 Error 라면 그대로 throw한다.</span></span><br><span class="line"><span class="comment"> * 변수 t의 내용이 RuntimeException이라면 그대로 리턴한다.</span></span><br><span class="line"><span class="comment"> * 다른 모든 경우에는 IllegalStateException을 throw한다.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RuntimeException <span class="title">launderThrowable</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException)</span><br><span class="line">      <span class="keyword">return</span> (RuntimeException) t;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error)</span><br><span class="line">      <span class="keyword">throw</span> (Error) t;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"RuntimeException이 아님"</span>, t);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2>5.5.3 세마포어</h2><ul><li><p><code>카운팅 세마포어 counting semaphore</code>는 특정 자원이나 특정 연산을 동시에 사용하거나 호출할 수 있는 스레드의 수를 제한하고자 할 때 사용한다.</p></li><li><p>이런 기능을 활용하면 자원 <code>풀 pool</code>이나 컬렉션의 크기에 제한을 두고자 할 때 유용하다.</p></li><li><p>Semaphore 클래스는 가상의 <code>퍼밋 permit</code>을 만들어 내부 상태를 관리한다.</p></li><li><p>Semaphore를 처음 생성할 떄 생성 메소드에 최초로 생성할 퍼밋 수를 넘겨 준다.</p></li><li><p>외부 스레드는 퍼밋을 요청해 확보하거나, 이전에 확보한 퍼밋을 반납할 수도 있다.</p></li><li><p>현재 사용할 수 있는 퍼밋이 없는 경우, acquire 메소드는 남은 퍼밋이 생기거나 인터럽트가 걸리거나 지정한 시간을 넘겨 타임아웃이 걸리기 전까지 대기한다.</p></li><li><p>release 메소드는 확보했던 퍼밋을 다시 세마포어에게 반납하는 기능을 한다.</p></li><li><p>세마포어는 데이터베이스 연결 풀과같은 자원 풀에서 요긴하게 사용할 수 있다.</p></li><li><p>세마포어를 사용하면 어떤 클래스라도 크기가 제한된 컬렉션 클래스로 활용할 수 있다. ex BoundedHashSet</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">        sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sem.acquire();</span><br><span class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wasAdded = set.add(o);</span><br><span class="line">            <span class="keyword">return</span> wasAdded;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wasAdded)</span><br><span class="line">                sem.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> wasRemoved = set.remove(o);</span><br><span class="line">        <span class="keyword">if</span> (wasRemoved)</span><br><span class="line">            sem.release();</span><br><span class="line">        <span class="keyword">return</span> wasRemoved;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>세마포어를 이용해 컬렉션의 크기 제한하기</li></ul><h2>5.5.4 배리어</h2><ul><li><p>관문을 만들수 있는 래치는 일회성이다.</p></li><li><p>래치가 한 번 터미널 상태에 다다르면 다시는 이전 상태로 회복할 수 없다.</p></li><li><p><code>배리어 barrier</code>는 특정 이벤트가 발생할 때까지 여러 개의 스레드를 대기 상태로 잡아둘 수 있다는 측면에서 래치와 비슷하다.</p></li><li><p>래치와의 차이점은 모든 스레드가 배리어 위치에 동시에 이르러야 관문이 열리고 계속해서 실행할 수 있다는 점이 다르다.</p></li><li><p>래치는 <code>이벤트</code>를 기다리기 위한 동기화 클래스이다.</p></li><li><p>배리어는 <code>다른 스레드</code>를 기다리기 위한 동기화 클래스이다.</p></li><li><p><code>CyclicBarrier</code> 클래스는 여러 스레드가 특정한 배리어 포인트에서 반복적으로 서로 만나는 기능을 모델링할 수 있다.</p></li><li><p>커다란 문제 하나를 여러 개의 작은 부분 문제로 분리해 반복적으로 병렬 처리하는 알고리즘을 구현할 수 있따.</p></li><li><p>스레드는 각자가 배리어 포인트에 다다르면 await 메소드를 호출하며, await 메소드는 모든 스레드가 배리어 포인트에 도달할 때까지 대기한다.</p></li><li><p>모든 스레드가 배리어 포인트에 도달하면 배리어는 모든 스레드를 통과시키며, await 메소드에서 대기하고 있던 스레드는 대기 상태가 모두 풀려 실행되고, 배리어는 다시 초기상태로 돌아가 다음 배리어 포인트를 준비한다.</p></li><li><p>만약 await을 호출 후 시간이 너무 오래 지나 타임아웃이 걸리거나 await 메소드에서 대기하던 스레드에 인터럽트가 걸리면 배리어는 깨진 것으로 간주하고 await에서 대기하던 모든 스레드에 BrokenBarrierException이 발생한다.</p></li><li><p>배리어가 성공적으로 통과하면 await 메소드는 각 스레드별로 배리어 포인트에 도착한 순서를 알려주며, 다음 배리어 포인트로 반복 작업을 하는동안 뭔가 특별한 작업을 진행할 일종의 리더를 선출하는데 이 값을 사용할 수도 있다.</p></li><li><p>CyclicBarrier는 생성자를 통해 배리어 작업을 넘겨받을 수 있도록 설계되어 있다.</p></li><li><p>배리어 작업은 Runnable 인터페이스를 구현한 클래스이다. 배리어 작업은 배리어가 성공적으로 통과된 이후 대기하던 스레드를 놓아주기 직전에 실행된다.</p></li><li><p><code>배리어는 대부분 실제 작업은 모두 여러 스레드에서 병렬로 처리하고, 다음 단계로 넘어가기 전에 이번 단계에서 계산해야 할 내용을 모두 취합해야 하는 등의 작업이 많이 일어나는 시뮬레이션 알고리즘에서 유용하게 사용할 수 있다.</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CellularAutomata</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Board mainBoard;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Worker[] workers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CellularAutomata</span><span class="params">(Board board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = board;</span><br><span class="line">        <span class="keyword">int</span> count = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="keyword">this</span>.barrier = <span class="keyword">new</span> CyclicBarrier(count,</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        mainBoard.commitNewValues();</span><br><span class="line">                    &#125;&#125;);</span><br><span class="line">        <span class="keyword">this</span>.workers = <span class="keyword">new</span> Worker[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            workers[i] = <span class="keyword">new</span> Worker(mainBoard.getSubBoard(count, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Board board;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Board board)</span> </span>&#123; <span class="keyword">this</span>.board = board; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!board.hasConverged()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; board.getMaxX(); x++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; board.getMaxY(); y++)</span><br><span class="line">                        board.setNewValue(x, y, computeValue(x, y));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException ex) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeValue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Compute the new value that goes in (x,y)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workers.length; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(workers[i]).start();</span><br><span class="line">        mainBoard.waitForConvergence();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Board</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getMaxX</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getMaxY</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">setNewValue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">commitNewValues</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">hasConverged</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">waitForConvergence</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Board <span class="title">getSubBoard</span><span class="params">(<span class="keyword">int</span> numPartitions, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 5장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.5 동기화 클래스&lt;/h1&gt;
&lt;p&gt;블로킹 큐는 다양한 컬렉션 클래스 가운데 특히나 눈에 띄는 특성이 많다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체를 담을 수 있는 컬렉션 클래스&lt;/li&gt;
&lt;li&gt;프로듀서-컨슈머 사이에서 take와 put 등의 블로킹 메소
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="Synchronized" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/Synchronized/"/>
    
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="Synchronized" scheme="http://jungha-cho.github.io/tags/Synchronized/"/>
    
  </entry>
  
  <entry>
    <title>자바병렬프로그래밍_Chapter05_구성단위</title>
    <link href="http://jungha-cho.github.io/2017/05/12/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Chapter05-%EA%B5%AC%EC%84%B1%EB%8B%A8%EC%9C%84/"/>
    <id>http://jungha-cho.github.io/2017/05/12/자바병렬프로그래밍-Chapter05-구성단위/</id>
    <published>2017-05-12T10:14:02.000Z</published>
    <updated>2018-03-26T07:55:35.343Z</updated>
    
    <content type="html"><![CDATA[<h1>자바 병렬 프로그래밍. Chapter 05. 구성 단위</h1><h2>5.1 동기화된 컬렉션 클래스</h2><h3>5.1.1 동기화된 컬렉션의 문제점</h3><ul><li>동기화된 컬렉션을 사용하면 따로 락이나 동기화 기법을 사용하지 않는다 해도 이런 대부분의 기능이 모두 스레드 안전하다.</li><li>하지만 여러 스레드가 해당 컬렉션 하나를 놓고 동시에 그 내용을 변경하려한다면 컬렉션 클래스가 상식적으로 올바른 방법으로 동작하지 않을 수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">  list.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>오동작 할 수 있는 예외</li><li>그럼에도 불구하고 Vector 자체 스레드 안전성에는 문제가 없다.</li><li>위의 예제는 컬렉션을 락으로 사용하면 해결 가능하다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(list) &#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(list) &#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">    list.remove(lastIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>List로 동기화한 코드</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)</span><br><span class="line">  doSomething(vector.get(i));</span><br></pre></td></tr></table></figure><ul><li>ArrayIndexOutBoundsException이 발생할 수 있는 반복문</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)</span><br><span class="line">    doSomething(vector.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>스레드 안전성은 확보할수 있다.</li><li>하지만 for문을 도는 동안에 다른 스레드들이 vector에 접근하지 못한다.</li><li>여러 스레드가 동작하는 병렬 프로그램의 큰 장점은 잃어버린다.</li></ul><h3>5.1.2 Iterator와 ConcurrentModificationException</h3><ul><li>Collection에 들어가 있는 값을 차례로 반복해서 읽어내는 가장 표준적인 방법은 Iterator를 사용하는 것이다.</li><li>하지만 Iterator 또한 같은 시점에 다른 스레드가 컬렉션 클래스 내부의 값을 변경하는 작업을 처리하지 못하게 만들어져 있다.</li><li>대신 <code>즉시 멈춤 fail-fast</code> 방식을 사용한다. 반복 도중 내부의 값 변경이 포착되면 ConcurrentModificationException 예외를 발생시키고 멈추는 방식이다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Widget&gt; widgetList = Collection.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Widjet&gt;&gt;());</span><br><span class="line">......</span><br><span class="line"><span class="comment">// ConcurrentModificationException이 발생할수 있다.</span></span><br><span class="line"><span class="keyword">for</span> (Widget w : widgetList)</span><br><span class="line">  doSomething(w);</span><br></pre></td></tr></table></figure><ul><li>for-each 반복문은 javac로 컴파일할때 내부적으로 Iterator를 사용해 hashNext나 next 메소드를 호출하는 방식으로 바뀐다.</li><li>따라서 반복문을 실행할때 ConccurentModificationException을 방지할 방법은 반복문 전체를 동기화 하는 방법 밖에 없다.</li></ul><p><code>but</code> 반복문을 실행하는 코드 전체를 동기화시키는 방법이 그다지 훌륭하지 못한 방법이라고 주장하는 이유를 살펴볼 필요가 있다.</p><ul><li><p>컬렉션에 엄청나게 많은 수의 값이 들어 있거나 값마다 반복하면서 실행해야 하는 작업이 시간이 많이 소모되는 작업 일수 있다.</p></li><li><p>이 경우 컬렉션 클래스 내부의 값을 사용하고자 하는 스레드가 상당히 오랜 시간 대기 상태에서 기다려야 할 수 있다.</p></li><li><p>또한 반복문에서 락을 잡고 있는 상황에서 다른 락을 확보해야 하는 상황이 벌어지면 <code>데드락 deadlock</code>이 발생할 수 있다.</p></li><li><p><code>소모상태 starvation</code>이나 데드락의 위험이 있는 상태에서 컬렉션 클래스를 오랫동안 막아두면 애플리케이션 전체의 확장성을 해칠 수 있다.</p></li><li><p>반복문에서 락을 오래 잡고 있으면 있을수록 락을 확보하고자 하는 스레드가 대기 상태에 많이 쌓일 수 있고, 대기 상태에 스레드가 적체되면 될수록 CPU 사용량이 급격하게 증가할 가능성이 높다.</p><ul><li>편법 - 반복문을 실행하는 동안 컬렉션 클래스에 들어있는 내용에 락을 걸어둔것과 같은 효과를 내려면 clone 메소드로 복사한 사본을 대상으로 반복문을 사용하면 된다</li><li>물론 최소한 복사 clone을 하는 도중에는 동기화를 사용해야 한다.</li></ul></li></ul><h3>5.1.3. 숨겨진 Iterator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">클래스 내부에서 필요한 변수를 모두 캡슐화하면 그 상태를 보존하기가 훨씬 편리한 것처럼, 동기화 기법을 클래스 내부에 캡슐화하면 동기화 정책을 적용하기가 쉽다.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AntiPattern</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenIterator</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  pirvate <span class="keyword">final</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer i)</span> </span>&#123; set.add(i); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Integer i)</span> </span>&#123; set.remove(i); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTenThings</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      add(r.nextInt());</span><br><span class="line">    System.out.println(<span class="string">"DEBUG: added ten elements to "</span> + set);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>AntiPattern : 문자열 연결 연산 내부에 iterator가 숨겨져 있는 상황.</p></li><li><p>위 예제 뿐만 아니라 toString 메소드, hashCode, equals, containsAll, removeAll, retainAll 등의 메소드도 내부적으로 Iterator를 사용한다. 이러한 모든 메소드에서  ConcurrentModificationException이 발생할 가능성이 있다.</p></li></ul><h2>5.2 병렬 컬렉션</h2><ul><li><p>동기화된 컬렉션 클래스는 내부 변수에 접근하는 통로를 일련화해서 스레드 안전성을 확보했다.</p></li><li><p>하지만 이렇다 보니 여러 스레드가 한번에 동기화된 컬렉션을 사용하려고 하면 동시 사용성은 상당 부분 손해를 볼 수 밖에 없다.</p></li><li><p>하지만 병렬 컬렉션은 여러 스레드에서 동시에 ㅅ용할 수 있도록 설계되어 있다.</p></li><li><p>병렬성을 극대화한 ConcurrentHashMap이 있다. 또 CopyOnWrighteArrayList는 추가되어 잇는 갹체 목록을 반복시키며 열람하는 연산의 성능을 최우선으로 구현한 List 클래스 하위 클래스 이다.</p></li><li><p>또한 ConcurrentMap 인터페이스는 추가하려는 항목이 기존에 없을때만 추가하는 <code>put-if-absent 연산</code>, <code>대치 replace 연산</code>, <code>조건부 제거 conditional remove 연산</code> 등을 정의하고 있다.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">기존에 사용하던 동기화 컬렉션 클래스를 병렬 컬렉션으로 교체하는 것만으로도 별다른 위험 요소 없이 전체적인 성능을 상당히 끌어 올릴 수 있다.</span><br></pre></td></tr></table></figure><ul><li>또한 Queue 인터페이스를 구현하는 여러 종류의 Queue 또한 있다.</li><li>ConcurrentLinkedQueue는 널리 알려져 있는 전통적인 <code>FIFO</code> 큐이고 PriorityQueue는 특정한 우선 순위에 따라 큐에 쌓여 있는 항목이 추출되는 순서가 바뀌는 특성을 갖고 있다.</li><li>BlockingQueue는 큐에 항목을 추가하거나 뽑아낼 때 상황에 따라 대기할 수 있도록 구현되어 있다.</li><li>ConcurrentHashMap 클래스가 해시 기반의 동기화된 Map인것처럼 ConcurrentSkipListMap과 ConcurrentSkipListSet이 있는데 이 둘은 각각 StoredMap과 SortedSet 클래스의 병렬성을 높이도록 발전된 형태이다.</li></ul><h3>5.2.1. ConcurrentHashMap</h3><ul><li>ConcurrentHashMap은 HashMap과 같이 해시를 기반으로 하는 Map이다. 하지만 내부적으로는 이전과 다른 동기화 기법을 적용해 병렬성과 확장성이 훨씬 나아졌다.</li><li>내부적으로 <code>락 스트라이핑 lock striping</code>이라 부르는 굉장히 세밀한 동기화 방법을 사용해 여러 스레드에서 공유하는 상태에 훨씬 잘 대응 할 수 있다.<ul><li>읽기 연산은 많은 수의 스레드라도 동시에 처리할 수 있다.</li><li>읽기와 동시에 쓰기 연산도 수행 가능하다.</li><li>쓰기 연산은 제한된 개수만큼 동시에 수행할 수 있다.</li><li>속도면에서는 여러 스레드가 동시에 동작하는 환경에서 일반적으로 훨씬 높은 성능 결과를 볼 수 있다.</li><li>단일 스레드 환경에서의 단점도 거의 찾아볼 수 없다.</li></ul></li><li>다른 병렬 컬렉션 클래스와 비슷하게 ConcurrentHashMap 클래스도 Iterator를 만들어 내는 부분에서 많이 발전했는데, ConcurrentHashMap이 만들어낸 Iterator는 ConcurrentModificationException을 발생시키지 않는다.</li><li>강해진 병렬성 만큼 조금 약해진 부분도 있다<ul><li>size나 isEmpty의 결과값을 받을 당시에 값이 바뀔수도 있다.<ul><li>추정값이 된다.</li></ul></li></ul></li><li>하지만 핵심 연산인 get, put, containsKey, remove등의 핵심 연산의 병렬성과 성능은 좋다.</li></ul><h3>5.2.2 Map 기반의 또 다른 단일 연산</h3><ul><li>ConcurrentHashMap 클래스는 일반적으로 많이 사용하는 <code>없을 경우 추가하는 put-if-absent</code>, <code>동일한 경우에 제거하는 remove-if-equal</code>, <code>동일한 경우 대치하는 replace-if-equal</code> 연산과 같이 자주 필요한 몇가지 연산이 이미 구현되어 있다.</li><li>만약 이미 구현되어 있지 않은 기능을 사용해야 한다면, ConcurrentHashMap 보다 ConcurrentMap을 사용해 보는 편이 났다.</li></ul><h3>5.2.3 CopyOnWriteArrayList</h3><ul><li>CopyOnWriteArrayList 클래스는 동기화된 List 클래스보다 병렬성을 훨씬 높이고자 만들어졌다. 예를 들어 대부분의 일반적인 용도에 쓰일때 병렬성이 ㅎㅇ상 됐고 특히 List를 복제할 필요가 없다.</li></ul><h2>5.3. BlockingQueue와 Producer-Consumer 패턴</h2><ul><li><p>BlockingQueue는 <code>put</code>과 <code>take</code>라는 핵심 메소드와 <code>offer</code>, <code>poll</code>이라는 메소드를 가지고 있다.</p></li><li><p>put은 큐가 가득차면 공간이 생길때 까지 대기한다.</p></li><li><p>take는 큐가 비어있을때 값이 생길때까지 대기한다.</p></li><li><p>큐와 함께 스레드 풀을 사용하는 경우가 바로 프로듀서-컨슈머 패턴을 활용하는 가장 흔한 경우이다.</p></li><li><p>작업 큐와 스레드 풀을 사용하는 부분은 Excutor 프레임웍을 사용한다.</p></li><li><p>offer 메소드는 큐에 값을 넣을 수 없을 때 대기하지 않고 바로 공간이 모자라 추가할 수 없다는 오류를 알려준다.</p></li><li><p>offer 메소드를 잘 활용하면 프로듀서가 작업을 많이 만들어 과부하에 이르는 상태를 좀더 효과적으로 처리할 수 있다.</p></li><li><p>예를 들어 부하를 분배하거나, 작업할 내용을 <code>직렬화 serialized</code>해서 디스크에 임시로 저장하거나, 아니면 프로듀서 스레드의 수를 동적으로 줄이거나, 기타 여러가지 방법을 사용해 프로듀서가 작업을 생성하는 양을 조절할 수 있다.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">블로킹 큐는 애플리케이션이 안정적으로 동작하도록 만들고자 할 때 요긴하게 사용할 수 있는 도구이다. 블로킹 큐를 사용하면 처리할 수 있는 양보다 훨씬 많은 작업이 생겨 부하가 걸리는 상황에서 작업량을 조절해 애플리케이션이 안정적으로 동작하도록 유도할 수 있다.</span><br></pre></td></tr></table></figure><ul><li><p>자바 클래스 라이브러리에는 BlockingQueue 인터페이스를 구현한 클래스가 몇가지 들어 있다.</p></li><li><p>LinkedBlockingQueue와 ArrayBlockingQueue는 FIFO 형태의 큐이다. 기존 LinkedList나 ArrayList에 대응 된다.</p></li><li><p>PriorityBlockingQueue는 우선 순위를 기준으로 동작하는 큐이다.</p><ul><li>PriorityBlockingQueue는 항목을 정렬 시킬수 있는 Comparable 인터페이스를 구현했다.</li></ul></li><li><p>마지막으로 SynchronousQueue 클래스도 BlockingQueue 인터페이스를 구현한다.</p><ul><li>큐에 항목이 쌓이지 않으며 따라서 큐 내부에 값을 저장할 수 있도록 공간을 할당하지도 않는다.</li><li>대신 큐에 값을 추가하려는 스레드나 값을 읽어가려는 스레드의 큐를 관리한다.</li><li>이처럼 SynchronousQueue는 take나 put을 호출하면 호출한 메소드의 상대편 측에 해당하는 메소드를 다른 스레드가 호출할때까지 대기하고 그 즉시 넘겨준다.</li><li>이처럼 SynchronousQueue는 데이터를 넘겨받을수 있는 스레드가 충분할때 사용하는 편이 좋다.</li></ul><h3>5.3.1. 예제: 데스크탑 검색</h3></li></ul><p>프로듀서-컨슈머 모델을 적용해 볼 수 있는 좋은 프로그램 예제로 데스크탑 검색 프로그램을 들 수 있겠다. 데스크탑 검색 프로그램은 로컬 하드 디스크에 들어 있는 문서를 전부 읽어들이면서 나중에 검색하기 좋게 색인을 만들어 두는 작업을 한다. 많이 알려진 구글 데스크탑 검색이나 윈도우 인덱싱 서비스 등이 이런 일을 하는 프로그램의 대표적인 예이다.</p><h3>5.3.2. 직렬 스레드 한정</h3><p>java.util.concurrent 패키지에 들어있는 블로킹 큐 관련 클래스는 모두 프로듀서 스레드에서 객체를 가져와 컨슈머 스레드에 넘겨주는 과정이 세심하게 동기화 되어 있다.</p><p>프로듀서-컨슈머 패턴과 블로킹 큐는 <code>가변 객체 mutable object</code>를 사용할 때 객체의 소유권을 프로듀서에서 컨슈머로 넘기는 과정에서 <code>직렬 스레드 한정 serial thread confinement</code> 기법을 사용한다.</p><p>스레드에 한정된 객체는 특정 스레드 하나만이 소유권을 가질 수 있는데, 객체를 안전한 방법으로 공개하면 객체에 대한 소유권을 <code>이전 transfer</code>할 수 있다.</p><ul><li><p><code>객체 풀 object pool</code>은 직렬 스레드 한정 기법을 잘 활용한 예이다.</p></li><li><p>풀에서 소유하고 있던 객체를 외부 스레드에게 <code>빌려주는</code> 일이 본업이기 때문이다.</p></li><li><p>가변 객체의 소유권을 이전해야 할 필요가 있다면, 위에서 설명한 것과 다른 객체 공개 방법을 사용할 수도 있다. 하지만 항상 소유권을 이전받는 스레드는 단 하나여야 한다는 점을 주의하자.</p></li><li><p>블로킹 큐를 사용하면 이런 점을 정확하게 지킬 수 있다.</p></li><li><p>덧붙여 ConcurrentMap의 remove 메소드를 사용하거나 AtomicReference의 compareAndSet 메소드를 사용하는 경우에도 약간의 추가 작업만 해준다면 원활하게 처리할 수 있다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCrawler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;File&gt; fileQueue;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FileFilter fileFilter;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> File root;</span><br><span class="line">  ....</span><br><span class="line">  ....</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      crawl(root);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">crawl</span><span class="params">(File root)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    File[] entries = root.listFiles(fileFilter);</span><br><span class="line">    <span class="keyword">if</span>(entries != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(File entry : entries)</span><br><span class="line">        <span class="keyword">if</span>(entry.isDirectory())</span><br><span class="line">          crawl(entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!alreadyIndexed(entry))</span><br><span class="line">          fileQueue.put(entry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Indexer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;File&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Indexer</span><span class="params">(BlockingQueue&lt;File&gt; queue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">          indexFile(queue.take());</span><br><span class="line">      &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>프로듀서-컨슈머 패턴을 활용한 데스크탑 검색 애플리케이션 구조</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startIndexing</span><span class="params">(File[] roots)</span> </span>&#123;</span><br><span class="line">  BlockingQueue&lt;File&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;File&gt;(BOUND);</span><br><span class="line">  FileFilter filter = <span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(File root : roots)</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> FileCrawler(queue, filter, root)).start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N_CONSUMERS; i++)</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Indexer(queue)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>5.3.3. 덱, 작업 가로채기</h3><ul><li><code>Deque('덱'이라고 읽는다)</code>과 BlockingDeque</li><li>Deque과 BlockingDeque는 각각 Queue와 BlockingQueue를 상속받은 인터페이스이다.</li><li>Deque는 앞과 뒤 어느 쪽에서도 객체를 쉽게 삽입하거나 제거할 수 있도록 준비된 큐이다.</li><li>Deque를 상속받은 클래스는 ArrayDeque과 LinkedBlockingDeque가 있다.</li></ul><h4>deque 덱</h4><ul><li><p><code>작업 가로채기 work stealing</code> 패턴은 덱을 그대로 가져다 사용할 수 있다.</p></li><li><p>프로듀서-컨슈머 패턴에서는 모든 컨슈머가 하나의 큐를 공유해 사용한다.</p></li><li><p>하지만 작업 가로채기 패턴에서는 모든 컨슈머가 각자의 덱을 갖는다.</p></li><li><p>만약 특정 컨슈머가 자신의 덱에 들어있던 작업을 모두 처리하고 나면 다른 컨슈머의 덱에 쌓여있는 작업 가운데 맨 뒤 추가된 작업을 가로채 가져올 수 있다.</p></li><li><p><code>작업 가로채기의 특성상 컨슈머가 하나의 큐를 바라보면서 서로 작업을 가져가려고 경쟁하지 않기 때문에 일반적인 프로듀서-컨슈머 패턴보다 규모가 큰 시스템을 구현하기에 적당하다.</code></p></li><li><p><code>컨슈머가 다른 컨슈머의 큐에서 작업을 가져올때 맨 뒤의 작업을 가져오기 때문에 맨 앞의 작업을 가져가려하는 원 소유자와 경쟁이 일어나지 않는다.</code></p></li><li><p><code>작업 가로채기 패턴은 컨슈머가 프로듀서의 역할도 갖고 있는 경우에 적용하기 좋다.</code></p></li><li><p><code>스레드가 작업을 진행하는 도중에 새로 처리해야 할 작업이 생기면 자신의 덱에 새로운 작업을 추가한다.(작업을 서로 공유하도록 구성하는 경우에는 다른 작업 스레드의 덱에 추가하기도 한다.).</code></p></li><li><p><code>만약 자신의 덱이 비었다면 다른 작업 스레드의 덱을 살펴보고 밀린 작업이 있다면 가져다가 처리해 자신의 덱이 비었다고 쉬는 스레드가 없도록 관리한다.</code></p></li></ul><h2>5.4 블로킹 메소드, 인터럽터블 메소드</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">스레드는 여러가지 원인에 의해 블록 당하거나, 멈춰질 수 있다.</span><br><span class="line">1. I/O 작업이 끝나기를 기다릴 수 있다.</span><br><span class="line">2. 락을 확보하기 위해 기다릴 수 있다.</span><br><span class="line">3. Thread.Sleep 메소드가 끝나기를 기다릴 수 있다.</span><br><span class="line">4. 다른 스레드가 작업 중인 내용의 결과를 확인하기 위해 기다리는 경우도 있다.</span><br><span class="line">5. 스레드가 블록되면 동작이 멈춰진 다음 블록된 상태(BLOCKED, WAITING, TIMED_WAITING) 가운데 하나를 갖게된다.</span><br></pre></td></tr></table></figure><ul><li><code>호출하려는 메소드 가운데 InterruptedExceptuon이 발생할 수 있는 메소드가 있다면 그 메소드를 호출하는 메소드 역시 블로킹 메소드이다. 따라서 InterruptedException이 발생했을 때 그에 대처할 수 있는 방법을 마련해둬야 한다.</code></li><li>일반적으로 라이브러리 형태의 코드라면 두가지를 사용해 볼 수 있다.</li></ul><ol><li>InterruptedException을 전달 : 받아낸 InterruptedException을 그대로 호출한 메소드에 넘긴다. 받은 메소드는 catch로 잡지 않거나 cat로 잡은 다음 정리 작업을 진행하고 throw로 다시 던지는 방법도 있다.</li><li>인터럽트를 무시하고 복구: 특정 상황에서는 InterruptedException을 throw할 수 없을 수도 있는데, 예를 들어 Runnable 인터페이스를 구현한 경우이다.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  BlockingQueue&lt;Task&gt; queue;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      processTask(queue.take());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// 인터럽트가 발생한 사실을 저장한다.</span></span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>인터럽트가 발생했음을 저장해 인터럽트 상황을 잊지 않아야 한다.</li></ul><blockquote><p>인터럽트를 잘 활용하면 훨씬 세밀하게 고급 기능을 구현할 수 있지만, 위의 두가지 방법을 사용하면 대부분의 경우 대응할 수 있다.</p><blockquote><p>AntiPattern : InterruptedException을 catch 하고 아무것도 하지 않은 일은 하지 말자.</p></blockquote></blockquote><ul><li>발생한 InterruptedException을 먹어버리고 더 이상 전파하지 않을 수 있는 경우는 Thread 클래스를 직접 상속하는 경우뿐이다.</li></ul><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 5장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;자바 병렬 프로그래밍. Chapter 05. 구성 단위&lt;/h1&gt;
&lt;h2&gt;5.1 동기화된 컬렉션 클래스&lt;/h2&gt;
&lt;h3&gt;5.1.1 동기화된 컬렉션의 문제점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;동기화된 컬렉션을 사용하면 따로 락이나 동기화 기법을 사용하지 않
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="Synchronized" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/Synchronized/"/>
    
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="Synchronized" scheme="http://jungha-cho.github.io/tags/Synchronized/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Java-규칙18_추상_클래스_대신_인터페이스를_사용하라</title>
    <link href="http://jungha-cho.github.io/2017/05/11/Effective-Java-%EA%B7%9C%EC%B9%9918-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%8C%80%EC%8B%A0-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/"/>
    <id>http://jungha-cho.github.io/2017/05/11/Effective-Java-규칙18-추상-클래스-대신-인터페이스를-사용하라/</id>
    <published>2017-05-11T12:10:13.000Z</published>
    <updated>2018-03-26T07:55:19.976Z</updated>
    
    <content type="html"><![CDATA[<h1>규칙 18. 추상 클래스 대신 인터페이스를 사용하라</h1><h3>추상 클래스와 인터페이스의 차이</h3><ol><li>추상 클래스는 구현된 메서드를 포함할 수 있지만 인터페이스는 아니다.</li><li>추상 클래스가 규정하는 자료형을 구현하기 위해서는 추상 클래스를 반드시 계승해야 한다.</li><li>인터페이스는 포함된 모든 메서드를 정의하고 인터페이스가 규정하는 일반 규약을 지키기만 하면 되고, 그렇게 만든 클래스는 상속관계에 속할 필요가 없다.</li><li>자바는 다중 상속을 허용하지 않기 때문에, 추상 클래스를 사용하게 되면 자료형으로 사용하는데 많은 제약이 발생하게 된다.</li></ol><p>이펙트 1. <code>이미 있는 클래스를 개조해서 새로운 인터페이스를 구현하도록 하는 것은 간단하다.</code><br>이펙트 2. <code>인터페이스는 믹스인(mixin)을 정의하는 데 이상적이다.</code><br>믹스인은 클래스가 주 자료형 이외에 추가로 구현할 수 있는 자료형으로, 어떤 선택적 기능을 제공한다는 사실을 선언하기 위해 쓰인다.<br>예를 들어 Comparable은 어떤 클래스가 자기 객체는 다른 객체와 비교 결과에 따른 순서를 갖는다고 선언할 떄 쓰는 믹스인 인터페이스다.</p><ul><li>이런 인터페이스를 믹스인이라고 하는 이유는 자료형의 주된 기능에 선택적인 기능을 <code>혼합</code>할 수 있도록 하기 때문이다.</li><li>추상 클래스는 믹스인 정의에는 사용할 수 없다. 클래스가 가질 수 있는 상위 클래스는 하나뿐이며, 클래스 계층에는 믹스인을 넣기 좋은 곳이 없다.</li></ul><p>이펙트 3. <code>인터페이스는 비 계층적(nonhierarchical)인 자료형 프레임워크(type frame-work)를 만들 수 있도록 한다.</code></p><ul><li>어떤 것들은 자료형 계층(type hierarchy)으로 잘 정리되지만, 계층 안에 잘 들어맞지 않는 것들도 있다. 예를 들어, 가수를 표현하는 인터페이스와 작곡가를 표현하는 인터페이스가 있다고 해보자.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Singer</span> </span>&#123;</span><br><span class="line">  <span class="function">AudioClip <span class="title">sing</span><span class="params">(Song s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Songwriter</span> </span>&#123;</span><br><span class="line">  <span class="function">Song <span class="title">compose</span><span class="params">(<span class="keyword">boolean</span> hit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그런데 가수 가운데는 작곡가인 사람도 있다. 추상 클래스 대신 인터페이스를 사용해 자료형을 만들었으므로, 아무런 문법적 문제 없이 Singer와 Songwriter를 동시에 구현하는 클래스를 만들 수 있따.</p><p>또 Singer와 Songwriter를 확장한 또 다른 인터페이스를 추가할 수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingerSongwriter</span> <span class="keyword">extends</span> <span class="title">Singer</span>, <span class="title">Songwriter</span> </span>&#123;</span><br><span class="line">  <span class="function">AudioClip <span class="title">strum</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">actSensitive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이펙트 4. <code>인터페이스를 사용하면 포장 클래스 숙어(wrapper class idiom)을 통해(규칙 16) 안전하면서도 강력한 기능 개선이 가능하다.</code></p><ul><li><p>추상 클래스를 사용해 자료형을 정의하면 프로그래머는 계승 이외의 수단을 사용할 수 없다. 그렇게 해서 만든 클래스는 포장 클래스보다 강력하지도 않고, 깨지기도 쉽다.</p></li><li><p>인터페이스 안에는 메서드 구현을 둘 수 없지만, 그렇다고 프로그래머가 사용할 수 있는 코드를 제공할 방법이 없는 것은 아니다.</p></li></ul><p>이펙트 5. <code>추상 골격 구현(abstract skeletal implementation) 클래스를 중요 인터페이스마다 두면, 인터페이스 장점과 추상 클래스의 장점을 결합할 수 있다.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 골격 구현 위에서 만들어진 완전한 List 구현</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title">intArrayAsList</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointException();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> AbstractList&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a[i]; <span class="comment">// 자동 객체화 (규칙 5)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Integer <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, Integer val)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> oldVal = a[i];</span><br><span class="line">      a[i] = val; <span class="comment">// 자동 비객체화</span></span><br><span class="line">      <span class="keyword">return</span> oldVal; <span class="comment">// 자동 객체화</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a.length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>이미 존재하는 List 구현체가 어떤 일을 할 수 있을지 잘 보여주는 예제이다. 골격 구현의 강력함을 아주 잘 보여준다.</li><li>int 배열을 Integer 객체의 리스트처럼 볼 수 있도록 하는 어댑터(Adapter) 패턴 적용 사례이기도 하다.</li><li>int 값과 Integer 객체 사이의 자동 객체화 변환 과정 때문에 성능은 좋지 않다.</li><li>정적 팩터리 메서드를 통해 반환되는 객체의 클래스가 정적 팩터리 안에 숨겨진, 외부에서 접근이 불가능한 <code>익명 클래스</code>라는 점에 주의하라.</li></ul><p>골격 구현 클래스를 만드는 작업은 상대적으로 멍청해 보일 수도 있는 단순한 작업이다.</p><p>Map.entry 인터페이스에 대한 골격 구현 클래스</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 골격 구현</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMapEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 기본 primitive 메서드</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 변경 가능 맵에 들어갈 Entry는 이 메서드를 재정의해야 한다.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Map.Entry.equals의 일반 규약 구현</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Map.Entry&lt;?, ?&gt; arg = (Map.Entry) o;</span><br><span class="line">    <span class="keyword">return</span> equals(getKey(), arg.getKey()) &amp;&amp; equals(getValue(), arg.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Obejct o1, Object o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1 == <span class="keyword">null</span> ? o2 == <span class="keyword">null</span> : o1.equals(o2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Map.Entry.hashCode의 일반 규약</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hashCode(getKey()) ^ hashCode(getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="keyword">null</span> ? <span class="number">0</span> : obj.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;규칙 18. 추상 클래스 대신 인터페이스를 사용하라&lt;/h1&gt;
&lt;h3&gt;추상 클래스와 인터페이스의 차이&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;추상 클래스는 구현된 메서드를 포함할 수 있지만 인터페이스는 아니다.&lt;/li&gt;
&lt;li&gt;추상 클래스가 규정하는 자료형을 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Interface" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/Interface/"/>
    
    
      <category term="Interface" scheme="http://jungha-cho.github.io/tags/Interface/"/>
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/tags/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
  </entry>
  
  <entry>
    <title>Executor란?-기초</title>
    <link href="http://jungha-cho.github.io/2017/05/10/Executor%EB%9E%80-%EA%B8%B0%EC%B4%88/"/>
    <id>http://jungha-cho.github.io/2017/05/10/Executor란-기초/</id>
    <published>2017-05-10T13:30:39.000Z</published>
    <updated>2018-03-26T07:54:56.923Z</updated>
    
    <content type="html"><![CDATA[<h3>Executor란?</h3><p>Thread, Runnable, asyncTask만 쓰면서 병렬 프로그래밍을 한다!! 외차다가 조금 더 효율적이고 효과적인 방법들을 찾아나섰다. 와중에 Executor FrameWork를 이용해서 스레드 프레임을 짜볼려서 공부중인데, Callable, Future, Callback 등등 쓰는법 사용하는법 다 알겠다. 다 알겠는데 대체 Executor라는 놈이 뭘까? 라는 생각이 들어서 파헤쳐 보기로 했다.</p><p>사전적 뜻 부터 찾아보자.</p><ul><li>Executor : 실행 하는 놈, 집행자, 실행자라고 보면 된다.</li><li>Callable : 여러 뜻이 있겠지만 단편적으로 부를수 있다. 라고 생각하자</li><li>Callback : 비동기 관점에서, A가 B를 불렀는데 B가 없다. A는 자기 할일을 하는데 B가 오니까 누가 알려주는거.</li><li>Future : 미래의 값을 받아볼수 있다? - Thread의 결과값을 받아볼 수 있게 해주는 클래스라고 생각하자.</li></ul><h3>더 파보자</h3><p><img src="/images/executor-framework-interfaces.png" alt="executor-fw-interface"></p><ul><li><p>Executor Frame Workd 전체 Interface 구성도 이다.</p></li><li><p>괜히 봤다.</p></li><li><p>더 모르겠다.</p></li><li><p>각설하고 Interface 내에서도 상속 관계가 이어지는 모습을 봤을때 부모가 중요한 것 같다.</p></li><li><p>Executor, Callable, Future, Runnable 등 Prefix, Postfix에 붙는걸 보았을때 나머지 이름이 해당 인터페이스와 이를 상속받는 클래스들이 하는 일들을 정리해 줄것이다.</p></li></ul><h3>이글의 핵심인 Executor를 또 더 파보자</h3><p><img src="/images/executor-framework-classes.png" alt="executor-framework-classes"></p><ul><li>Javadoc에서는 Executor를 Runnable이나 Thread를 실행시켜주는 <code>집행자</code>라고 정의하고 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for each of a set of tasks, you might use:</span></span><br><span class="line">Thread(<span class="keyword">new</span>(RunnableTask())).start()</span><br><span class="line"></span><br><span class="line"><span class="comment">//각각 태스크를 직접 실행하는 대신에</span></span><br><span class="line"><span class="comment">//Executor에게 실행하라고 태스크를 넘겨주라고 한다.</span></span><br><span class="line">Executor executor = anExecutor;</span><br><span class="line">executor.execute(<span class="keyword">new</span> RunnableTask1());</span><br><span class="line">executor.execute(<span class="keyword">new</span> RunnableTask2());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executor를 구현해서</span></span><br><span class="line"><span class="comment">// 유일한 메소드인 execute로 실행해도 된다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 또는 이런식으로 execute안에서도</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 또는 이렇게 내가 작업하고 싶은 작업 내용들을</span></span><br><span class="line"><span class="comment">// 비동기적으로...</span></span><br><span class="line"><span class="comment">// 이게 뭐지!?</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Queue&lt;Runnable&gt; tasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">  <span class="keyword">final</span> Executor executor;</span><br><span class="line">  Runnable active;</span><br><span class="line"></span><br><span class="line">  SerialExecutor(Executor executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">    tasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          r.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">      scheduleNext();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((active = tasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      executor.execute(active);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>하아… 그러니까 어디보자…</li><li>Executor는 비동기 실행자이다.</li><li>task를 할당하는 순서대로 보장받지 못한다.</li><li>그래서 SerialExecutor로 구현하면 Executor를 이용해서 순서를 보장받을 수 있다.</li><li>음… 왜 이래야 할까요…?</li></ul><h3>봐도 봐도 Executor의 존재 이유를 모르겠다.</h3><ul><li>얼핏, 비동기 실행을 위한 분리 구현?</li><li>음…</li></ul><h3>붙잡고 있지 말고 ExecutorService로 가보자</h3><ul><li>하나 이상의 비동기 태스크 추적을 위한 Future를 생성할 수 있는 Executor…</li><li>음… 구조적이고 체계적인 그러니까…</li><li>Executor는 Task와 Thread를 분리하고, Thread에 Task를 할당해서 비동기적으로 실행이 가능하게 만들어 주는 거로구만…</li><li>음…</li></ul><h3>더 모르겠다. 코드를 보자!!</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = Executors.newFixedThreadPool();</span><br><span class="line">ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">ExecutorService es = Executors.newScheduledThreadPool();</span><br></pre></td></tr></table></figure><ul><li><p>ExecutorService는 위와같은 방법들로 생성이 가능하다.</p></li><li><p>각각의 Executors.*(); 의 인자값에 적절한 값을 넣어주면 다음과 같은 특징으로 ExecutorService가 동작한다.</p></li><li><p>순서대로<br>// 초기 스레드 수 = 0, 코어 스레드 수 = n, 최대 스레드 수 = n<br>// 초기 스레드 수 = 0, 코어 스레드 수 = 0, 최대 스레드 수 = Integer.MAX_VALUE<br>// 단일 스레드, 작업 중 Exception 발생시 새로운 스레드 생성<br>// 특정 시간에 동작시킬 수 있는 스레드</p></li><li><p>각 인자값과 예제는 여러 IT 블로그들에서 찾아볼 수 있다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017-05-10.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : ver 1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> : cho_jeong_ha</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- 작업의 실행과 종료</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- ExecutorService 객체를 생성할때 쓰레드 풀 관리 방식과 스레드 갯수를 정할수 있다.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * newFixedThreadPool       : 초기 스레드 수 = 0, 코어 스레드 수 = n, 최대 스레드 수 = n</span></span><br><span class="line"><span class="comment"> * newCachedThreadPool      : 초기 스레드 수 = 0, 코어 스레드 수 = 0, 최대 스레드 수 = Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> * newSingleThreadExecutor  : 단일 스레드, 작업 중 Exception 발생시 새로운 스레드 생성</span></span><br><span class="line"><span class="comment"> * newScheduledThreadPool   : 일정 시간에 동작시킬 수 있는 스레드</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- 쓰레드의 종료</span></span><br><span class="line"><span class="comment"> * void shutdown()          : 현재 처리 중인 작업뿐만아니라 작업 큐에 대기하고 있는 모든 작업을 처리한 뒤에 스레드 풀을 종료시킨다.</span></span><br><span class="line"><span class="comment"> * List&lt;Runnable&gt;           : 현재 작업 처리 중인 스레드를 interrupt해서 작업 중지를 시도하고 스레드 풀을 종료시킨다.</span></span><br><span class="line"><span class="comment"> *                            리턴값은 작업 큐에 있는 미처리된 작업의 목록이다.</span></span><br><span class="line"><span class="comment"> * boolean awaitTermination(long timeout, TimeUnit unit)</span></span><br><span class="line"><span class="comment"> *                          : shutdown 메소드 호출 이후, 모든 작업 처리를 timeout 시간내에 완료하면 true를 리턴하고,</span></span><br><span class="line"><span class="comment"> *                            완료하지 못하면 작업 처리 중인 스레드를 interrupt하고 false를 리턴한다.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorServiceExample_1_ExcutorService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// No Parameter</span></span><br><span class="line">  <span class="keyword">static</span> ExecutorService es1 = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CPU 코어 수의 최대 쓰레드 생성</span></span><br><span class="line">  <span class="keyword">static</span> ExecutorService es2 =</span><br><span class="line">      Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 스레드의 종료</span></span><br><span class="line">    es1.shutdown();</span><br><span class="line">    es1.shutdownNow();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      es2.awaitTermination(<span class="number">5</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>공부하면서 만들어본 예제.</li><li>내일은 Callable과 Future를…</li><li>근데 아직도 Executor가 뭔지 잘 모르겠다…</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Executor란?&lt;/h3&gt;
&lt;p&gt;Thread, Runnable, asyncTask만 쓰면서 병렬 프로그래밍을 한다!! 외차다가 조금 더 효율적이고 효과적인 방법들을 찾아나섰다. 와중에 Executor FrameWork를 이용해서 스레드 프레임
      
    
    </summary>
    
      <category term="Java" scheme="http://jungha-cho.github.io/categories/Java/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Java/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="Java" scheme="http://jungha-cho.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>자바병렬프로그래밍-챕터4-객체구성</title>
    <link href="http://jungha-cho.github.io/2017/05/10/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%B1%95%ED%84%B04-%EA%B0%9D%EC%B2%B4%EA%B5%AC%EC%84%B1/"/>
    <id>http://jungha-cho.github.io/2017/05/10/자바병렬프로그래밍-챕터4-객체구성/</id>
    <published>2017-05-09T17:26:43.000Z</published>
    <updated>2018-03-26T07:54:43.711Z</updated>
    
    <content type="html"><![CDATA[<h3>Chapter 4 객체 구성 이어서…</h3><h3>차량 위치 추적</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Point&gt; location = vehicles.getLocation();</span><br><span class="line"><span class="keyword">for</span> (String key : locations.keySet())</span><br><span class="line">  renderVehicle(key, locations.get(key));</span><br></pre></td></tr></table></figure><p>이와 유사하게 업데이터 스레드는 차량에 장착된 GPS 장치에서 읽어낸 위치 정보를 자동으로 입력하거나, GUI 화면에서 수동으로 입력한 내용을 새로운 위치 정보로 업데이트한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vehicleMoved</span><span class="params">(VehicleMovedEvent evt)</span> </span>&#123;</span><br><span class="line">  Point loc = evt.getNewLocation();</span><br><span class="line">  vehicles.setLocation(evt.getVehicleId(), loc.x, loc.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 구조라면 뷰 스레드와 업데이터 스레드가 동시 다발적으로 데이터 모델을 사용하기 때문에 데이터 모델에 해당하는 클래스는 반드시 스레드 안전성을 확보하고 있어야만 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorVehicleTracker</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, MutablePoint&gt; locations;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MonitorVehicleTracker</span><span class="params">(Map&lt;String, MutablePoint&gt; locations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.locations = deepCopy(locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Map&lt;String, MutablePoint&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deepCopy(locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> MutablePoint <span class="title">getLocation</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        MutablePoint loc = locations.get(id);</span><br><span class="line">        <span class="keyword">return</span> loc == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> MutablePoint(loc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        MutablePoint loc = locations.get(id);</span><br><span class="line">        <span class="keyword">if</span> (loc == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No such ID: "</span> + id);</span><br><span class="line">        loc.x = x;</span><br><span class="line">        loc.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, MutablePoint&gt; <span class="title">deepCopy</span><span class="params">(Map&lt;String, MutablePoint&gt; m)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, MutablePoint&gt; result = <span class="keyword">new</span> HashMap&lt;String, MutablePoint&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String id : m.keySet())</span><br><span class="line">            result.put(id, <span class="keyword">new</span> MutablePoint(m.get(id)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위 클래스는 차량 위치를 담는 MutablePoint 클래스를 활용해 자바 모니터 패턴에 맞춰 만들어진 차량 추적 클래스가 나타나 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePoint</span><span class="params">(MutablePoint p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = p.x;</span><br><span class="line">        <span class="keyword">this</span>.y = p.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위 클래스 MutablePoint는 클래스가 스레드 안전하지 않지만 차량 추적 클래스는 스레드 안전성을 확보하고 있다. 위치를 담는 location 변수나 위치를 나타내는 Point 인스턴스 모두 외부에 전혀 공개되고 있지 않았다.</li><li>차량의 위치를 알고싶어하는 클라이언트 프로그램에게 위치를 넘겨줄 때는 MutablePoint 클래스의 생성자를 통해 MutablePoint의 복사본을 만들거나 deepCopy 메소드를 사용해 완전히 새로운 locations 인스턴스 복사본을 만들어 넘겨준다.</li><li>deepCopy는 원래 Map 인스턴스에 Map 인스턴스 뿐만 아니라 그 안에 들어 있는 키와 값도 모두 복사해 완전히 새로운 인스턴스를 만든다.</li><li>단순하게 Map 인스턴스를 Collection 클래스의 unmodifiableMap 메소드로 감싸는 것으로는 deepCopy의 기능을 다 하지 못하는데, UnmodificableMap은 컬렉션 자체만 변경할 수 없게 막아주며 그 안에 보관하고 있는 객체의 내용을 손대는 것은 막지 못하기 때문이다. HashMap의 생성자에 HashMap을 넘겨 복사하는 기능도 앞서 설명한 것과 동일하게, 즉 위치를 나타내는 Point 값을 복사하는 것이 아니라 point를 가리키는 참조를 복사하기 때문에 올바른 결과를 얻을 수 없다.</li><li>외부에서 변경 가능한 데이터를 요청할 경우 그에 대한 복사본을 넘겨주는 방법을 사용하면 스레드 안전성을 부분적이나마 확보할 수 있다. 일반적인 경우라면 그다지 문제가 되지 않지만, 차량 추적 예제의 경우 추적하는 차량의 대수가 굉장히 많아진다면 성능에 문제가 발생할 수 있다.</li></ul><h3>4.3 스레드 안전성 위임</h3><ul><li>스레드 안전성을 확보한 객체를 조합해 만든 객체는 스레드에 안전한 객체일까?</li><li><code>상황에 따라 다르다.</code>가 정답이다. 스레드에 안전한 객체를 모아 만든 객체는 스레드에 안전할 수도 있고 조금더 나은 출발점일 수 있다.</li><li>앞서 살펴 봤던 CountingFactorizer 클래스의 상태는 스레드 안전한 AtomicLong 클래스의 상태와 같다.</li><li>CountingFactorizer 클래스를 표현하는 상태값은 AtomicLong 하나이기 때문이다. 또 AtomicLong에 보관하는 카운트 값에 아무런 제한 조건이 없기 때문이다.</li><li>이런 경우 CountingFactorizer는 스레드 안전성 문제를 AtomicLong 클래스에게 <code>위임 delegate</code>한다고 하며, AtomicLong 클래스가 스레드에 안전하기 때문에 AtomicLong에게 스레드 안전성을 위임했던 Counting Factorizer 역시 스레드에 안전하다.</li></ul><h3>4.3.1 예제: 위임 기법을 활용한 차량 추적</h3><ul><li>먼저 Point 클래스를 <code>immutable</code>하게 만들자.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>값을 변경할 수 없는 Point 객체, Point 클래스는 불변이기 떄문에 스레드 안전하다. 불변의 값은 얼마든지 마음대로 안전하게 공유하고 외부에 공개할 수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingVehicleTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Point&gt; locations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Point&gt; unmodifiableMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegatingVehicleTracker</span><span class="params">(Map&lt;String, Point&gt; points)</span> </span>&#123;</span><br><span class="line">        locations = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Point&gt;(points);</span><br><span class="line">        unmodifiableMap = Collections.unmodifiableMap(locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Point&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unmodifiableMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getLocation</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> locations.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (locations.replace(id, <span class="keyword">new</span> Point(x, y)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid vehicle name: "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Alternate version of getLocations (Listing 4.8)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Point&gt; <span class="title">getLocationsAsStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(</span><br><span class="line">                <span class="keyword">new</span> HashMap&lt;String, Point&gt;(locations));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>스레드 안전성을 ConcurrentHashMap 클래스에 위임한 추적 프로그램</li><li>위 DelegatingVehicleTracker 예제에서는 별다른 동기화 흔적이 없다.</li><li>모든 동기화 작업은 ConcurrentHashMap에서 담당하고, Map에 들어 있는 모든 값은 불변 상태이다.</li><li>앞서 소개했던 모니터 적용 버전은 현재 시점의 차량 위치 전부의 고정된 스냅샷을 알려줬다.</li><li>위임 기능을 적용한 버전은 언제든지 가장 최신의 차량 위치를 실시간으로 학인할 수 있는 동적인 데이터를 넘겨준다.</li><li>특정 시점의 차량 고정 위치 데이터를 갖고 싶다면 getLocations 메소드에서 locations 변수에 들어있는 Map 클래스에 대한 단순 복사본을 넘겨줄 수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Point&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Collections.unmodifiableMap(<span class="keyword">new</span> HashMap&lt;String, Point&gt;(locations));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>4.3.2 독립 상태 변수</h3><ul><li>지금까지 모두 스레드 안전한 변수 하나에만 스레드 안전성을 위임했다.</li><li>위임하고자 하는 내부 변수가 두개 이상이라 해도 두 개 이상의 변수가 서로 <code>독립적</code>이라면 클래스의 스레드 안전성을 위임할 수 있다.</li><li><code>독립적</code>이라 함은 변수가 서로의 상태 값에 대한 연관성이 없다는 말이다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisualComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;KeyListener&gt; keyListeners</span><br><span class="line">            = <span class="keyword">new</span> CopyOnWriteArrayList&lt;KeyListener&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MouseListener&gt; mouseListeners</span><br><span class="line">            = <span class="keyword">new</span> CopyOnWriteArrayList&lt;MouseListener&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addKeyListener</span><span class="params">(KeyListener listener)</span> </span>&#123;</span><br><span class="line">        keyListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMouseListener</span><span class="params">(MouseListener listener)</span> </span>&#123;</span><br><span class="line">        mouseListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKeyListener</span><span class="params">(KeyListener listener)</span> </span>&#123;</span><br><span class="line">        keyListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMouseListener</span><span class="params">(MouseListener listener)</span> </span>&#123;</span><br><span class="line">        mouseListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>VisualComponent 클래스는 클라이언트가 마우스와 키보드 이벤트를 처리하는 리스너를 등록할 수 있는 화면 컴포넌트이다. VisualComponent는 각 종류별로 등록된 이벤트 리스너를 호출하는 기능을 갖고 있다. 내부적으로 보면 마우스 이벤트 리스너를 관리하는 목록 변수와 키보드 이벤트를 관리하는 목록 변수는 서로 아무런 연관이 없으므로 서로 독립적이다.</li><li>리스너 이벤트 목록을 <code>CopyOnWriteArrayList</code> 클래스에 보관한다.  CopyOnWriteArrayList는 리스너 목록을 관리하기에 적당하게 만들어져 있는 스레드 안전한 List 클래스이다.</li><li>위 두가지 리스트는 각각 스레드 안전성을 확보하고 있고 두 개의 변수를 서로 연동시켜 묶어주는 상태가 전혀 없기 때문에 VisualComponent는 스레드 안전성이라는 책임을 <code>mouseListeners</code>와 <code>keyListeners</code> 변수에게 완전히 위임할 수 있다.</li></ul><h3>4.3.3 위임할 때의 문제점</h3><p>물론 위 VisualCompoenet 처럼 간단하게 구성되어 있는 클래스는 거의 없다. 거의 모든 클래스에서 내부 변수들이 상태 변수 간에 의존성을 가지고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberRange</span> </span>&#123;</span><br><span class="line">    <span class="comment">// INVARIANT: lower &lt;= upper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger lower = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger upper = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Warning -- unsafe check-then-act</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; upper.get())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"can't set lower to "</span> + i + <span class="string">" &gt; upper"</span>);</span><br><span class="line">        lower.set(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Warning -- unsafe check-then-act</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; lower.get())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"can't set upper to "</span> + i + <span class="string">" &lt; lower"</span>);</span><br><span class="line">        upper.set(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInRange</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &gt;= lower.get() &amp;&amp; i &lt;= upper.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>클래스가 서로 의존성 없이 독립적이고 스레드 안전한 두 개 이상의 클래스를 조합해 만들어져 있고 두 개 이상의 클래스를 한번에 처리하는 복합 연산 메소드가 없는 상태라면, 스레드 안전성을 내부 변수에게 모두 위임할 수 있다.</p></blockquote><h3>4.3.4 내부 상태 변수를 외부에 공개</h3><blockquote><p>상태 변수가 스레드 안전하고, 클래스 내부에서 상태 변수의 값에 대한 의존성을 갖고 있지 않고, 상태 변수에 대한 어떤 연산을 수행하더라도 잘못된 상태에 이를 가능성이 없다면, 해당 변수는 외부에 공개해도 안전하다.</p></blockquote><h3>4.3.5 예제: 차량 추적 프로그램의 상태를 외부에 공개</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafePoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafePoint</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafePoint</span><span class="params">(SafePoint p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(p.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafePoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>x, y의 set과 get을 따로둔다면 x,y를 갖고올때 x는 바뀐값을 y는 바뀌지 않은 값을 가져올 수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublishingVehicleTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SafePoint&gt; locations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SafePoint&gt; unmodifiableMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PublishingVehicleTracker</span><span class="params">(Map&lt;String, SafePoint&gt; locations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.locations = <span class="keyword">new</span> ConcurrentHashMap&lt;String, SafePoint&gt;(locations);</span><br><span class="line">        <span class="keyword">this</span>.unmodifiableMap = Collections.unmodifiableMap(<span class="keyword">this</span>.locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, SafePoint&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unmodifiableMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SafePoint <span class="title">getLocation</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> locations.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!locations.containsKey(id))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid vehicle name: "</span> + id);</span><br><span class="line">        locations.get(id).set(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>4.4 스레드 안전하게 구현된 클래스에 기능 추가</h3><ul><li>조심 또 조심… 쥐도 새도 모르게 동기화가 깨질 수 있따. 잠온다…</li></ul><h3>4.4.1 호출하는 측의 동기화</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadListHelper</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> absent = !list.contains(x);</span><br><span class="line">        <span class="keyword">if</span> (absent)</span><br><span class="line">            list.add(x);</span><br><span class="line">        <span class="keyword">return</span> absent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodListHelper</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> absent = !list.contains(x);</span><br><span class="line">            <span class="keyword">if</span> (absent)</span><br><span class="line">                list.add(x);</span><br><span class="line">            <span class="keyword">return</span> absent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Vector 클래스와 Collections.synchronizedList 메소드에 대한 문서를 읽어보면 Vector 클래스 자체나 synchronizedList의 결과 List를 통해 클라이언트 측 동기화를 지원한다는 점을 알수 있다. 따라서 해당 list 변수로 락을 실행해 스레드 안전성을 확보했다.</li></ul><h3>4.4.2 클래스 재구성</h3><ul><li>기존 클래스에 새로운 단일 연산을 추가하고자 할 때 좀더 안전하게 사용할 수 있는 방법이 있는데, 바로 <code>재구성 composition</code>이다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImprovedList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PRE: list argument is thread-safe.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImprovedList</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123; <span class="keyword">this</span>.list = list; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> contains = list.contains(x);</span><br><span class="line">        <span class="keyword">if</span> (contains)</span><br><span class="line">            list.add(x);</span><br><span class="line">        <span class="keyword">return</span> !contains;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Plain vanilla delegation for List methods.</span></span><br><span class="line">    <span class="comment">// Mutative methods must be synchronized to ensure atomicity of putIfAbsent.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.contains(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> list.toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.containsAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.addAll(index, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.removeAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.retainAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.equals(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, T element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.set(index, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, T element)</span> </span>&#123;</span><br><span class="line">        list.add(index, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.remove(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.indexOf(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.lastIndexOf(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;T&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.listIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;T&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.listIterator(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.subList(fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; list.clear(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ImprovedList는 List 클래스의 기능을 구현할 때는 ImprovedList 내부의 List 클래스 인스턴스가 갖고 있는 기능을 불러와 사용하고, 그에 덧붙여 putIfAbsend 메소드를 구현하고 있다.</li><li>ImprovedList 클래스는 그 자체를 락으로 사용해 그 안에 포함되어 있는 List와는 다른 수준에서 락을 활용하고 있다.</li><li>이런 방법으로 구현할 때에는 ImprovedList 클래스를 락으로 사용해 동기화하기 때문에, 내부의 List 클래스가 스레드 안전한지 아닌지는 중요하지 않고 신경 쓸 필요도 없다.</li><li>심지어 불러다 사용한 List클래스가 내부적으로 동기화 정책을 바꾼다 해도 신경 쓸 필요가 없다.</li><li>물론 이런 방법으로 동기화 기법을 한 단계 더 사용하면 전체적인 성능의 측면에서 약간 부정적인 영향이 있을 수 있다.</li></ul><h3>4.5 동기화 정책 문서화 하기</h3><ul><li>클래스의 동기화 정책에 대한 내용을 문서로 남기는 일은 스레드 안전성을 관리하는데 있어 가장 강력한 방법 가운데 하나다. (가장 많이 배척하는 방법 중임에도 틀림 없다.)<ul><li>클래스를 가져다 사용하는 입장에서는 개발자가 작성한 문서를 가장 먼저 확인 할 것이다.</li><li>유지보수를 담당하는 팀은 현재 사용하고 있는 프로그램의 안전성을 해치지 않을 수 있도록 동기화 전략을 파악하고자 할 것이다.</li></ul></li></ul><blockquote><p>구현한 클래스가 어느 수준까지 스레드 안전성을 보장하는지에 대해 충분히 문서를 작성해둬야 한다. 동기화 기법이나 정책을 잘 정리해두면 유지보수 팀이 원활하게 관리할 수 있다.</p></blockquote><p>synchronized, volatile 등의 키워드나 기타 여러 가지 동기화 관련 클래스를 사용하는 일은 모두 멀티스레드 환경에서 동작하는 클래스의 내부에 담겨있는 데이터를 안전하게 사용할 수 있도록 <code>동기화 정책 synchronization policy</code>를 정의하는 일이라고 볼 수 있다. 동기화 정책은 전체 프로그램 설계의 일부분이며 반드시 문서로 남겨야 한다.</p><p>동기화 정책을 구성하고 결정하고자 할 때 여러 가지 사항을 고려해야 한다.</p><ul><li>어떤 변수를 volatile로 지정할 것인지.</li><li>어떤 변수를 사용할 때는 락으로 막아야 하는지.</li><li>어떤 변수는 불변 클래스로 만들고 어떤 변수를 스레드에 한정시켜야 하는지.</li><li>어떤 연산을 단일 연산으로 만들어야 하는지를 따져봐야 한다.</li></ul><p><code>최소한 클래스가 스레드 안전성에 대해서 어디까지 보장하는지 문서로 남겨야 한다.</code></p><ul><li>클래스가 스레드에 안전한가?</li><li>락이 걸린 상태에서 콜백 함수를 호출하는 경우가 있는가?</li><li>클래스의 동작 내용이 달라질 수 있는 락이 있는지?</li></ul><p><code>이런 질문에 대해서 추측성 생각은 위험하다.</code></p><ul><li>여러분이 개발한 클래스를 클라이언트 측에서 락으로 사용하지 못하게 해도 좋다.</li><li>하지만 클라이언트 측 락을 사용할 수 없다고 적어 놓아야 한다.</li><li>또 개발한 클래스를 유지보수시 어떤 락으로 동기화 해야 안전하게 구현할 수 있는지에 대해 문서로 알려야 한다.</li></ul><p><code>GuardedBy 등의 Annotation만 활용해도 훌령하다.</code></p><ul><li>동기화를 맞출때 사용하는 아주 작은 기법이라도 반드시 적어두자.</li><li>후임자나 유지보수 인력에게는 굉장히 큰 도움이 된다.</li></ul><p><code>직관적으로 안전하겠다고 생각하는 클래스가 실제로는 그렇지 않은 경우가 많다.</code></p><ul><li>java.text.simpleDateFormat 클래스는 스레드 동기화가 되어 있지 않은데, JDK 1.4 버전 이전에는 API 문서에 동기화 언급이 전혀 없다.</li></ul><h3>4.5.1 애매한 문서 읽어내기</h3><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 4장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Chapter 4 객체 구성 이어서…&lt;/h3&gt;
&lt;h3&gt;차량 위치 추적&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="Code" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/Code/"/>
    
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="Code" scheme="http://jungha-cho.github.io/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency in Practice, 객체 공유 - 스레드 한정</title>
    <link href="http://jungha-cho.github.io/2017/05/09/JavaConcurrencyinPracticeObjectShareThreadConfine/"/>
    <id>http://jungha-cho.github.io/2017/05/09/JavaConcurrencyinPracticeObjectShareThreadConfine/</id>
    <published>2017-05-09T05:10:59.000Z</published>
    <updated>2018-03-26T07:54:17.658Z</updated>
    
    <content type="html"><![CDATA[<h3>3.3 스레드 한정</h3><p>스레드 안정성을 확보하는 방법</p><ol><li>변경 가능한 객체를 공유해 사용하는 경우, 항상 동기화 한다.</li><li>동기화를 사용하지 않는다면, 기본적으로 객체를 공유해 사용하지 않아야 한다.</li><li>특정 객체를 단일 스레드에서만 활용한다고 확신할수 있다면 동기화가 필요없다.</li></ol><p>이처럼 스레드를 <code>한정 confine</code>하는 방법으로 스레드 안전성을 확보할 수 있다.</p><h3>3.3.1 스레드 한정 - 주먹구구식</h3><p>스레드 한정 기법을 사용할 것인지를 결정하는 일은 GUI 모듈과 같은 특정 시스템을 단일 스레드로 동작하도록 만들 것이냐에 달려 있다. 특정 모듈의 기능을 단일 스레드로 동작하도록 구현한다면, 언어적인 지원 없이 직접 구현한 스레드 한정 기법에서 나타날 수 있는 오류의 가능성을 최소화할 수 있다.</p><p>임시방편적인 스레드 한정 기법은 안전성을 완벽하게 보장할 수 있는 방법은 아니기 떄문에 꼭 필요한 곳에만 제한적으로 사용하는 게 좋다. 가능하다면 좀더 안전한 스레드 한정 기법을 사용하자. ( 비추천 )</p><h3>3.3.2 스택 한정</h3><p>스택 한정 기법은 특정 객체를 로컬 변수를 통해서만 사용할 수 있는 특별한 경우의 스레드 한정기법이라고 할 수 있다. 변수를 클래스 내부에 숨겨두면 변경 상태를 관리하기가 쉬운데, 클래스 내부에 숨겨둔 변수는 특정 스레드에 쉽게 한정시킬 수도 있다. 스택 한정 기법은 앞서 살펴본 스레드 한정 기법보다 안전하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int loadTheArk(Collection&lt;Animal&gt; candidates) &#123;</span><br><span class="line">        SortedSet&lt;Animal&gt; animals;</span><br><span class="line">        int numPairs = 0;</span><br><span class="line">        Animal candidate = null;</span><br><span class="line"></span><br><span class="line">        // animals confined to method, don&apos;t let them escape!</span><br><span class="line">        animals = new TreeSet&lt;Animal&gt;(new SpeciesGenderComparator());</span><br><span class="line">        animals.addAll(candidates);</span><br><span class="line">        for (Animal a : animals) &#123;</span><br><span class="line">            if (candidate == null || !candidate.isPotentialMate(a))</span><br><span class="line">                candidate = a;</span><br><span class="line">            else &#123;</span><br><span class="line">                ark.load(new AnimalPair(candidate, a));</span><br><span class="line">                ++numPairs;</span><br><span class="line">                candidate = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numPairs;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>loadTheArk 메소드에 정의되어 있는 numPairs와 같이 기본 변수형을 사용하는 로컬 변수는 일부러 하려고 해도 스택 한정 상태를 깰 수 없다. 기본 변수형은 객체와 같이 참조되는 값이 아니기 때문인데, 이처럼 기본 변수형을 사용하는 로컬 변수는 언어적으로 스택 한정 상태가 보장된다.</li><li>기본 변수형의 로컬 변수와 객체형의 로컬 변수에 대한 스택 한정</li></ul><h3>3.3.3 ThreadLocal</h3><p>스레드 내부의 값과 값을 갖고 있는 객체를 연결해 스레드 한정 기법을 적용할 수 있도록 도와주는 좀더 형식적인 방법으로 ThreadLocal이 있다. ThreadLocal 클래스에는 get과 set 메소드가 있는데 호출하는 스레드마다 다른 값을 사용할 수 있도록 관리해준다. 다시 말해 threadLocal 클래스의 get 메소드를 호출하면 현재 실행중인 스레드에서 최근에 set 메소드를 호출해 저장했던 값을 가져올 수 있다.</p><ul><li>스레드 로컬 변수는 변경 가능한 싱글톤이나 전역 변수 등을 기반으로 설계되어있는 구조에서 변수가 임의로 공유되는 상황을 막기위해 사용하는 경우가 많다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">  public Connection initialValue() &#123;</span><br><span class="line">    return DriverManager.getConnection (DB_URL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public static Connection getConnection() &#123;</span><br><span class="line">  return connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ThreadLocal을 사용해 스레드 한정 상태를 유지</li><li>connectionHolder와 같이 JDBC 연결을 보관할때 ThreadLocal을 사용하면 스레드는 저마다 각자의 연결 객체를 갖게 된다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">특정 스레드가 ThreadLocal.get 메소드를 처음 호출한다면 initialValue 메소드에서 값을 만들어 해당 스레드에게 초기 값으로 넘겨준다. 개념적으로 본다면 ThreadLocal&lt;T&gt; 클래스는 Map&lt;Thread, T&gt;라는 자료구조로 구성되어 있고, Map&lt;Thread, T&gt;에 스레드별 값을 보관한다고 생각할 수 있겠다. 물론 ThreadLocal이 Map&lt;Thread, T&gt;를 사용해 구현되어 있다는 말은 아니다. 스레드별 값은 실제로 Thread 객체 자체에 저장되어 있으며, 스레드가 종료되면 스레드별 값으로 할당되어 있던 부분도 가비지 컬렉터가 처리한다.</span><br></pre></td></tr></table></figure><h3>3.4 불변성 (immutable)</h3><p>직접적으로 객체를 동기화하지 않고도 안전하게 사용할 수 있는 방법 가운데 마지막은 <code>불변 immutable</code>객체 이다. 이 모든 문제들은 여러 스레드가 예측할 수 없는 방향으로 변경 가능한 값을 동시에 사용하려 하기 때문에 발생한다.</p><p><code>불변 객체는 언제라도 스레드에 안전하다</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">다음 조건을 만족하면 해당 객체는 불변 객체다.</span><br><span class="line">1. 생성되고 난 이후에는 객체의 상태를 변경할 수 없다.</span><br><span class="line">2. 내부의 모든 변수는 final로 설정돼야 한다.</span><br><span class="line">3. 적절한 방법으로 생성돼야 한다(예를 들어 this 변수에 대한 참조가 외부로 유출되지 않아야 한다.)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Immutable</span><br><span class="line"> public final class ThreeStooges &#123;</span><br><span class="line">    private final Set&lt;String&gt; stooges = new HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public ThreeStooges() &#123;</span><br><span class="line">        stooges.add(&quot;Moe&quot;);</span><br><span class="line">        stooges.add(&quot;Larry&quot;);</span><br><span class="line">        stooges.add(&quot;Curly&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isStooge(String name) &#123;</span><br><span class="line">        return stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>일반 객체를 사용해 불변 객체를 구성한 모습</li></ul><p>실행 중인 프로그램은 그 상태가 계속해서 바뀌고 또 바뀌어야 하기 때문에 불변 객체가 그다지 쓸모 있을지에 대해 의문이 생길 수도 있지만, 불변 객체는 쓰임새가 참 다양하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[객체]가 불변이라는 것과 [참조]가 불변이라는 것은 반드시 구분해서 생각해야한다. 예를 들어 프로그램이 사용하는 데이터가 불변 객체에 들어있다 해도, ㅎ당 객체를 가리키고 있는 참조 변수에 또 다른 불변 객체를 바꿔치기하면 프로그램의 데이터가 언제든지 바뀌는 셈이다.</span><br></pre></td></tr></table></figure><h3>3.4.1 final 변수</h3><p>final 키워드는 불변 객체를 생성할 떄도 도움을 준다. final을 지정한 변수의 값은 변경할수 없는데 <code>(물론 변수가 가리키는 객체가 불변 객체가 아니라면 해당 객체에 들어 있는 값은 변경할 수 있다.)</code> 자바 메모리 모델을 놓고 보면 약간 특별한 의미를 찾을 수 있다. final 키워드를 적절하게 사용하면 초기화 안전성 <code>initialization safety</code>을 보장하기 때문에 별다른 동기화 작업 없이도 불변 객체를 자유롭게 사용하고 공유할 수 있다.</p><ul><li>완전한 불변 객체는 아니지만 상태 값이 하나 또는 두개 정도로 바뀔 수 있는 <code>거의 불변인</code> 객체 역시 일반 객체보다는 훨씬 고려해야 할 범위를 줄여준다. 그리고 변수를 final로 선언해두면 후임자가 코드를 읽을 떄에도 해당 변수에 지정된 값이 변하지 않는다는 점을 정확하게 이해할 수 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">외부에서 반드시 사용할 일이 없는 변수는 private으로 선언하는 게 괜찮은 방법인 만큼, 나중에 변경할 일이 없다고 판단되는 변수는 final로 선언해두는 것도 좋은 방법이다.</span><br></pre></td></tr></table></figure><h3>3.4.2 예제 : 불변 객체를 공개할 때 volatile 키워드 사용</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Immutable</span><br><span class="line">public class OneValueCache &#123;</span><br><span class="line">    private final BigInteger lastNumber;</span><br><span class="line">    private final BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    public OneValueCache(BigInteger i,</span><br><span class="line">                         BigInteger[] factors) &#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        if (lastNumber == null || !lastNumber.equals(i))</span><br><span class="line">            return null;</span><br><span class="line">        else</span><br><span class="line">            return Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>입력 값과 인수 분해된 결과를 묶는 불변 객체</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class VolatileCachedFactorizer extends GenericServlet implements Servlet &#123;</span><br><span class="line">    private volatile OneValueCache cache = new OneValueCache(null, null);</span><br><span class="line"></span><br><span class="line">    public void service(ServletRequest req, ServletResponse resp) &#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        if (factors == null) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            cache = new OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>VolatileCachedFactorizer 클래스는 OneValueCache 클래스를 사용해 입력 값과 결과를 캐시한다. 스레드 하나가 volatile로 선언된 cache 변수에 새로 생성한 OneValueCache 인스턴스를 설정하면, 다른 스레드에서도 cache 변수에 설정된 새로운 값을 즉시 사용할 수 있다.</li><li>최신 값을 불변 객체에 넣어 volatile 변수에 보관</li><li>OneValueCache 클래스가 불변인데다 cache 변수를 사용하는 코드에서는 cache 변수를 정확하게 한번씩만 사용하기 때문에 캐시와 관련된 연산은 전혀 혼동되거나 섞이지 않는다. VolatileCachedFactorizer 클래스는 변경할 수 없는 상태 값을 여러 개 갖고 있는 불변 객체인데다 volatile 키워드를 적용해 시간적으로 가시성을 확보하기 때문에 따로 락을 사용하지 않았다 해도 스레드에 안전하다.</li></ul><h3>3.5 안전 공개</h3><ul><li>지금까지는 객체를 특정 스레드에 한정하거나 다른 객체 내부에 넣을 때, 객체를 공개하지 않고 확실하게 숨기는 방법에 대해 살펴봤다.</li><li>여러 스레드에서 공유하도록 공개해야 할 상황이 있을 수도 있을떄에는 반드시 안전한 방법을 사용해야 한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 안전하지 않은 객체 공개</span><br><span class="line">// AntiPattern</span><br><span class="line">public Holder holder;</span><br><span class="line"></span><br><span class="line">public void initialize() &#123;</span><br><span class="line">  holder = new Holder(42);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>별 문제 없어 보이는 코드 이지만, 이렇게 별 문제 없어 보이는 코드가 얼마나 큰 문제를 일으킬 수 있는지를 이해하게 되면 정말 놀랍다는 생각이 든다.</li><li>가시성 문제 때문에 Holder 클래스가 안정적이지 않은 상태에서 외부 스레드에게 노출될 수 있으며, 심지어 생성 메소드에서 내부의 고정된 값을 정상적으로 설정한 이후에도 문제가 된다.</li><li>이렇게 단순한 방법으로 객체를 외부에 공개하면 생성 메소드가 채 끝나기도 전에 공개된 객체를 다른 스레드가 사용할 수 있다.</li></ul><h3>3.5.1 적절하지 않은 공개 방법 : 정상적인 객체도 문제를 일으킨다.</h3><p>만약 객체의 생성 메소드가 제대로 완료되지 않은 상태라면 과연 그 객체를 제대로 사용할 수 있을까?</p><ul><li>생성 메소드가 실행되고 있는 상태의 인스턴스를 다른 스레드가 사용하려 할때, 비정상 상태임에도 그대로 사용한다.</li><li>나중에 생성 메소드가 제대로 끝나고 보니 공개한 이후에 값이 바뀐 적이 없음에도 불구하고 처음 사용할 떄와는 값이 다른 경우도 생긴다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Holder &#123;</span><br><span class="line">  private int n;</span><br><span class="line"></span><br><span class="line">  public Holder(int n) &#123; this.n = n; &#125;</span><br><span class="line"></span><br><span class="line">  public void assertSanity() &#123;</span><br><span class="line">    if (n != n)</span><br><span class="line">      throw new AssertionError(&quot;This Statement Is False.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>올바르게 공개하지 않으면 문제가 생길 수 있는 객체</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">올바르게 공개하지 않으면 두 가지 문제가 발생할 수 있다.</span><br><span class="line">1. holder 변수에 스테일 상태가 발생할 수 있는데, holder 변수에 값을 지정한 이후에도 null 값이 지정되어 있거나 예전에 사용하던 참조가 들어가 있을 수도 있다.</span><br><span class="line">2. 다른 스레드는 모두 holder 변숭서 정상적인 참조 값을 가져갈 수 있지만 Holder 클래스의 입장에서는 스테일 상태에 빠질 수 있다.</span><br><span class="line"></span><br><span class="line">다시 한 번 강조하지만, 특정 데이터를 여러 개의 스레드에서 사용하도록 공유할떄 적절한 동기화 방법을 적용하지 않는다면 굉장히 이상한 일이 발생할 가능성이 높다는 점을 알아두자.</span><br></pre></td></tr></table></figure><h3>3.5.2 불변 객체와 초기화 안전성</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">불변 객체는 별다른 동기화 방법을 적용하지 않았다 해도 어느 스레드에서건 마음껏 안전하게 사용할 수 있다. 불변 객체를 공개하는 부분에 동기화 처리를 하지 않았다 해도 아무런 문제가 없다.</span><br></pre></td></tr></table></figure><p>final로 선언된 모든 변수는 별다른 동기화 작업 없이도 안전하게 사용할 수 있다. 하지만 final로 선언된 변수에 변경 가능한 객체가 지정되어 있다면 해당 변수에 들어있는 객체 값을 사용하려고 하는 부분을 모두 동기화 시켜야한다.</p><h3>3.5.3 안전한 공개 방법의 특성</h3><ul><li>불변 객체가 아닌 객체는 모두 올바른 방법으로 안전하게 공개해야 한다.</li><li>대부분 공개하는 스레드와 불러다 사용하는 스레드 양쪽 모두에 동기화 방법을 적용해야 한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">객체를 안전하게 공개하려면 해당 객체에 대한 참조와 객체 내부의 상태를 외부의 스레드에게 동시에 볼 수 있어야 한다. 올바르게 생성 메소드가 실행되고 난 객체는 다음과 같은 방법으로 안전하게 공개할 수 있다.</span><br><span class="line">1. 객체에 대한 참조를 static 메소드에서 초기화시킨다.</span><br><span class="line">2. 객체에 대한 참조를 volatile 변수 또는 AtomicReference 클래스에 보관한다.</span><br><span class="line">3. 객체에 대한 참조를 올바르게 생성된 클래스 내부의 final 변수에 보관한다.</span><br><span class="line">4. 락을 사용해 올바르게 막혀 있는 변수에 객체에 대한 참조를 보관한다.</span><br></pre></td></tr></table></figure><ul><li>Hashtable, ConcurrentMap, synchronizedMap을 사용해 만든 Map 객체를 사용하면 그 안에 보관하고 있는 키와 값 모두를 어느 스레드에서라도 항상 안전하게 사용할 수 있다.</li><li>객체를 Vector, CopyOnWriteArrayList, CopyOnWriteArraySet이나 synchronizedList 또는 synchronizedSet 메소드로 만든 컬렉션은 그 안에 보관하고 있는 객체를 어느 스레드에서라도 항상 안전하게 사용할 수 있다.</li><li>BlockingQueue나 ConcurrentLinkedQueue 컬렉션에 들어 있는 객체는 어느 스레드라도 항상 안전하게 사용할 수 있다.</li></ul><p>자바 라이브러리에서 제공하는 몇 가지 간단한 방법 <code>(Future 클래스나 Exchanger 클래스)</code>를 적절하게 활용해도 객체를 안전하게 공개할 수 있다.<br>다음과 같이 static 변수를 선언할 때 직접 new 연산자로 생성 메소드를 실행해 객체를 생성할 수 있다면 가장 쉬우면서도 안전한 객체 공개 방법이다.</p><p><code>public static Holder holder = new Holder(42);</code></p><p>static 초기화 방법은 JVM에서 클래스를 초기화하는 시점에 작업이 모두 진행된다. 그런데 JVM 내부에서 동기화가 맞춰져 있기 때문에 이런 방법으로 객체를 초기화 하면 객체를 안전하게 공개할 수 있다.</p><h3>3.5.4 결과적으로 불변인 객체</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">안전하게 공개한 결과적인 불변 객체는 별다른 동기화 작업 없이도 여러 스레드에서 안전하게 호출해 사용할 수 있다.</span><br></pre></td></tr></table></figure><p>예를 들어 Date 클래스는 불변 객체가 아니라서 여러 스레드에서 공유해 사용하려면 항상 락을 걸어야만 했다. 하지만 앞에서 설명한 것처럼 불변 객체인 것처럼 사용하면 동기화 작업을 하지 않아도 된다. 아래와 같이 사용자별로 최근 로그인한 시각을 Map에 저장해 두는 코드를 생각해보자.</p><p><code>public Map&lt;String, Date&gt; lastLogin = Collections.synchronizedMap(new HashMap&lt;String, Date&gt;());</code></p><p>위와 같은 코드에서 Map에 한 번 들어간 Date 인스턴스의 값이 더 이상 바뀌지 않는 다면 synchronizedMap 메소드를 사용하는 것만으로 동기화 작업이 충분하며, 그 안의 값을 사용할 떄에도 추가적인 동기화 코드를 만들어야 할 필요가 없다.</p><h3>3.5.5 가변 객체</h3><p>객체의 생성 메소드를 실행한 이후에 그 내용이 변경될 수 있다면, 안전하게 공개했다 하더라도 그저 공개한 상태를 다른 스레드가 볼 수 있다는 정도만 보장할 수 있다.</p><ul><li><code>가변 객체 mutable object</code>를 사용할 때에는 공개하는 부분과 가변 객체를 사용하는 모든 부분에서 동기화 코드를 작성해야만 한다. 그래야 객체 내용이 바뀌는 상황을 정확하게 인식하고 사용할 수 있다.</li><li>가변 객체를 안전하게 사용하려면 안전하게 공개해야만 하고, 또한 동기화와 락을 사용해 스레드 안전성을 확보해야만 한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">가변성에 따라 객체를 공개할 때 필요한 점을 살펴보면 다음과 같다.</span><br><span class="line">1. 불변 객체는 어떤 방법으로 공개해도 아무 문제가 없다.</span><br><span class="line">2. 결과적으로 불변인 객체는 안전하게 공개해야 한다.</span><br><span class="line">3. 가변 객체는 안전하게 공개해야 하고, 스레드에 안전하게 만들거나 락으로 동기화시켜야 한다.</span><br></pre></td></tr></table></figure><h3>3.5.6 객체를 안전하게 공유하기</h3><p>언제든 객체에 대한 참조를 가져다 사용하는 부분이 있다면, 그 객체로 어느 정도의 일을 할 수 있는지를 정확하게 알고 있어야 한다.</p><ol><li>객체를 사용하기 전에 동기화 코드를 적용해 락을 확보해야 하는지?</li><li>객체 내부의 값을 바꿔도 괜찮은지, 아니면 값을 읽기만 해야 하는 것인지?</li><li>대부분의 동기화 오류는 이와같이 몇가지 수칙을 이해하지 못하고 프로그램을 작성하는데서 싹트기 시작한다.</li><li>또한, 반대로 객체를 외부에서 사용할 수 잇도록 공개할 때에는 해당 객체를 어떤 방법으로 사용할 수 있고, 사용해야 하는지에 대해서 정확하게 설명해야 한다.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">여러 스레드를 동시에 사용하는 병렬 프로그램에서 객체를 공유해 사용하고자 할 때 가장 많이 사용되는 몇 가지 원칙을 살펴보면 다음과 같다.</span><br><span class="line"></span><br><span class="line">[스레드 한정] : 스레드에 한정된 객체는 완전하게 해당 스레드 내부에 존재하면서 그 스레드에서만 호출해 사용할 수 있다.</span><br><span class="line">[읽기 전용 객체를 공유] : 읽기 전용 객체를 공유해 사용한다면 동기화 작업을 하지 않더라도 여러 스레드에서 언제든지 마음껏 값을 읽어 사용할 수 있다. 물론 읽기 전용 객체에 해당한다고 볼 수 있다.</span><br><span class="line">[스레드에 안전한 객체를 공유] : 스레드에 안전한 객체는 객체 내부적으로 필수적인 동기화 기능이 만들어져 있기 때문에 외부에서 동기화를 신경 쓸 필요가 없고, 여러 스레드에서 마음껏 호출해 사용할 수 있다.</span><br><span class="line">[동기화 방법 적용] : 특정 객체에 동기화 방법을 적용해두면 지정한 락을 획득하기 전에는 해당 객체를 사용할 수 없다. 스레드에 안전한 객체 내부에서 사용하는 객체나 공개된 객체 가운데 특정 락을 확보해야 사용할 수 있도록 막혀 있는 객체 등에 동기화 방법이 적용되어 있다고 볼 수 있다.</span><br></pre></td></tr></table></figure><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 3장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;3.3 스레드 한정&lt;/h3&gt;
&lt;p&gt;스레드 안정성을 확보하는 방법&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;변경 가능한 객체를 공유해 사용하는 경우, 항상 동기화 한다.&lt;/li&gt;
&lt;li&gt;동기화를 사용하지 않는다면, 기본적으로 객체를 공유해 사용하지 않아야 한다.&lt;
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="Thread" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/Thread/"/>
    
    
      <category term="Thread" scheme="http://jungha-cho.github.io/tags/Thread/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency in Practice, 객체 공유 - 스레드 한정</title>
    <link href="http://jungha-cho.github.io/2017/05/09/JavaConcurrencyinPracticeChapter4Objectcomposition/"/>
    <id>http://jungha-cho.github.io/2017/05/09/JavaConcurrencyinPracticeChapter4Objectcomposition/</id>
    <published>2017-05-09T05:10:59.000Z</published>
    <updated>2018-03-26T07:54:00.538Z</updated>
    
    <content type="html"><![CDATA[<hr><h3>Chapter 04. 객체 구성</h3><p>기본적으로 어떤 프로그램의 스레드 안전성을 확보하고 있는지 확인하는 것은 굉장히 어려운 일이다. 대신 스레드 안전성을 확보한 개별 컴포넌트를 가져다가 안전한 방법을 동원해 서로 연결해 사용한다면 규모있는 컴포넌트나 프로그램을 좀더 쉽게 작성할 수 있다.</p><p>4장에서는 컴포넌트의 스레드 안전성을 안정적으로 확보할 수 있고, 이와 함께 개발자가 코드를 작성하는 과정에서 실수한다 해도 스레드 안전성을 해치지 않도록 도와주는 클래스 구성 방법을 살펴보자.</p><h3>4.1 스레드 안전한 클래스 설계</h3><blockquote><p>구조적인 캡슐화 없이 만들어 낸 결과물을 여러 스레드에서 사용해도 안전한지를 확인하기도 어려울 뿐더러 해당 객체를 나중에야 변경할 필요가 있을 때에도 스레드 공기화 문제 없이 변경하기란 더더욱 어려운 일이다.</p></blockquote><p>클래스가 스레드 안전성을 확보하도록 설계하고자 할 때에는 다음과 같은 세 가지를 고려해야 한다.</p><ul><li>객체의 상태를 보관하는 변수가 어떤 것인가?</li><li>객체의 상태를 보관하는 변수가 가질 수 있는 값이 어떤 종류, 어떤 범위에 해당하는가?</li><li>객체 내부의 값을 동시에 사용하고자 할 때, 그 과정을 관리할 수 있는 정책</li></ul><ul><li>객체의 상태는 항상 객체 내부의 변수를 기반으로 한다. 객체 내부의 변수가 모두 기본 변수형으로 만들어져 있다면 해당 변수만으로 객체의 상태를 완전하게 표현할 수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == Long.MAX_VALUE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"counter overflow"</span>);</span><br><span class="line">        <span class="keyword">return</span> ++value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Counter</code> 클래스는 <code>Value</code>라는 단 하나의 변수를 갖고 있으며, 따라서 <code>Counter</code> 클래스의 상태는 <code>value</code> 변수만 보면 완벽하게 알 수 있다.</li><li>예를 들어, <code>LinkedList</code> 객체의 상태는 추가되어 있는 모든 객체의 상태를 포함하는 범위에 해당한다.</li></ul><blockquote><p>객체 내부의 여러 변수가 갖고 있는 현재 상태를 사용하고자 할 때 값이 계속해서 변하는 상황에서도 값을 안전하게 사용할 수 있도록 조절하는 방법을 동기화 정책이라고 한다.<br>동기화 정책에는 객체의 불변성, 스레드 한정, 락 등을 어떻게 적절하게 활용해 스레드 안전성을 확보할 수 있으며 어떤 변수를 어떤 락으로 막아야 하는지 등의 내용을 명시한다.<br>클래스를 유지보수하기 좋게 관리하려면 해당 객체에 대한 동기화 정책을 항상 문서로 작성해둬야 한다.</p></blockquote><h3>4.1.1 동기화 요구사항 정리</h3><ul><li>정의 : 여러 스레드가 동시에 클래스를 사용하려 하는 상황에서 클래스 내부의 값을 안정적인 상태로 유지할 수 있다면 바로 스레드 안전성을 확보했다고 할 수 있다.<ul><li>객체와 변수를 놓고 보면 항상 객체와 변수가 가질 수 있는 가능한 값의 범위를 생각할 수 있는데, 이런 값의 범위를 <code>상태 범위 state space</code>라고 한다.</li><li>상태 범위가 좁으면 좁을수록 객체의 논리적인 상태를 파악하기가 쉽다.</li><li>부분 부분마다 <code>final</code>을 지정해두면 상태 범위를 크게 줄여주기 때문에 생각해야 할 논리의 범위를 줄일 수 있다. ( 가장 확실한 예로 불변 객체를 들 수 있다. 그 값이 변하지 않기 때문에 상태 범위에 단 하나의 값만 들어간다. )</li></ul></li><li>대부분의 클래스에는 특정 상태가 올바른 상태인지 올바르지 확인할 수 있는 마지노선이 있다.<ul><li>앞에서 봤던 <code>counter</code> 클래스의 <code>value</code> 변수는 <code>long</code> 타입으로 선언되어 있었다. <code>long</code>으로 지정된 변수는 항상 가장 작은 <code>Long.MIN_VALUE</code> 부터 가장 큰 <code>Long.MAX_VALUE</code> 사이의 값을 가질 수 있다. 더군다나 <code>Counter</code> 클래스는 동기화된 메소드를 사용해 <code>value</code> 변수에 음수 값이 지정될 수는 없다.</li></ul></li><li>클래스 내부의 상태나 상태 변화와 관련해 여러 가지 제약 조건이 있을 수 있는데, 이런 제약 조건에 따라 또 다른 동기화 기벗이나 캡슐화 방법을 사용해야 할 수도 있다.<ul><li>클래스가 특정 상태를 가질 수 없도록 구현해야 한다면, 해당 변수는 클래스 내부에 숨겨둬야만 한다.</li><li>변수를 숨겨두지 않으면 외부에서 클래스가 <code>올바르지 않다</code>고 정의한 값을 지정할 수 있기 때문이다. 그리고 특정한 연산을 실행했을 때 올바르지 않은 상태 값을 가질 가능성이 있다면 해당 연산은 단일 연산으로 구현해야 한다.</li><li>반대로 클래스에서 변수의 값에 별다른 제약 조건을 두지 않는다면 클래스의 유연성과 실행 성능을 높인다는 측면에서 이와 같은 동기화 방법이나 캡슐화 기법을 사용하지 않아도 되겠다.</li></ul></li></ul><blockquote><p>뭔소린지 모르겠다… 객체 상태를 가지는 변수의 최소값과 최대값을 정확하게 인식하고 사용하라는 것 같다.</p></blockquote><p>객체가 가질 수 있는 값의 범위와 변동 폭을 정확하게 인식하지 못한다면, 스레드 안전성을 완벽하게 확보할 수 없다. 클래스의 상태가 정상적이라는 여러 가지 제약 조건이 있을때 클래스의 상태를 정상적으로 유지하려면 여러 가지 추가적인 동기화 기법ㅂ을 적용하거나 상태 변수를 클래스 내부에 적절히 숨겨야 한다.</p><hr><h3>4.1.2 상태 의존 연산</h3><p>클래스가 가질 수 있는 값의 범위와 값이 변화하는 여러 가지 조건을 살펴보면 어떤 상황이라야 클래스가 정상적인지를 정의할 수 있다. 특정 객체는 상태를 기반으로 하는 <code>선행 조건 precondition</code>을 갖기도 한다. 예를 들어 현재 아무것도 들어있지 않은 큐에서는 값을 뽑아낼 수가 없다. 당연한 말이지만 큐에 뭔가 값이 들어 있어야 값을 뽑아낼 수 있기 때문이다. 당연한 말이지만 큐에 뭔가 값이 들어 있어야 값을 뽑아낼 수 있기 떄문이다. 현재 조건에 따라 동작 여부가 결정되는 연산을 <code>상태 의존 state-dependent</code> 연산이라고 한다.</p><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 4장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3&gt;Chapter 04. 객체 구성&lt;/h3&gt;
&lt;p&gt;기본적으로 어떤 프로그램의 스레드 안전성을 확보하고 있는지 확인하는 것은 굉장히 어려운 일이다. 대신 스레드 안전성을 확보한 개별 컴포넌트를 가져다가 안전한 방법을 동원해 서로 연결해 사용
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="Thread" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/Thread/"/>
    
    
      <category term="Thread" scheme="http://jungha-cho.github.io/tags/Thread/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency in Practice, 객체 공유</title>
    <link href="http://jungha-cho.github.io/2017/05/09/JavaConcurrencyinPracticeObjectShare/"/>
    <id>http://jungha-cho.github.io/2017/05/09/JavaConcurrencyinPracticeObjectShare/</id>
    <published>2017-05-09T04:10:59.000Z</published>
    <updated>2018-03-26T07:54:10.173Z</updated>
    
    <content type="html"><![CDATA[<h3>Chapter 03. 객체 공유</h3><ul><li>여러개의 스레드에서 특정 객체를 동시에 사용하려 할 때 섞이지 않고 안전하게 동작하도록 객첼ㄹ 공유하고 공개하는 방법을 살펴본다.</li><li>synchronized 키워드를 사용해 동기화시킨 블록이 단일 연산인 것처럼 동작하게 할 수 있다.</li></ul><h3>3.1 가시성</h3><p><code>재배치 (reordering)</code> 현상은 읽기 작업을 수행하는 스레드가 변수의 값을 먼저 읽어가는 상황이다.<br>재배치 현상은 특정 메소드의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에서 기인하는 문제이다.<br>단일 스레드로 동작할 때는 차이점을 전혀 알아챌 수 없지만 여러 스레드가 동시에 동작하는 경우에는 확연하게 나타날 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">동기화 기능을 지정하지 않으면 컴파일러나 프로세서, JVM 등이 프로그램 코드가 실행되느 순서를 임의로 바꿔 실행하는 이상한 경우가 발생하기도 한다. 다시 말하자면, 동기화 되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 &apos;반드시 이런 순서로 동작할 것이다&apos;라고 단정지을 수 없다.</span><br></pre></td></tr></table></figure><h3>3.1.1 스테일 데이터</h3><p>변수의 최신 값을 이용하지 못하고 다른 값을 사용하게 되는 경우가 발생할 수 있다. 항상 스테일 데이털ㄹ 사용하게 될 때도 있고, 정상적으로 동작하는 경우도 있다는 점이다. 다시 말하자면 특정 스레드가 어떤 변수를 사용할때 정상적인 최신 값을 사용할 <code>수</code>도 있고, 올바르지 않은 값을 사용할 <code>수</code>도 있다는 말이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">public class MutableInteger &#123;</span><br><span class="line">    private int value;</span><br><span class="line"></span><br><span class="line">    public int get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>동기하되지 않은 상태로 정수 값을 보관하는 클래스</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class SynchronizedInteger &#123;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private int value;</span><br><span class="line"></span><br><span class="line">    public synchronized int get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void set(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>동기화된 상태로 정수 값을 보관하는 클래스</li></ul><h3>3.1.2 단일하지 않은 64비트 연산</h3><p>동기화되지 않은 상태에서 특정 스레드가 변수의 값을 읽으려 한다면 스테일 상태의 값을 읽어갈 가능성이 있긴 하지만, 그래도 전혀 엉뚱한 값을 가져가는 것이 아니라 바로 이전에 다른 스레드에서 설정한 값을 가져가게 된다. 말하자면 <code>전혀 난데 없는 값이 생기지 않는다</code>는 정도로 생각할 수 있겠다.</p><p>하지만, 64비트를 사용하는 숫자형에 volatile 키워드를 사용하지 않은 경우에는 난데없는 값마저 생길 가능성이 있다. 자바 메모리 모델은 메모리에서 값을 가져오고<code>fetch</code> 저장<code>store</code>하는 연산이 단일해야 ㅎㄴ다고 정의하고 있지만, volatile로 지정하지 않은 long이나 double형의 64비트 값에 대해서는 메모리에 쓰거나 읽을때 두번의 32비트 연산을 사용할 수 있도록 허용하고 있다.</p><h3>3.1.3 락과 가시성</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">락은 상호 배제(mutual exclusion)뿐만 아니라 정상적인 메모리 가시성을 확보하기 위해서도 사용한다. 변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화시켜야 한다.</span><br></pre></td></tr></table></figure><h3>3.1.4 volatile 변수</h3><p>자바에서는 volatile 변수로 약간 다른 형태의 좀더 약한 동기화 기능을 제공한다.<br>volatile로 선언된 변수의 값을 바꿨을때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해준다.</p><ul><li>특정 변수를 선언할 때 <code>volatile</code> 키워드를 지정하면, 컴파일러와 런타임 모두 <code>이 변수는 공유해 사용하고, 따라서 ㅅㄹ행 순서를 재배치해서는 안 된다</code>고 이해한다.</li><li><code>volatile</code>로 지정된 변수는 프로세서의 레지스터에 캐시되지도 않고, 프로세서 외부의 캐시에도 들어가지 않기 때문에 volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해둔 최신의 값을 읽어갈 수 있다.</li><li><code>volatile</code> 변수를 사용할 때에는 아무런 락이나 동기화 기능이 동작하지 않기 때문에 <code>synchronized</code>를 사용한 동기화보다는 아무래도 강도가 약할 수 밖에 없다.</li><li><code>volatile</code> 변수의 가시성 효과는 변수 자체의 값에 대한 범위보다 약간 확장되어 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">스레드 A가 volatile 변수에 값을 써넣고 스레드 B가 해당 변수의 값을 읽어 사용한다고 할 때, 스레드 B가 volatile 변수의 값을 읽고나면 스레드 A 가 변수에 값을 쓰기전에 볼 수 있었던 모든 변수의 값을 스레드 B도 모두 볼수 있기 때문에 메모리 가시성 입장에서 본다면 volatile 변수를 사용하는 것과 synchronized 키워드로 특정한 코드를 묶는 게 비슷한 효과를 가져오고, volatile 변수의 값을 읽고 나면 synchronized 블록에 진입하는 것과 비슷한 상태에 해당한다.</span><br></pre></td></tr></table></figure><p>어쨋든 메모리 가시성에 효과가 있긴 하지만 그렇다고 volatile 변수에 너무 의존하지 않는게 좋다.</p><ul><li>volatile 변수만 사용해 메모리 가시성을 확보하도록 장성한 코드는 synchronized로 직접 동기화한 코드보다 훨씬 읽기가 어렵고, 따라서 오류가 발생할 확률도 높다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">동기화하고자 하는 부분을 명확하게 볼 수 있고, 구현하ㅏ기가 훨씬 간단한 경우에만 volatile 변수를 활용하자. 반대로 작은 부분이라도 가시성을 추론해봐야 하는 경우에는 volatile변수를 사용하지 않는 것이 좋다. volatile 변수를 사용하는 적절한 경우는 일반적으로 변수에 보관된 클래스의 상태에 대하ㅏㄴ 가시성을 확보하거나 중요한 이벤트가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우 등이 해당된다.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">락을 사용하면 가시성과 연산의 단일성을 모두 보장받을 수 있다. 하지만 volatile 변수는 연산의 단일성은 보장하지 못하고 가시성만 보장한다.</span><br></pre></td></tr></table></figure><p>정리하자면, volatile 변수는 다음과 같은 상황에서만 사용하는 것이 좋다.</p><ul><li>변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재</li><li>해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않다.</li><li>해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우</li></ul><h3>3.2 공개와 유출</h3><ul><li>특정 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만들면 <code>공개(published)</code> 되었다고 한다.</li><li>의도적으로 공개시키지 않았지만 외부에서 사용할 수 있게 된 경우를 <code>유출 상태(escaped)</code>라고 한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Set&lt;Secret&gt; knownSecrets;</span><br><span class="line"></span><br><span class="line">public void initialized() &#123;</span><br><span class="line">  knownSecrets = new HashSet&lt;Secret&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>스코프에 관계없이 완전히 공개되는 경우, <code>객체 공개</code></li></ul><p>특정 객체 하나를 공개한다고 해도, 그와 관련된 다른 객체까지 덩달아 공개하게 되는 경우도 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class UnsafeStates &#123;</span><br><span class="line">  private String[] states = new String[] &#123;</span><br><span class="line">    &quot;AK&quot;, &quot;AL&quot;, .....</span><br><span class="line">  &#125;;</span><br><span class="line">  public String[] getStates() &#123; return states; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>private으로 선언된 변수가 getStates 메소드를 통해 외부에 공개될 수 있기 때문에, <code>유출 상태</code>에 놓여 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@AntiPattern</span><br><span class="line">public class ThisEscape &#123;</span><br><span class="line">  public ThisEscape(EventSource source) &#123;</span><br><span class="line">    source.registerListener (</span><br><span class="line">      new EventListener () &#123;</span><br><span class="line">        public void onEvent (Event e) &#123;</span><br><span class="line">          doSomething(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>this 클래스에 대한 참조를 외부로 공개하는 상황, AntiPattern!!</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">생성 메소드를 실행하는 도중에는 this 변수가 외부에 유출되지 않게 해야 한다.</span><br></pre></td></tr></table></figure><ul><li>생성 메소드에서 this 변수를 ㅇ출시키는 가장 흔한 오류는 생성 메소드에서 스레드를 새로 만들어 시작시키는 일이다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class SafeListener &#123;</span><br><span class="line">    private final EventListener listener;</span><br><span class="line"></span><br><span class="line">    private SafeListener() &#123;</span><br><span class="line">        listener = new EventListener() &#123;</span><br><span class="line">            public void onEvent(Event e) &#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SafeListener newInstance(EventSource source) &#123;</span><br><span class="line">        SafeListener safe = new SafeListener();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        return safe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void doSomething(Event e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    interface EventSource &#123;</span><br><span class="line">        void registerListener(EventListener e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface EventListener &#123;</span><br><span class="line">        void onEvent(Event e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Event &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>생성 메소드에서 this 변수가 외부로 유출되지 않도록 팩토리 메소드를 사용하는 모습</li></ul><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 3장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Chapter 03. 객체 공유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;여러개의 스레드에서 특정 객체를 동시에 사용하려 할 때 섞이지 않고 안전하게 동작하도록 객첼ㄹ 공유하고 공개하는 방법을 살펴본다.&lt;/li&gt;
&lt;li&gt;synchronized 키워드를 사용해 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency in Practice, 스레드 안전성</title>
    <link href="http://jungha-cho.github.io/2017/05/09/JavaConcurrencyinPracticeThreadSafe/"/>
    <id>http://jungha-cho.github.io/2017/05/09/JavaConcurrencyinPracticeThreadSafe/</id>
    <published>2017-05-09T03:10:59.000Z</published>
    <updated>2018-03-26T07:54:25.961Z</updated>
    
    <content type="html"><![CDATA[<h3>스레드 안전성</h3><p>공유가 됐다는 것은 여러 스레드가 특정 변수에 접근할 수 있다는 뜻이다.<br>변경할 수 있다<code>(mutable)</code>는 것은 해당 변수 값이 변경될 수 있다는 뜻이다.<br>스레드 안전성이 코드를 보호하는 것처럼 보일 수 있지만, 실제로는 데이터에 제어 없이 동시<br>접근하는 것을 막으려는 의미이다.</p><p>자바에서 동기화 수단은 <code>synchronized</code> 키워드로서 배타적인 락을 통해 보호 기능을 제공한다.<br>하지만 <code>volatile</code> 변수, 명시적 락, 단일 연산 변수 <code>atomic variable</code>을 사용하는 경우에도<br><code>동기화</code>라는 용어를 사용한다.</p><p>프로그램을 작성할 때는 공유된 상태에 대한 접근을 동기화해야 한다는 원칙에 <code>특별한</code> 경우의 예외가 있다고 생각하고 싶겠지만, 그런 유혹은 버려야한다.</p><ul><li>꼭 필요한 동기화 구문이 빠진 프로그램도 테스트를 통과하고 몇 년 동안 잘 동작하는 등 얼핏 제대로 동작하는 것 처럼 보일 수도 있다. 하지만 잘못됐다는 사실에는 변함이 없고 언제든 오동작할 수 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">만약 여러 스레드가 변경할 수 있는 하나의 상태 변수를 적절한 동기화 없이 접근하면 그 프로그램은 잘못된 것이다. 이렇게 잘못된 프로그램을 고치는 데는 세 가지 방법이 있다.</span><br><span class="line">1. 해당 상태 변수를 스레드 간에 공유하지 않는다.</span><br><span class="line">2. 해당 상태 변수를 변경할 수 없도록 만든다.</span><br><span class="line">3. 해당 상태 변수에 접근할 땐 언제나 동기화를 사용한다.</span><br></pre></td></tr></table></figure><ul><li>클래스를 설계하면서 애당초 동시 접근을 염두에 두지 않았다면, 뒤늦게 위 세가지 방법 중 일부를 적용하고자 할 때 설계를 상당히 많이 고쳐야 할 가능성이 높다.</li><li>스레드 안전성 확보를 위해 나중에 클래스를 고치는 것보다는 애당초 스레드에 안전하게 설계하는 편이 훨씬 쉽다.</li><li><code>캡슐화</code>나 <code>데이터 은닉</code>이 도움이 될 수도 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">스레드에 아전한 클래스를 설계할 땐, 바람직한 객체 지향 기법이 왕도다. 캡슐화와 불변 객체를 잘 활용하고, 불변 족ㄴ을 명확하게 기술해야 한다.</span><br></pre></td></tr></table></figure><p><code>스레드 안전한 클래스</code>와 <code>스레드 안전한 프로그램</code>이란 용어를 구분 없이 사용했다. 그럼 스레드 안전한 프로그램은 스레드 안전한 클래스로만 구성된 프로그램일까? 꼭 그런것은 아니다.</p><h3>2.1 스레드 안전성이란?</h3><ul><li>스레드에 대한 납득할 만한 정의의 핵심은 모두 <code>정확성(correctness)</code> 개념과 관계가 있다.<br><code>정확성</code>일ㄴ 클래스가 해당 클래스의 명세에 부합한다는 뜻이다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄하든 어디에 끼워넣든, 호출하는 쪼에서 추가적인 동기화나 다른 조율 없이도 정혹하게 동작하면 해당 클래스는 스레드 안전하다고 말한다.</span><br></pre></td></tr></table></figure><ul><li>애당초 단일 스레드 환경에서도 제대로 동작하지 않으면 스레드 안전할 수 없다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">스레드 안전한 클래스는 클라이언트 쪽에서 동기화할 필요가 없도록 동기화 기능도 캡슐화한다.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">상태 없는 (stateless) 객체는 항상 스레드 안전하다.</span><br></pre></td></tr></table></figure><h3>2.2 단일 연산</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@AntiPattern</span><br><span class="line">@NotThreadSafe</span><br><span class="line">public <span class="keyword">class</span> UnsafeCountingFactorizer extends GenericServlet implements Servlet &#123;</span><br><span class="line">    private <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">long</span> getCount() &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> service(ServletRequest req, ServletResponse resp) &#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        ++count;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> encodeIntoResponse(ServletResponse res, BigInteger[] factors) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger extractFromRequest(ServletRequest req) &#123;</span><br><span class="line">        <span class="keyword">return</span> new BigInteger(<span class="string">"7"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger[] factor(BigInteger i) &#123;</span><br><span class="line">        <span class="comment">// Doesn't really factor</span></span><br><span class="line">        <span class="keyword">return</span> new BigInteger[] &#123; i &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>동기회 구문 없이 요청 횟수를 카운트 하는 서블릿, 안티 패턴!</li></ul><h3>2.2.2 예제: 늦은 초기화 시 경쟁 조건</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">public <span class="keyword">class</span> UnsafeLazyInitialization &#123;</span><br><span class="line">    private <span class="keyword">static</span> Resource resource;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> Resource getInstance() &#123;</span><br><span class="line">        <span class="keyword">if</span> (resource == null)</span><br><span class="line">            resource = new Resource(); <span class="comment">// unsafe publication</span></span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> Resource &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>스레드 A와 B가 동시에 getInstance를 수행한다고 할때, A와 B는 서로 다른 Instance를 가져갈 수도 있다. (의도와는 다른 동작)</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public <span class="keyword">class</span> CountingFactorizer extends GenericServlet implements Servlet &#123;</span><br><span class="line">    private final AtomicLong count = new AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">long</span> getCount() &#123; <span class="keyword">return</span> count.get(); &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> service(ServletRequest req, ServletResponse resp) &#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> encodeIntoResponse(ServletResponse res, BigInteger[] factors) &#123;&#125;</span><br><span class="line">    BigInteger extractFromRequest(ServletRequest req) &#123;<span class="keyword">return</span> null; &#125;</span><br><span class="line">    BigInteger[] factor(BigInteger i) &#123; <span class="keyword">return</span> null; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>AtomicLong으로 바뀐 부분에서 카운터에 접근하는 모든 동작이 단일 연산으로 처리된다. 서블릿의 상태가 카운터의 상태이고 카운터가 스레드에 안전하기 때문에 서블릿도 스레드에 안전하다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">가능하면 클래스 상태를 관리하기 위해 AtomicLong처럼 스레드에 안전하게 이미 만들어져 있는 객체를 사용하는 편이 좋다. 스레드 안전하지 않은 상태 벼수를 선언해두고 사용하는 것보다 이미 스레드 안전하게 만들어진 크래스가 가질 수 있는 가능한 상태의 변화를 파악하는 편이 훨씬 쉽고, 스레드 안전성을 더 쉽게 유지하고 검증할 수 있다.</span><br></pre></td></tr></table></figure><h3>2.3.1 암묵적인 락</h3><p>synchronized (lock) {<br>// Lock으로 보호된 공유 상태에 접근하거나 해당 상태를 수정한다.<br>}</p><p>이와같이 자바에 내장된 락을 <code>암묵적인 락 intrinsic lock</code> 혹은 <code>모니터 락 monitor lock</code>이라고 한다. 락은 스레드가 synchronized 블록에 들어가기전에 자동으로 확보됨.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public <span class="keyword">class</span> SynchronizedFactorizer extends GenericServlet implements Servlet &#123;</span><br><span class="line">    @GuardedBy(<span class="string">"this"</span>) private BigInteger lastNumber;</span><br><span class="line">    @GuardedBy(<span class="string">"this"</span>) private BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    public synchronized <span class="keyword">void</span> service(ServletRequest req,</span><br><span class="line">                                     ServletResponse resp) &#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        <span class="keyword">if</span> (i.equals(lastNumber))</span><br><span class="line">            encodeIntoResponse(resp, lastFactors);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            BigInteger[] factors = factor(i);</span><br><span class="line">            lastNumber = i;</span><br><span class="line">            lastFactors = factors;</span><br><span class="line">            encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> encodeIntoResponse(ServletResponse resp, BigInteger[] factors) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger extractFromRequest(ServletRequest req) &#123;</span><br><span class="line">        <span class="keyword">return</span> new BigInteger(<span class="string">"7"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger[] factor(BigInteger i) &#123;</span><br><span class="line">        <span class="comment">// Doesn't really factor</span></span><br><span class="line">        <span class="keyword">return</span> new BigInteger[] &#123; i &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>동기화 수단을 쓰면 아주 쉽게 인수분해 서블릿을 스레드 안전하게 고칠 수 있다. 이제 SynchronizedFactorizer는 스레드에 안전하다. 하지만 이 방법은 너무 극단적이라 인수분해 서블릿을 여러 클라이언트가 동시에 사용할 수 없고, 이 때문에 응답성이 엄창나게 떨어질 수 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">종종 단순성과 성능이 서로 상충할 때가 있다. 동기화 정책을 구현할 때는 성능을 위해 조급하게 단순성(잠재적으로 안전성을 훼손하면서)을 희생하고픈 유혹을 버려야 한다.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">복잡하고 오래 걸리는 계산 작업, 네트웍 작업, 사용자 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 락을 잡지 말아라.</span><br></pre></td></tr></table></figure><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 2장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;스레드 안전성&lt;/h3&gt;
&lt;p&gt;공유가 됐다는 것은 여러 스레드가 특정 변수에 접근할 수 있다는 뜻이다.&lt;br&gt;
변경할 수 있다&lt;code&gt;(mutable)&lt;/code&gt;는 것은 해당 변수 값이 변경될 수 있다는 뜻이다.&lt;br&gt;
스레드 안전성이 코드를
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="Thread" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/Thread/"/>
    
    
      <category term="Thread" scheme="http://jungha-cho.github.io/tags/Thread/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency in Practice, 개요</title>
    <link href="http://jungha-cho.github.io/2017/05/08/JavaConcurrencyinPracticeIntroduce/"/>
    <id>http://jungha-cho.github.io/2017/05/08/JavaConcurrencyinPracticeIntroduce/</id>
    <published>2017-05-08T11:10:59.000Z</published>
    <updated>2018-03-26T07:53:17.899Z</updated>
    
    <content type="html"><![CDATA[<h3>01. 개요</h3><p>한 종류의 일을 순차적으로 처리하는 프로그램은 작성하기 쉽고 오류도 별로 생기지 않는다.<br>또 여러 종류 일을 순차적으로 처리하는 프로그램 보다 테스트하기도 쉽다.<br>종류별 작업마다 또는 시뮬레이션 작업의 각 요소마다 스레드를 하나씩 할당하면 마치 순차적인 작업처럼 처리할 수 있고,<br>스케줄링, 교차 실행되는 작업, 비동기 I/O, 자원 대기 등의 세부적인 부분과 상위의 비즈니스 로직에 해당하는 부분을 분리할 수 있다.<br>다시 말해 복잡하면서 비동기적인 작업 흐름을 각기 별도 스레드에서 수행되는 더 단순하고 동기적인 작업 흐름 몇 개로 나눌 수 있다.<br>이런 작업 흐름에서는 특정한 동기화 시점에서만 상호 작용이 발생한다.</p><h3>정리하기</h3><ul><li>스스로 개념을 정리 좀 해보고자 한다.<br><img src="/images/threaddiagram.jpg" alt="threaddiagram"></li></ul><p>스레드는 하나의 Process에서 실행될 수 있는 작업 단위를 뜻한다.<br>이전에 Process와 Program은 차이가 뭘까?</p><ul><li>Process는 <code>실행 중</code>인 Program을 뜻한다.</li><li>Program은 <code>대기 중</code>인 코드 및 파일들을 뜻한다.</li></ul><p>대기 중 이라는 말이 애매할 수도 있는데, 아직 실행되지 못한 코드 및 파일이고 이 파일들이 메모리에 올라가 실행 중일때 <code>Process</code>이다.</p><ul><li>각각의 스레드는 하나의 프로세스 안에서 메모리를 공유할 수 있다.</li></ul><h3>용어 정리</h3><p><code>경쟁 조건 ( Race Condition )</code> : 병행 프로세스에서의 자원경쟁<br><code>데드락 ( deadlock )</code> : 운영체제 혹은 소프트웨어의 잘못된 자원 관리로 인하여 둘 이상의 프로그램(심하면 운영체제 자체도 포함해서)이 함께 멈추어 버리는 현상을 말한다. 식사하는 철학자 문제를 보는 것도 도움이 된다.<br><code>기아 상태 ( starvation )</code> : 컴퓨터 과학 용어의 하나로, 프로세스가 끊임없이 필요한 컴퓨터 자원을 가져오지 못하는 상황으로, 이러한 자원 없이는 처리를 끝낼 수 없는 병행 컴퓨팅에서 마주치는 문제이다. 기아 상태는 스케줄링이나 상호 배제 알고리즘의 오류에 기인하지만 자원 누수에 의해 일어날 수도 있으며 포크 폭탄과 같은 서비스 거부 공격을 통해 고의적으로 발생할 수도 있다.</p><h3>책 구조</h3><ul><li>기본 원리 1부 ( 2장 ~ 5장 ): 병렬 프로그램 문제점을 피하는 모든 방법, 스레드 안전한 클래스를 작성하는 방법, 스레드 안전성을 확인할 수 있는 방법 등등…</li><li>병렬 프로그램 구조 잡기 2부 ( 6장 ~ 9장 ) : 스레드를 어떻게 사용하면 병렬 프로그램의 성능과 응답성을 높일 수 있는지를 다룬다.</li><li>활동성, 성능, 테스트 3부 ( 10장 ~ 12장 ) : 개발자가 의도한 기능이 병렬 프로그램이 제대로 처리하는지 확인하는 방법. 적당한 시간 이내에 원하는 기능을 처리할 수 있는지의 여부 확인.</li><li>고급 주제 4부 ( 13장 ~ 16장 ) : 명시적 락, 단일 연산 변수, 넌블로킹 알고리즘, 입맛에 맞는 동기화 클래스 작성법.</li><li>기본 Java 5에 일부 Java 6 기능 활용.</li></ul><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 1장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;01. 개요&lt;/h3&gt;
&lt;p&gt;한 종류의 일을 순차적으로 처리하는 프로그램은 작성하기 쉽고 오류도 별로 생기지 않는다.&lt;br&gt;
또 여러 종류 일을 순차적으로 처리하는 프로그램 보다 테스트하기도 쉽다.&lt;br&gt;
종류별 작업마다 또는 시뮬레이션 작업의 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>조엘 온 소프트웨어 C5-C14</title>
    <link href="http://jungha-cho.github.io/2017/05/08/JoelOnSoftwareC5C14/"/>
    <id>http://jungha-cho.github.io/2017/05/08/JoelOnSoftwareC5C14/</id>
    <published>2017-05-08T09:50:59.000Z</published>
    <updated>2018-03-26T07:53:51.129Z</updated>
    
    <content type="html"><![CDATA[<h3>5장, 손쉬운 기능명세 작성법</h3><ul><li>명세서 없이 코딩에 뛰어드는 짓은 하지말자</li><li>명세서 작성에서 얻을수 있는 결실은 프로그램 설계이다.</li><li>작성한 설계서를 바탕으로 고객이 원하는 바를 파악하고 다시 설계서를 수정함으로써 삽질을 줄일수 있다.</li><li>시간을 절약할 수 있다.</li><li>명세서를 바탕으로 팀의 협업이 원활히 진행될 수 있다.</li><li>명세서는 전지전능하며 모든 업무의 기본이다.</li></ul><h3>6장, 명세서가 뭡니까?</h3><ul><li>기술 명세와 기능 명세는 명백히 다르다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">기술 명세 ( functional specification )   </span><br><span class="line">완전히 사용자 관점에서 제품이 어떻게 동작할지를 기술한다. 어떻게 구현했는지는</span><br><span class="line">신경 쓰지 않는다. 기능에 대해 이야기하고, 화면, 메뉴, 대화상자와 같은 사용자</span><br><span class="line">인터페이스 부품을 명세한다.</span><br><span class="line"></span><br><span class="line">기능 명세 ( technical specification )   </span><br><span class="line">프로그램의 내부 구현을 기술한다. 자료구조와 관계형 데이터베이스 모델과</span><br><span class="line">프로그래밍 언어, 도구, 알고리즘 선택과 같은 항목을 다룬다.</span><br></pre></td></tr></table></figure><ul><li>명세 단골 항목</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 면책 조항 : 이 명세는 완벽하지 않다.</span><br><span class="line">2. 저자 : 저자는 1명으로 책임을 단일화 한다.</span><br><span class="line">3. 시나리오 : 제품 사용 방법에 대한 시나리오 작성</span><br><span class="line">4. 회피 목표 : non-goal -&gt; 쓸모 없는 기능을 제외시키는 항목</span><br><span class="line">5. 개괄 : 목차와 유사</span><br><span class="line">6. 세부 사항, 세부 사항, 세부 사항 : 너무나도 자세해 못 견딜 만큼 따분한 세부 사항</span><br><span class="line">7. 미해결 문제 : open-issue -&gt; 토론의 장을 열어놓기</span><br><span class="line">8. 방주 : 명세서를 읽는 사람은 테스터, 마케터, 팀원 등 다양하다. 따라서 자세한 기술을 원할때는 기술 노트, 테스팅 노트, 마케팅 노트 등등 각주를 포함한다.</span><br></pre></td></tr></table></figure><ul><li>명세는 지속적으로 개정해야 한다.</li></ul><h3>7장, 누가 명세를 작성하나?</h3><ul><li>PM</li><li>코드 개발자를 프로그램 관리자로 승급시키지 말라</li><li>마케팅 부서 사람을 프로그램 관리자로 승급시키지 말라</li><li>프로그래머가 프로그램 관리자에게 보고하는 체제가 되어서는 안된다.</li></ul><h3>8장, 명세 팁</h3><ul><li>명세서 작성에서 가장 큰 걸림돌은 아무도 명세서를 읽지 않는다는 것이다.<br>규칙 1: 재미있게 쓰자.<br>규칙 2: 명세를 쓰는 작업은 머리가 돌아가도록 코드를 쓰는 작업과 유사하다.<br>규칙 3: 최대한 단순하게 작성하라.<br>규칙 4: 여러 차례에 걸쳐 검토하고 다시 읽어라.<br>규칙 5: 표준 양식은 해롭다고 간주한다.</li></ul><h3>9장, 손쉬운 소프트웨어 일정관리법</h3><ol><li>마이크로소프트 엑셀을 사용합시다.</li><li>단순하게 만듭시다.</li><li>각 기능은 과업 여러개를 포함해야만 한다.</li><li>담당 프로그래머만이 제대로 일정을 짤 수 있다.</li><li>과업을 세부적으로 나누자.</li><li>초기 예측과 현재 예측을 동시에 유지하자.</li><li>경과 열은 매일 갱신하자.</li><li>일정에 휴가나 휴일 같은 항목을 넣자.</li><li>일정에 디버깅 시간을 넣자.</li><li>일정에 통합 시간을 넣자.</li><li>일정에 여유 기간을 두자.</li><li>관리자가 프로그래머에게 일정을 단축하도록 절대 강요하지 못하게 하자.</li><li>일정은 장난감 블록과도 같다.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">엑셀에 대해 꼭 알아둬야 할 사항들   </span><br><span class="line">공유 목록 : 동시에 여러 사람이 편집이 가능하다.   </span><br><span class="line">자동 필터 : 해당 과업, 담당자 별 필터링이 가능하다.   </span><br><span class="line">피벗 테이블 : 개발자 마다 남아있는 시간을 보여줄수 있는 차트를 만든다던가.. 등등</span><br></pre></td></tr></table></figure><h3>10장, 일일 빌드는 당신의 친구</h3><ul><li>빌드 체크와 코드 퀄리티 게이트를 적용해 해당 빌드 패스 및 버그 수정을 그날그날 수행하자.</li></ul><h3>11장, 고리타분한 버그 수정</h3><ol><li>찾아낸 버그를 모두 확인하자.</li><li>경제적인 피드백을 확인하자.</li><li>버그를 모두 수정하는 작업이 어떤 값어치가 있는지 계산하자. ( 릴리즈와 버그 수정 중 어떤 일이 먼저인지 판단하자는 것 )</li></ol><h3>12장, 다섯 가지 세계</h3><ol><li>상품 소프트웨어</li><li>사내용 소프트웨어</li><li>임베디드 소프트웨어</li><li>게임 소프트웨어</li><li>일회성 소프트웨어</li></ol><p><code>각 세계는 모두 다른 특성과 이해관계가 얽혀있다.</code></p><h3>13장, 종이 프로토타이핑</h3><p><code>연필로 슥슥 갈긴 프로토타입으로 회의 시간을 단축하자.</code></p><h3>14장, 화성인 아키텍트를 조심하세요.</h3><p>다음에…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;5장, 손쉬운 기능명세 작성법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;명세서 없이 코딩에 뛰어드는 짓은 하지말자&lt;/li&gt;
&lt;li&gt;명세서 작성에서 얻을수 있는 결실은 프로그램 설계이다.&lt;/li&gt;
&lt;li&gt;작성한 설계서를 바탕으로 고객이 원하는 바를 파악하고 다시
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="명세서" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/%EB%AA%85%EC%84%B8%EC%84%9C/"/>
    
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/tags/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="명세서" scheme="http://jungha-cho.github.io/tags/%EB%AA%85%EC%84%B8%EC%84%9C/"/>
    
  </entry>
  
  <entry>
    <title>GCP에 CI 구축하기</title>
    <link href="http://jungha-cho.github.io/2017/05/08/JenkinsslacktrelloGoogleCloudPlatform/"/>
    <id>http://jungha-cho.github.io/2017/05/08/JenkinsslacktrelloGoogleCloudPlatform/</id>
    <published>2017-05-08T09:50:59.000Z</published>
    <updated>2018-03-26T07:53:39.336Z</updated>
    
    <content type="html"><![CDATA[<h3>Google Cloud Platform에 CI 구축하기</h3><p>GCP 프로모션을 통해 1년간 사용할 수 있는 무료 크레딧 $300을 지원받았다.<br>이를 통해 CentOS를 설치하고 Jenkins, SonarQube를 운용중이다.<br>여기에 Slack을 연동하고 github과 gitlab repo를 연동시켜 각 프로젝트의 일일 빌드를<br>수행하는데 이용하고 있다.</p><p>늘 그렇듯 구글 검색과 삽질의 연속으로 각각 연동 시켰는데, 큰 어려움은 없었지만<br>네트워크 inbound, outbound 설정에서 많이 애를 먹었다. 공식 url인 gitlab, github의<br>ip가 아니라 연결된 repo에서 webhook이나 checkout을 수행할때 들어오고 나오는 ip가<br>달랐는데, 이 또한 구글신의 도움으로 해결했다.</p><p>GCP Inbound<br>Gitlab In<br>52.184.189.123<br>52.184.194.155<br>52.184.195.9<br>52.184.195.32<br>52.184.195.57<br>52.184.196.138<br>52.184.198.203<br>58.221.55.205<br>52.167.214.135</p><p>Gitlab out<br>52.184.189.123<br>52.184.194.155<br>52.184.195.9<br>52.184.195.32<br>52.184.195.57<br>52.184.196.138<br>52.184.198.203<br>58.221.55.205<br>52.167.214.135</p><p>slack Inbound<br>54.230.251.234<br>54.169.142.40<br>54.230.248.67<br>52.84.188.161<br>34.197.17.145<br>107.23.98.243<br>52.71.151.85<br>52.3.21.159</p><p>Slack outbound<br>54.230.251.234<br>54.169.142.40<br>54.230.248.67<br>52.84.188.161<br>34.197.17.145<br>107.23.98.243<br>52.71.151.85<br>52.3.21.159</p><p>무식한 방법이지만 이중 ip가 각각 hook과 repo checkout을 수행하는데 사용하는 IP<br>였거니 라는 엔지니어 답지않은 마인드로 방화벽 규칙을 등록했다.</p><p>더 좋은 방법이 있다면 조언 부탁드립니다!!</p><p>이상! 삽질기 끝</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Google Cloud Platform에 CI 구축하기&lt;/h3&gt;
&lt;p&gt;GCP 프로모션을 통해 1년간 사용할 수 있는 무료 크레딧 $300을 지원받았다.&lt;br&gt;
이를 통해 CentOS를 설치하고 Jenkins, SonarQube를 운용중이다.&lt;b
      
    
    </summary>
    
      <category term="Infra" scheme="http://jungha-cho.github.io/categories/Infra/"/>
    
      <category term="CI" scheme="http://jungha-cho.github.io/categories/Infra/CI/"/>
    
      <category term="Jenkins" scheme="http://jungha-cho.github.io/categories/Infra/CI/Jenkins/"/>
    
    
      <category term="CI" scheme="http://jungha-cho.github.io/tags/CI/"/>
    
      <category term="Jenkins" scheme="http://jungha-cho.github.io/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Apache Kafka 설치</title>
    <link href="http://jungha-cho.github.io/2017/04/12/ApachKafkaInstall/"/>
    <id>http://jungha-cho.github.io/2017/04/12/ApachKafkaInstall/</id>
    <published>2017-04-12T10:09:59.000Z</published>
    <updated>2018-03-26T07:52:56.681Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/kafka.png" alt="img"></p><h3>준비 사항</h3><ol><li>CentOS 7이 설치된 서버 (또는 VM)</li><li>오픈 JDK 패키지 설치</li></ol><ul><li>yum install java-1.8.0-openjdk.x86_64</li><li>설치가 잘 되었는지 확인하려면 아래의 명령어를 실행해서 자바 버전 확인</li><li>java -version</li></ul><ol start="3"><li>자바 환경 변수 설정</li></ol><ul><li>텍스트 에디터를 이용해서 ‘/etc/profile’에 자바 환경 변수 설정을 추가<ul><li>vim /etc/profile</li><li>profile 파일 안에 아래의 내용을 추가<ul><li>export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk</li><li>export JRE_HOME=/usr/lib/jvm/jre</li></ul></li><li>source 명령어를 이용해서 변경된 내용 적용<ul><li>source /etc/profile</li></ul></li></ul></li></ul><h3>설치 단계</h3><ol><li>Kafka 패키지 다운로드</li></ol><ul><li>wget <a href="http://www-us.apache.org/dist/kafka/0.10.0.1/kafka_2.11-0.10.0.1.tgz" target="_blank" rel="noopener">http://www-us.apache.org/dist/kafka/0.10.0.1/kafka_2.11-0.10.0.1.tgz</a><ul><li>위의 버전이 최신 버전이 아니면 kafka 웹사이트 (<a href="http://www-us.apache.org/dist/kafka" target="_blank" rel="noopener">http://www-us.apache.org/dist/kafka</a>)에 들어가셔서 최신 버전을 확인 후 다운 받으세요.</li></ul></li><li>tar xvf kafka_2.11-0.10.0.1.tgz</li><li>mv kafka_2.11-0.10.0.1 /opt</li><li>cd /opt/kafka_2.11-0.10.0.1</li></ul><ol start="2"><li>Zookeeper 서버 시작</li></ol><ul><li>bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</li></ul><ol start="3"><li>Kafka 서버 시작</li></ol><ul><li>bin/kafka-server-start.sh config/server.properties<ul><li>서버 시작 후 아래와 같은 로그를 확인하셨다면 서버가 정상적으로 시작된 것입니다.</li><li>INFO [Kafka Server 0], started (kafka.server.KafkaServer)</li></ul></li></ul><ol start="4"><li>Kafka 패키지에서 제공하는 클라이언트 프로그램을 이용한 간단한 서버 테스트</li></ol><ul><li>테스트 토픽 생성<ul><li>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</li></ul></li><li>Consumer 생성<ul><li>bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test —from-beginning</li></ul></li><li>Producer 생성<ul><li>같은 SSH 연결에서 Consumer와 Producer를 같이 생성할 수 없기 때문에 새로운 SSH 연결을 한 후 에 아래의 명령어를 실행합니다.</li><li>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</li><li>위의 명령어를 실행 후 콘솔에 텍스트를 입력하고 엔터를 누르면 입력한 텍스트가 Consumer 쪽 콘솔에 출력 되는 것을 확인하실 수 있으십니다.</li></ul></li></ul><ol start="5"><li>References<br><a href="https://www.vultr.com/docs/how-to-install-apache-kafka-on-centos-7" target="_blank" rel="noopener">https://www.vultr.com/docs/how-to-install-apache-kafka-on-centos-7</a><br><a href="http://davidssysadminnotes.blogspot.com/2016/01/installing-apache-kafka-and-zookeeper.html" target="_blank" rel="noopener">http://davidssysadminnotes.blogspot.com/2016/01/installing-apache-kafka-and-zookeeper.html</a><br><a href="http://www.javaworld.com/article/3060078/big-data/big-data-messaging-with-kafka-part-1.html" target="_blank" rel="noopener">http://www.javaworld.com/article/3060078/big-data/big-data-messaging-with-kafka-part-1.html</a></li></ol><p>출처 : <a href="http://utk-unm.blogspot.kr/2016/10/apache-kafka-centos-721511-64-bit.html" target="_blank" rel="noopener">http://utk-unm.blogspot.kr/2016/10/apache-kafka-centos-721511-64-bit.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/kafka.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3&gt;준비 사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CentOS 7이 설치된 서버 (또는 VM)&lt;/li&gt;
&lt;li&gt;오픈 JDK 패키지 설치&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;y
      
    
    </summary>
    
      <category term="Infra" scheme="http://jungha-cho.github.io/categories/Infra/"/>
    
      <category term="MQ" scheme="http://jungha-cho.github.io/categories/Infra/MQ/"/>
    
      <category term="Kafka" scheme="http://jungha-cho.github.io/categories/Infra/MQ/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://jungha-cho.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>규칙 13 클래스와 멤버의 접근 권한은 최소화하라</title>
    <link href="http://jungha-cho.github.io/2017/04/11/EffectiveJavaRule13/"/>
    <id>http://jungha-cho.github.io/2017/04/11/EffectiveJavaRule13/</id>
    <published>2017-04-11T13:09:59.000Z</published>
    <updated>2018-03-26T07:52:29.850Z</updated>
    
    <content type="html"><![CDATA[<h3>규칙 13. 클래스와 멤버의 접근 권한은 최소화하라</h3><p><code>잘 설계된 모듈과 그렇지 못한 모듈을 구별 짓는 가장 중요한 속성 하나는 모듈 내부의 데이터를 비롯한 구현 세부사항을 다른 모듈에 잘 감추느냐의 여부에 달려있다.</code></p><p>잘 설계된 모듈은 구현 세부사항을 전부 API 뒤쪽에 감춘다. 모듈은 이 API를 통해서만 서로 통신하며, 각자 내부적으로 무슨 짓을 하는지는 신경쓰지 않는다. 이 개념은 <code>정보 은닉(Information hiding)</code> 또는 <code>캡슐화(encapsulation)</code>라는 용어로 알려져 있으며, 소프트웨어 설계의 기본적인 원칙 가운데 하나다.</p><h3>정보 은닉(Information Hiding)의 장점</h3><ul><li><code>의존성 최소화</code><blockquote><p>각자 개별적으로 개발하고, 시험하고, 최적화하고, 이해하고, 변경할 수 있도록 한다는 사실에 기초한다. 그렇게 되면 시스템 개발 속도가 올라가는데, 각각의 모듈을 병렬적으로 개발할 수 있기 때문이다.</p></blockquote></li><li><code>각 모듈의 병렬 개발 가능</code></li><li><code>유지 보수의 용이</code><blockquote><p>유지보수의 부담도 낮아지는데, 모듈 각각을 좀 더 빨리 이해할 수 있을 뿐 아니라 다른 모듈에 영향을 끼칠 걱정 없이 디버깅을 진행할 수 있기 때문이다.</p></blockquote></li><li><code>효과적인 성능 튜닝 용이</code><blockquote><p><code>정보 은닉의 원칙이 좋은 성능을 자동적으로 보장하는 것은 아니지만, 효과적인 성능 튜닝(tunning)을 가능하게 하는 것은 사실이다.</code> 시스템이 완성된 다음에 어떤 모듈이 성능 문제를 일으키는지 <code>프로파일링(profiling)</code>하기 용이하기 떄문이다.</p></blockquote></li><li><code>재사용성 향상</code></li><li><code>대규모 개발 RISK 감소</code></li></ul><h3><strong>원칙</strong></h3><p><code>각 클래스와 멤버는 가능한 한 접근 불가능하도록 만들어라</code></p><blockquote><p>개발 중인 소프트웨어의 정상적인 동작을 보증하는 한도 내에서 가장 낮은 접근 권한을 설정하라</p></blockquote><p>최상위 레벨 클래스와 인터페이스에 부여할 수 있는 접근 권한은 package-private과 public 두가지다.<br>package-private으로 선언하면 API의 일부가 아니라 구현 세부사항이 됨으로 다음번 릴리즈에 클라이언트 코드를 깨뜨릴 걱정없이 변경하거나 삭제가 가능하다. 하지만 Public으로 선언하게 되면 호환성을 보장하기 위해 해당 개체를 계속 지원해야 한다.</p><p><code>필드</code>나 <code>메서드</code>, <code>중첩 클래스(nested class)</code>, <code>중첩 인터페이스(nested interface)</code> 같은 멤버의 접근 권한은 아래의 네 개 중 하나로 설정할 수 있다.</p><ul><li><code>private</code> - private으로 선언된 멤버는 선언된 최상위 레벨 클래스 내부에서만 접근 가능 하다.</li><li><code>package-private</code> - package-private로 선언된 멤버는 같은 패키지 내의 아무 클래스나 사용할 수 있다. 기본 접근 권한(defualt access)로 알려져 있는데, 멤버를 선언 할 떄 아무런 접근 권한 수정자(<code>access modifier</code>)도 붙이지 않으면, 이 권한이 주어진다.</li><li><code>protected</code> - protected로 선언된 멤버는 선언된 클래스 및 그 하위 클래스만 사용할 수 있다.</li><li><code>public</code> - public은 어디에서나 사용 가능하다.</li></ul><h3><strong>객체 필드(instance field)는 절대로 Public으로 선언하지 마라</strong></h3><p>비 final 필드나 변경 가능한 객체에 대해 final 참조 필드를 public으로 선언하면 필드에 저장될 값을 제한할 수 없게 된다. 따라서 그 필드에 관계된 불변식을 강제할 수 없다. 필드가 변경될 떄 특정한 동작이 실행되도록 할수도 없으므로 <strong>변경가능 public 필드를 가진 클래스는 다중 스레드에 안전하지 않다.</strong></p><h3><strong>길이가 0이 아닌 배열은 언제나 변경 가능하므로, <code>public static final 배열 필드를 두거나, 배열 필드를 반환하는 접근자를 정의하면 안된다</code></strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//보안 문제를 초례할 수 있는 코드</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>이 문제를 고치는 두가지 방법</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Array.asList(PRIVATE_VALUES));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123; <span class="keyword">return</span> PRIVATE_VALUES.clone(); &#125;</span><br></pre></td></tr></table></figure><p>클라이언트가 어떤 작업을 해야하는지에 따라 두가지 방법중 하나를 선택하면 된다.</p><p>출처 : 조슈아 블로크, 『 Effective Java 2/E』, 이병준 옮김, 인사이트(2014.9.1), 규칙13 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;규칙 13. 클래스와 멤버의 접근 권한은 최소화하라&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;잘 설계된 모듈과 그렇지 못한 모듈을 구별 짓는 가장 중요한 속성 하나는 모듈 내부의 데이터를 비롯한 구현 세부사항을 다른 모듈에 잘 감추느냐의 여부에 달려있다.&lt;/c
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Access Modifier" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/Access-Modifier/"/>
    
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/tags/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Access Modifier" scheme="http://jungha-cho.github.io/tags/Access-Modifier/"/>
    
  </entry>
  
  <entry>
    <title>12. NIO 개요 01.자바 IO는 느리다?</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOWhatIO/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOWhatIO/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:49:14.482Z</updated>
    
    <content type="html"><![CDATA[<h1>12. NIO 개요 01.자바 IO는 느리다?</h1><p>블록킹 자바 IO<br>구 JVM, JRE1.4는 JVM 프로세스에서 커널을 거쳐 파일 디스크립터로 read() 처럼 시스템 콜을 간접적으로 이용한다. 풀어보자면 자바에서 파일 읽기를 시도하면 제일 먼저 커널에 명령을 전달한다. 커널은 시스템 콜(read())을 사용해서 디스크 컨트롤러가 물리적 디스크로부터 읽어온 파일 데이터를 커널 영역 안의 버퍼로 저장한다. 그 후 모든 파일 데이터가 커널 안의 버퍼로 복사되면 JVM(프로세스) 안의 버퍼로 복사를 시작한다.</p><p>이과정에서 두가지 비효율적인 부분이 있다.</p><ol><li><p>커널 영역 버퍼에서 프로세스 영역 안의 버퍼로 데이터를 복사한다는 점이다. 물리적 디스크에서 커널 영역의 버퍼로 데이터를 저장하는 것은 디스크 컨트롤러가 DMA 기술을 이용해 CPU의 도움없이 처리할 수 있다. 하지만 커널 영역에서 프로세스 영역 버퍼로의 데이터 전달은 CPU가 관여해야 하기 때문에 느리다.</p></li><li><p>디스크 컨트롤러에서 커널 역역의 버퍼로 데이터를 복사하는 동안 프로세스 영역은 블록킹 된다. 운영체제는 효율을 높이기 위해 최대한 많은 양의 데이터를 커널 영역의 버퍼에 저장한 후 프로세스 영역의 버퍼로 전달한다. 따라서 디바이스의 파일 데이터를 커널 영역 안의 버퍼로 모두 복사할 때까지 자바 프로세스 ( 파일 읽기를 요청한 자바 스레드)가 블록킹된다.</p></li></ol><p>이러한 이유로 시스템 콜을 직접 사용하는 C나 C++ 등의 저수준 언어에 비해 자바의 IO가 느리다.</p><h3>03. IO 향상을 위한 운영체제 수준의 기술</h3><ol><li>buffer<br>버퍼(buffer)는 데이터를 효율적으로 전달하기 위한 객체이다. 데이터를 한 개씩 여러번 반복적으로 전달하는 것보다는 중간에 버퍼를 두고 그 버퍼에 데이터를 모아 한 번에 전달하는 것이 훨씬 효율적이다. 그렇기 때문에 데이터를 전송하는 곳에서는 대부분 버퍼를 기본적으로 사용한다.</li></ol><p>3가지 테스트 케이스</p><ol><li>파일을 복사하는 간단한 코드에서 1byte씩 복사하는 방법.</li><li>2048byte씩 복사하는 방법</li><li>파일 크기 만큼 복사하는 방법.</li></ol><p>위 케이스는 1에서 3으로 갈수록 속도가 빨라진다.</p><ol start="2"><li>Scatter / Gather<br>자바 프로그램 안에서 버퍼 세 개를 만들어 사용하는 경우, 동시에 각각 읽고 쓰는 작업을 수행할 때 각각, 세번의 시스템 콜이 일어날 것이다. 이는 비효율적인 것으로 이를 해결하기 위해 운영체제 수준에서 지원하는 기술이 Scatter/Gather이다.</li></ol><p>Scatter/Gather를 사용하면 시스템 콜을 한 번만 호출한다. 대신 시스템 콜을 한 번 호출할 때마다 사용할 버퍼의 주소 목록을 넘겨줌으로서 운영체제에서는 최적화된 로직을 사용해 주어진 버퍼들로부터 순차적으로 데이터를 읽거나 쓴다.</p><p>3개의 버퍼가 있을 경우 커널 영역의 버퍼에서 나갈때 들어올때 분산 처리 방식을 이용하는 것 같다. 아직 이해는 되지 않는다.</p><p>또한 NIO에서는 성능 향상을 위해 운영체제에서 지원하는 Scatter/Gather 기능을 이용하기 위해 ScatteringByteChannel과 GatheringByteChannel 인터페이스를 사용한다.</p><ol start="3"><li>가상 메모리<br>가상 메모리는 프로그램이 사용할 수 있는 주소 공간을 늘리기 위해 운영체제에서 지원하는 기술이다. 운영체제는 가상 메모리를 페이지라는 고정된 크기로 나누고 각 페이지는 메모리가 아닌 디스크에 먼저 저장된다. 그리고 실제 프로그램이 실행되는데 필요한 페이지의 가상주소만을 물리적 메모리주소로 바꿔, 실제 메인 메모리에 올려놓는 것이다.</li></ol><p>이러한 가상 메모리를 사용할때 생기는 장점으로는 두가지가 있다.</p><ol><li>실제 물리적 메모리 크기보다 큰 가상 메모리 공간을 사용할 수 있다는 점이다.</li><li>여러 개의 가상 주소가 하나의 물리적 메모리 주소를 참조함으로써 메모리를 효율적으로 사용할 수 있게 해준다는 것이다.</li></ol><p>프로그램 상에서 JVM이 커널 영역의 버퍼에서 복사하는 과정을 생각해 볼때 이 가상 메모리를 이용하게 되면<br>커널 영역에 저장하는 동시에 유저 영역에서 저장하는 것과 같은 효과를 볼수 있다. JVM과 커널 영역이 같은 주소를 참조하게 된다면 말이다. 이는 느린 자바 IO를 해결할 수 있는 중요한 단서가 된다.</p><p>가상 메모리의 장점 중 하나가 &quot;실제 물리적 메모리 크기보다 큰 가상 메모리 공간을 사용할 수 있다&quot;는 것이다. 이를 실현하려면 메모리 페이징이라는것을 사용해야 한다. 메모리 페이징은 일반적인 메모리 페이지 사이ㅣ즈인 1024, 2048 등의 하나로, 운영체제에서 사용하는 페이징 크기로 물리적 디스크에 저장된다. 그리고 이들 각각은 물리적 메모리의 특정 주소를 참조하고 있다가 특정 페이지 부분이 필요하다면 디스크에 저장된페이지를 물리적 메모리에 읽어들여 사용한다.</p><ol start="4"><li>메모리 맵 파일<br>간단한 워드 프로그램을 만들었다고 가정하자면 워드 프로그램 특성상 수행중에 파일을 읽고 쓰는 작어이 빈번할 것이다. 그럴때마다 비용이 값비싼 시스템 콜과 더불어 불필요한 커널 영역과 유저 영역 버퍼 간의 복사가 이루어질 것이다. 또한 복사의 댓가로 많은 가비지가 생긴다. 또 이러한 가비지는 가비지 컬렉터가 빈번하게 호출되는데 이 가비지 컬렉터가 가비지를 수거하는 것은 상당히 느린 작업이다. 이런 이유로 파일의 크기가 커지면 저장하거나 읽을 데이터의 크기가 클수록 성능은 나빠진다.</li></ol><p>이러한 문제점을 해결하기 위해 운영체제에서 지원하는 것이 Memory-mapped IO다. Memory-mapped IO는 파일 시스템의 페이지들과 유정 영역의 버퍼를 가상 메모리로 맵핑 시킨다.</p><p>메모리 맵 파일을 사용하면 많은 장점을 얻을수 있다.</p><ol><li>프로세스가 파일 데이터를 메모리로서 바라보기 때문에 read(), write() 시스템 콜을 할 필요가 없다는 점이다. 프로세스가 파일 데이터를 변경하면 별도의 입출력 과정을 거치지 않고 변경된 부분을 물리적 디스크에 자동으로 반영하게 되고 커널 영역에서 유저 영역으로 버퍼를 복사할 필요도 없다.</li><li>매우 큰 파일을 복사하기 위해 많은 양의 메모리를 소비하지 않아도 된다는 것이다. 파일 시스템의 페이지들을 메모리로서 바라보기 때문에 그때그때 필요한 부분만을 실제 메모리에 올려놓고 사용하면 되므로 효율적으로 메모리를 사용할 수 있다.</li></ol><p>NIO에서는 byteBuffer를 상속하는 MappedByteBuffer라는 클래스가 있는데, 바로 메모리 맵 파일과 관련해서 사용되는 버퍼다.</p><ol start="5"><li>파일 락<br>파일 락은 스레드의 동기화와 거의 비슷한 개념이다. 한 프로세스가 어떤 파일에 락을 획득했을 때, 다른 프로세스가 그 파일로 동시에 접근하는것을 막거나 또는 접근하는 방식에 제한을 두는 것이다. 이런 경우 파일의 전체 또는 일부분을 잠궈서 사용하는데 이때 바이트 단위로 계산해서 파일의 잠글 부분을 계산한다. 이렇게 파일의 일부분만을 잠궈서 사용함으로써 락이 설정되지 않은 파일의 다른 위치에서 여러 프로세스들이 동시에 다른 작업을 할 수 있게 되는 것이다.</li></ol><p>파일 락은 크게 공유(shared) 락과 베타(exclusive) 락, 두가지로 나눌 수 있다. 일반적으로 공유 락은 읽기 작업에 사용되고 베타 락은 쓰기 작업에 사용된다. 파일 락이 사용되는 가장 대표적인 프로그램은 데이터베이스다. 데이터베이스의 테이블에 저장된 데이터를 읽는 것은 여러 사람이 동시에 접근해서 읽어간다고 별다른 문제가 발생하지 않는다. 이러한 작업에서는 공유 락을 사용한다. 이 경우 읽기 상태에서 읽기 요청이 들어오는 경우 락을 건네 주지만 읽기 상태에서 쓰기 요청이 들어오는 경우 이를 거부한다.</p><p>테이블에서 데이터를 수정하거나 삭제한다고 생각해보자. 스레드의 예처럼 동시에 공유 데이터에 접근해서 수정하려고 한다면 문제가 발생할 것이다.<br>파일 락은 NIO의 파일 채널과 파일 락에서 다루는 부분이다.</p><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 12장 인용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;12. NIO 개요 01.자바 IO는 느리다?&lt;/h1&gt;
&lt;p&gt;블록킹 자바 IO&lt;br&gt;
구 JVM, JRE1.4는 JVM 프로세스에서 커널을 거쳐 파일 디스크립터로 read() 처럼 시스템 콜을 간접적으로 이용한다. 풀어보자면 자바에서 파일 읽기
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
  </entry>
  
  <entry>
    <title>15. 셀렉터 Selector 01. 셀렉터 개요</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOSelector/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOSelector/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:48:56.076Z</updated>
    
    <content type="html"><![CDATA[<h1>01. 셀렉터 개요</h1><p>NIO에서 비블록킹 서버 구현의 밑바탕이 되는 것은 Reactor 패턴이다. 이벤트 중심의 애플리케이션이 하나 이상의 클라이언트로부터 하나의 애플리케이션으로 동시에 전달되는 서비스 요청들을 나눠 각 요청에 상응하는 서비스 제공자에게 구별해서 보내준다. 좀더 자세하게 설명하면 클라이언트들의 모든 요청을 우선 앞단의 큐에 저장하고 큐를 모니터링 하는 스레드에 이벤트를 보낸다. 그러면 큐를 모니터링 하는 스레드는 큐에 저장된 요청의 방향을 분석해서 적절한 프로세스 로직으로 보내줘 해당 요청이 처리되게 해주는 것이 바로 Reactor 패턴이다.</p><p>Selector는 바로 Reactor의 역할을 한다. 즉, 여러 SelectableChannel을 자신에게 등록하게 하고 등록된 SelectableChannel의 이벤트 요청들을 나눠서 적절한 서비스 제공자에게 보내 처리하는 것이다. 즉 멀티플렉스 IO를 가능하게 한다.</p><p>멀티플렉스 IO는 단 하나의 스레드로 동시에 많은 IO 채널들을 효율적으로 관리할 수 있게 해주어 기존의 멀티스레드를 이용한 네트워크 프로그램에 비해 많은 부분에서 훨씬 유리하다. 즉, 좀더 적은 CPU와 자원을 소모하게 됨으로써 기존의 서버보다 좀더 빠르고 많은 동시 접속자를 수용할 수 있는 확장성 있는 서버를 만들 수 있게 되는 것이다.</p><p>( 확장성이란 두 가지 의미를 내포한 단어다. 첫 번째는 어떤 애플리케이션에 기능을 추가하는 것 등이 손쉽게 이루어질 수 있는 것을 말한다. 두 번째, 제한된 CPU, 메모리 등의 자원을 이용해서 최대한의 성능을 내는 것을 말한다. 만약 동일한 컴퓨터에 서버 A는 1000명의 동시 접속자를 수용할 수 있고 서버 B는 5000명의 동시 접속자를 수용할 수 있다면 서버 A 보다 서버 B가 더 확장성 있는 서버라고 할 수 있다.)</p><p>유닉스 환경에서 C/C++로 네트워크 프로그래밍을 해본 독자들이라면 Selector를 이용한 멀티플렉스 모델을 쉽게 이해할 수 있을 것이다. 즉, 자바에서 Selector를 사용하는 것과 같이 select(), poll() 시스템 콜을 이용해서 멀티플렉스 모델의 서버를 만들어 봤을 것이기 때문이다.</p><p>JDK 1.4 이전에는 자바의 IO가 블록킹 모델이었다. 따라서 네트워크 프로그램을 개발할떄, 많은 구조적 문제점이 있었다. 따라서 우선 기존 IO 모델을 이용한 네트워크 프로그램의 문제점이 무엇인지를 알아보고 이 문제를 해결하기 위해 어떤 방법들이 이용되고 있는지를 살펴보겠다.</p><h3>02. 기존의 네트워크 프로그래밍 모델</h3><p>기존의 IO는 블록킹 IO이다. 블록킹 IO란 특정 디바이스에서 읽기, 쓰기(read/write) 작업을 할 때 데이터를 이용할 수 있을떄까지 해당 IO 작업을 수행하려던 스레드가 아무것도 하지않고 대기하는 것을 말한다.</p><p>예를 들어, 소켓으로부터 BufferedReader 객체를 얻어 이 스트림으로부터 데이터를 읽어오기 위해 readLine() 메소드를 호출했다고 가정해보자. readLine() 메소드를 호출했을 때 해당 스트림으로부터 개행문자(\n)를 읽을 떄까지 이 스레드는 블록킹 될 것이다.</p><p>블록킹을 피할 수 있는 두가지 방법 중 하나는</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket ss = new ServerSocket(4567);</span><br><span class="line">while(true) &#123;</span><br><span class="line">    Socket s = ss.accept();</span><br><span class="line">    ...</span><br><span class="line">    // 동시에 여러 클라이언트들의 요청을 수행하기 위해 별도의 스레드를 만들어서 처리한다.</span><br><span class="line">    Service service = new Service(s);</span><br><span class="line">    service.start();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이처럼 멀티 스레드 기반으로 구현하는 것이다. 하지만 이처럼 멀티 스레드 모델은 많은 문제점이 있는데, 우선 해당 서버로 접속하는 클라이언트 수가 많아지면 스레드 개수가 접속된 클라이언트의 수만큼 증가한다는 것이다. 앞서 코드 템플릿을 통해 살펴봤지만 이 구조에서 클라이언트당 하나의 service 스레드를 만들어야만 한다. 따라서 다음과 같은 문제점이 발생한다.</p><p>많은 스레드 생성에 따른 스레드 컨텍스트 스위치 부하<br>서버의 성능과 애플리케이션의 성격에 따라 다르기는 하지만 보통 경량 서버의 경유 약 천여개 정도의 스레드가 생성되면 스레드 컨텍스트 스위치 부하로 인해 급격한 성능 저하가 발생된다.</p><p>스레드 자체가 CPU와 고유 스택을 갖는 데 따른 컴퓨터 리소스 부하<br>모든 스레드는 자신만의 스택 영역을 갖고 스레드는 별도의 실행흐름이므로 CPU를 사용한다.</p><p>클라이언트의 빈번한 접속과 종료에 따라 많은 가비지가 생성되는 문제점<br>서버를 통해 주고받는 데이터는 대부분 일회용이다. 따라서 클라이언트와 데이터를 주고받는 과정에서, 앞서 NIO의 도입부에서 그림을 통해 설명한 것과 같이 JVM 힙 영역으로 데이터의 복사가 빈번하게 이뤄지므로 많은 가비지가 생성된다. 또한 서버에 클라이언트의 연결이 빈번하다면 스레드의 잦은 생성과 소멸에 따른 가비지도 많을 것이다. 이미 알고 있을지 모르겠지만 자바에서 가비지 컬렉터를 실행하는 것은 상당히 느린 작업이다.</p><p>클라이언트가 접속할 때마다 매번 스레드를 새로 생성하는 부담<br>자체 스택을 갖고 있는 스레드를 생성하는 것은 그리 빠른 작업이 아니다. 그런데 그 스레드가 클라이언트와 통신하는 로직까지 들고 있도록 무겁게 설계된 경우에는 더욱더 그럴 것이다.</p><p>서버의 메모리가 부족해서 OutOfMemoryException<br>눈에 보이는 위험성을 가지고 있는 애플리케이션은 결코 좋은 애플리케이션이 아니다. 보통 이런 애플리케이션은 신뢰성이 없다. 예를 들어 보자. 만약, 채팅 서버에 접속해서 친구와 열심히 대화를 하고 있는데 종종 아무런 공지없이 갑자기 서버가 종료된다면 이 채팅서버를 신뢰할 수 없을 것이다. 아마 채팅이 가능한 다른 곳을 알아 볼 것이다.</p><p>이처럼 멀티스레드를 이용한 서버는 확장성(scalable)이 없어서 동시 접속자가 많은 대규모의 서버로 사용하기에는 부적합하다. 또한 C/C++로 만든 서버에 비해 상당히 느리다. 보통 상용 애플리케이션에서는 위의 문제점 중 일부를 해결하기 위해서 스레드풀(ThreadPool)을 사용한다… 보통 스레드 생성시간을 단축시키고 스레드를 재사용 하기 위해서 스레드풀을 이용한다고 생각하지만 가장 중요한 이유는 첫번째와 다섯번째에 있다.</p><p>상용 애플리케이션은 신뢰성이 중요하기 떄문에 스레드풀을 이용해서 서버가 수용할 수 있는 제한된 개수만큼 스레드 생성을 제한해서 최악의 상황(OutOfMemoryException)을 예방하는 것이다. 또한 많은 테스트와 튜닝으로 스레드 컨텍스트 스위치로 인해 급격한 성능 저하가 발생하는 지점을 찾아 그 이전 개수만큼으로 스레드 개수를 제한해서 서버가 항상 최적의 상태로 동작하는 것을 보장하게 만드는 것이다. 하지만 스레드풀을 사용한다고 하더라도 확장성(scalable) 문제는 어쩔 수 없다.</p><p>그렇지만 많은 전문가들은 다른 방법보다 멀티스레드를 이용하는 것이 개발기간 개발효율 등을 고려했을때 가장 나은 선택이라고 판단해서 서버 프로그래밍을 할때 ㅐ부분 멀티스레드를 이용하는 방법을 사용했다.</p><p>그러나 멀티스레드를 포함한 기존 블록킹 IO의 문제를 해결하는 방법 중에서 가장 효율성을 인정받는 방법은 바로 JNI를 이용해서 기존의 C/C++ 개발자들 처럼 Select(), poll() 시스템 콜을 사용하는 것이다. 하지만 이 방법은 개발 난이도가 상당히 높아 쉽게 구현할 수 없다는 점이 문제다. 따라서 많이 사용되지 않는다.</p><h3>03. 비블록킹 모델</h3><p>멀티플렉스 모델의 서버를 만들기 위해 핵심적인 역할을 하는 것이 바로 Selector, SelectableChannel, SelectionKey 클래스다. 이 클래스 세 개가 각각 어떤 기능을 수행하고 또 서로 간에 어떻게 협력하는지를 이해하면 멀티플렉스 모델의 서버를 만들기 위한 핵심을 이해하는 것이다.</p><p>블록킹 모드의 경우 일반적으로 다음과 같은 코드 템플릿을 이용한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    byte buffer[] = new byte[4096];</span><br><span class="line"></span><br><span class="line">    while(true) &#123;</span><br><span class="line">        int r = in.read(buffer);</span><br><span class="line">        String message = new String(buffer, 0, r);</span><br><span class="line">        System.out.println(message);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch(IOException ie)&#123;&#125;</span><br></pre></td></tr></table></figure><p>int r = in.read(buffer)를 실행하는 순간에 읽어들일 데이터가 없다면 이 스레드는 블록킹된다. 따라서 기존에 멀티스레드로 이처럼 블록킹 될 수 있는 부분은 별도의 부분에서 처리하도록 스레드를 이용해 분리하는 방법을 사용했다.</p><p>이제 NIO에서 멀티스레드를 사용하지 않고 비블록킹을 사용해서 스레드 단 하나만으로도 멀티스레드 서버와 같은 동작을 할 수 있는지, 그 워크 플로우를 설명한다.</p><ul><li>이미 생성된 바운드 되어 있는 채널(SelectableChannel)들을 Selector에 자신이 발생시키고 싶은 이벤트(OP_ACCEPT, OP_READ 등)와 함께 등록한다. 이렇게 채널을 Selector에 등록하면 이 등록에 관련된 채널과 Selector 사이의 관계를 캡슐화한 SelectionKey가 Selector에 저장되고 또한 등록하는 메소드의 리턴 값으로 이렇게 생성된 SelectionKey가 리턴된다.</li><li>SelectionKey는 어떤 채널이 어떤 Selector에 등록되었는지, 또한 이 채널이 Selector에 등록할 때 어떤 모드로 등록했는지, 이 채널이 등록한 모드에 대한 동작할 준비가 되었는지 등의 정보를 가지고 있게 된다. 따라서 어떤 채널이 자신이 등록한 모드에 대해 동작할 준비가 되면 SelectionKey는 그 준비상태를 내부적으로 저장하고 있게 된다. 예를 들어 서버 소켓 채널의 경우에는 접속한 클라이언트를 Accept할 준비가 된 상태, 소켓 채널의 경우에는 클라이언트가 보낸 데이터를 읽을 준비가 된 상태를 말한다. 그 후 Selector가 select() 메소드를 호출해서 자신에게 등록된 모든 SelectionKey들을 검사하는데, 바로 동작할 준비가 되어있는지 아닌지를 검사하는 것이다. 이 검사를 통해 동작할 준비가 된 SelectionKey의 집합(Set)을 얻어서 이것들을 하나씩 순서대로 꺼내서 요청한 이벤트에 대해 적절히 처리하는 것이다.</li></ul><h3>04. SelectableChannel</h3><p>SelectableChannel은 모든 소켓 채널들의 수퍼클래스이다. SelectableChannel에는 두 가지 기능이 있는데그 한 가지가 채널을 블록킹이나 비블록킹 모드로 설정하는 것이고 다른 하나는 Selector에 등록하는 것이다. 이를 15장에서 자세히 알아본다고 말하고 넘어갔다. 이제 그 남은 기능인 채널을 Selector에 등록하는 방법에 대해 알아볼 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class SelectableChannel extends AbstractChannel implements Channel &#123;</span><br><span class="line">    // 블록킹-비블록킹 모드 설정에 관련된 메소드들</span><br><span class="line">    public abstract void configureBlocking(boolean block) throws IOException;</span><br><span class="line">    public abstract boolean isBlocking();</span><br><span class="line">    public abstract Object blockingLock();</span><br><span class="line"></span><br><span class="line">    // 채널을 Selector에 등록하는 것과 관련된 메소드들</span><br><span class="line">    public abstract SelectionKey register(Selector sel, int ops) throws ClosedChannelException;</span><br><span class="line">    public abstract SelectionKey register(Selector sel, int ops, Object att) throws ClosedChannelException;</span><br><span class="line">    public abstract SelectionKey keyFor(Selector sel);</span><br><span class="line">    public abstract int validOps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 15장 인용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;01. 셀렉터 개요&lt;/h1&gt;
&lt;p&gt;NIO에서 비블록킹 서버 구현의 밑바탕이 되는 것은 Reactor 패턴이다. 이벤트 중심의 애플리케이션이 하나 이상의 클라이언트로부터 하나의 애플리케이션으로 동시에 전달되는 서비스 요청들을 나눠 각 요청에 상응
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Selector" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Selector/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
  </entry>
  
  <entry>
    <title>13. 버퍼 01. 버퍼 개요</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOWhatIOBuffer/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOWhatIOBuffer/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:49:50.738Z</updated>
    
    <content type="html"><![CDATA[<h1>01. 버퍼 개요</h1><p><img src="http://cfile23.uf.tistory.com/image/270D0C4F58C92481152819" alt="img"><br>버퍼는 운영체제의 커널이 관리하는 시스템 메모리를 직접 사용할 수 있다. 기존에는 버퍼 대신 주로 바이트 배열(byte[], 배열도 객체다)을 사용했기 때문에 JVM의 힙 영역에 메모리가 할당되고 맨 처음으로 바이트 배열의 초기 값이 시스템 메모리로 한 번 복사되어야 했다. 이렇게 초기 한 번 뿐이지만 복사가 이루어진다는 점도 성능에 나쁘게 작용했지만 결정적으로 DMA, 가상 메모리, 메모리 맵 파일 등의 운영체제 수준에서 제공해주는 유용한 기능들까지도 사용할 수 없다는 점이 가장 큰 단점이었다.</p><p>이에 대한 해법으로 C/C++에서 포인터를 사용하듯이 자바에서도 직접 시스템 메모리를 사용할 수 있는 버퍼(Buffer) 클래스를 java.nio 패키지에 포함시켰다.</p><p><img src="http://cfile8.uf.tistory.com/image/256AF73E58C929B62681DE" alt="img2"><br>그림에서 볼 수 있듯이 java.nio 패키지는 크게 Buffer 클래스와 ByteOrder 클래스로 나눠진다. 먼저 ByteOrder 클래스에 대해 간단히 살펴보자.</p><p>컴퓨터마다 바이트를 저장하는 순서가 다르다. Big Endian과 Little Endian으로 구분할 수 있다. 자바는 기본적으로 네트워크에서 사용하는 빅 엔디안을 사용하고 대부분의 유닉스 운영체제 역시 빅 엔디안 방식을 사용한다. 반면 윈도우 운영체제의 경우에는 리틀 엔디안을 사용한다. ByteOrder 클래스는 버퍼, 즉 메모리의 바이트 순서를 조정해 주기 위해 사용되는데 사실 거의 사용되지 않는다고 봐도 무방하다.</p><h3>Buffer</h3><p>buffer 클래스는 자신을 상속하는 하위 클래스들에서 공통적으로 사용할 메소드들을 정의한 부모 클래스다. buffer를 상속하는 각각의 하위 클래스들은 Buffer 계층 구조에서 클래스 명을 볼 수 있듯이 boolean을 제외하고 모두 기본 형식의 버퍼들이다. 버퍼는 어떤 하나의 데이터 형태들을 저장하는 컨테이너라고 할 수 있다. 버퍼는 시작과 끝이 있는 일직선 모양의 데이터 구조를 갖고 내부적으로 자신의 상태 정보를 네 가지 기본 속성 값에 저장한다. 또한 이렇게 각 버퍼에 있는 네 가지 기본 속성들을 편리하게 제어할 수 있는 다양한 유틸리티 메소드들을 제공해준다. 따라서 배열보다 훨씬 사용하기 편하고 강력한 기능들을 갖추고 있다.</p><h1>02. 버퍼의 네 가지 기본 속성</h1><p>모든 버퍼들의 부모 클래스인 Bufer는 네가지 속성이 있다. 각각의 버퍼는 자체적으로 이 속성들을 저장하고 있고 이 속성을 이용해서 버퍼 자체를 제어하는 것이다.</p><p><img src="http://cfile23.uf.tistory.com/image/2633873558C92DE33071A1" alt="img3"><br>mark를 제외한 나머지 세 개의 속성 값은 음수를 가질 수 없다. 단, mark 속성만이 초기 값으로 -1을 갖는다. 눈여겨볼 또 다른 점은 capacity 속성을 착각하면 안 된다는 점이다. capacity 속성은 버퍼의 바이트 크기를 정하는 것이 아니라 각 형식 버퍼에 맞는 기본 형식의 데이터를 각각의 기본형 버퍼 클래스에 몇 개나 넣을 수 있는지를 나타내는 것이다.</p><p>즉, IntBuffer의 Capacity를 100으로 정했다면 이 버퍼에는 int를 100개 넣을 수 있다는 의미다. 따라서 1024를 초기 값으로 지정해준 경우, ByteBuffer는 실제 1024Byte의 메모리를 점유하고, int는 4byte이므로 IntBuffer는 4096Byte를 long은 8Byte이므로 LongBuffer는 8192Byte를 갖게 된다.</p><p>이 네가지의 속성의 관계는 다음과 같다.</p><p><code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></p><p><img src="http://cfile26.uf.tistory.com/image/23517D4658C931F50F15B4" alt="img4"><br>capacity가 10인 버퍼를 생성하면 위와 같은 모습이 된다. 앞서 버퍼의 속성을 통해 본것처럼 position은 0으로 설정되어 있고 limit와 capacity는 10으로 설정되어 있다. 이제 앞으로 이렇게 생성된 Buffer 클래스의 position, limit, mark 속성을 적절히 제어하면서 버퍼를 이용할 것이다. Buffer 클래스는 이 기본 속성들을 제어하는 다양한 메소드들을 제공하는데, 우선 다음의 API를 살펴보자</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Buffer &#123;</span><br><span class="line">    public final int position();</span><br><span class="line">    public final int limit();</span><br><span class="line">    public final int capacity();</span><br><span class="line"></span><br><span class="line">    public final Buffer position(int newPosition);</span><br><span class="line">    public final Buffer limit(int newLimit);</span><br><span class="line"></span><br><span class="line">    public final Buffer mark();</span><br><span class="line">    public final Buffer reset();</span><br><span class="line"></span><br><span class="line">    public final int remaining();</span><br><span class="line">    public final boolean hasRemainig();</span><br><span class="line">    public abstract boolean isReadOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buffer 클래스에서 제공하는 메소드 중 일부분을 나타냈다. 버퍼 계열 클래스 모두가 공통적으로 사용하는 메소드들이기 때문에 오버라이딩되는 것을 막기 위해서 메소드들을 final로 지정했다는 것이 눈여겨볼 점이다. 다만 생성하는 시점에 결정되는 읽기 전용 버퍼인지를 나타내는 isReadOnly() 메소드는 추상(abstract) 메소드로 지정해서 나중에 구현 클래스에서 오버라이딩해서 구현하게 해놨다.</p><p><code>첫째 문단의 메소드 세 개는 position, limit, capacity 위치 값을 리턴하는 간단한 getter 메소드다.</code><br><code>둘째 문단의 메소드 두 개는 position과 limit의 위치 값을 지정해주는 setter 메소드다.</code><br><code>셋째 문단에 위치한 mark() 메소드는 현재 포지션을 mark 속성에 저장하게 한다. 그리고 이렇게 저장된 mark 위치로 나중에 이동하고 싶을때 reset() 메소드를 사용하면 된다. 하지만 mark() 메소드로 mark 속성 값을 설정하지 않고 reset() 메소드를 호출하면 InvalidMarkException이 발생한다. 또한 Position이나 limit 값이 mark 위치보다 작은데도 reset() 메소드를 호출하면 InvalidMarkException이 발생한다. 다음은 mark() 메소드와 reset() 메소드의 간단한 사용 템플릿 예다.</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf.position(1);    // position = 1</span><br><span class="line">buf.mark();         // mark = 1</span><br><span class="line">buf.position(5);    // position = 5</span><br><span class="line">buf.reset();        // position = mark = 1</span><br></pre></td></tr></table></figure><p>Buffer 계열 클래스들은 체이닝을 이용하도록 디자인되어 있다. API를 보면 알 수 있겠지만 대부분의 메소드에는 Buffer 또는 각 구현 형식별 버퍼 클래스가 리턴 된다. 버퍼 클래스에 이렇게 체이닝 디자인을 도입한 이유는 체이닝이 코드량을 줄여주며 코드를 명확하고 이해하기 쉽게 해주기 때문이다. 쳉닝을 이용해서 앞서 설명한 mark(), reset() 메소드를 이용하는 코드 템플릿을 만들면 다음과 같이 한 줄로 표현할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.position(1).mark().position(5).reset();</span><br></pre></td></tr></table></figure><p>Buffer 클래스는 효율성을 높이기 위해 디자인까지 신경을 썻다.</p><p>넷째 문단에 위치한 remaining() 메소드는 &quot;limit - position&quot;과 같은 뜻이다. 즉, 현재 position을 기준으로 해서 버퍼에 읽을 수 있는 데이터가 몇 개나 남았는지를 알려주는 메소드다. hasRemaining() 메소드는 &quot;(limit - position &gt; 0)&quot;을 의미한다. 즉, 현재 position을 기준으로 해서 버퍼에 읽을 수 있는 데이터가 있는지 없는지를 boolean형 값으로 리턴해주는 것이다. isReadOnly() 메소드는 버퍼가 읽기 전용인지 아닌지를 알려주는 메소드다.</p><p>필자는 앞으로 ByteBuffer를 기준으로 해서 설명할 것이다. 그 이유는 ByteBuffer가 가장 많이 사용되고 있으며 또한 다른 버퍼들도 거의 동일한 형식의 메소드를 제공하고 사용법도 유사하므로 ByteBuffer만 제대로 활용할 줄 안다면 다른 형식의 버퍼도 API를 보고 쉽게 이용할 수 있기 때문이다.</p><h3>03. 버퍼에서 데이터 읽고 쓰기</h3><p>Buffer 클래스를 상속하는 모든 하위 클래스들을 다양한 형식으로 데이터를 읽거나 쓸 수 있는 메소드를 제공한다. 다음은 ByteBuffer가 제공하는 메소드의 일부분이다. 하지만 다른 버퍼들도 메소드 파라미터와 리턴 값만이 다른 동일한 메소드를 제공하고 있으므로 사용법은 동일하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//상대적 위치로 읽고 쓰기</span><br><span class="line">public abstract byte get();</span><br><span class="line">public abstract ByteBuffer put(byte b);</span><br><span class="line"></span><br><span class="line">//절대적 위치로 읽고 쓰기</span><br><span class="line">public abstract byte get(int index);</span><br><span class="line">public abstract ByteBuffer put(int index, byte b);</span><br><span class="line"></span><br><span class="line">//버퍼의 데이터를 주어진 배열로 읽고 쓰기</span><br><span class="line">public ByteBuffer get(byte[] dst);</span><br><span class="line">public ByteBuffer get(byte[] dst, int offset, int length);</span><br><span class="line">public final ByteBuffer put(byte[] src);</span><br><span class="line">public ByteBuffer put(byte[] src, int offset, int length);</span><br><span class="line"></span><br><span class="line">//파라미터로 주어진 버퍼의 내용을 쓰기</span><br><span class="line">public ByteBuffer put(ByteBuffer src);</span><br></pre></td></tr></table></figure><h3>1. 상대적 위치를 이용해서 1바이트씩 읽고 쓰기</h3><p>상대적 위치를 이용해서 버퍼에 데이터를 읽거나 쓰는 메소드는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//상대적 위치로 읽고 쓰기</span><br><span class="line">public abstract byte get();</span><br><span class="line">public abstract ByteBuffer put(byte b);</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ....</span><br><span class="line">byte b = buf.get();</span><br></pre></td></tr></table></figure><p>이렇게 buf.get()을 호출하게 되면 position은 현재 위치의 요소를 가져오고 position은 1이 더해진 값으로 이동한다. 그러나 limit와 capacity 위치는 변화가 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//버퍼에 쓰는 것</span><br><span class="line">ByteBuffer buf = ...</span><br><span class="line">but.put((byte) z);</span><br></pre></td></tr></table></figure><p>put을 호출하게 되면 현재 위치의 요소에 z가 삽입되게 되고 position은 1이 ㄷㅓ해진다. limit와 capacity는 변동이 없다.<br>지속적으로 get, put 메소드를 호출하게 되면 총 크기의 범위를 벗어나게 되면 각각 BufferUnderflowException과 BufferOverflowException이 발생한다는 점이다. 따라서 읽고 쓰기 전에 항상 현재 position과 limit를 비교한 후에 버퍼에 데이터를 읽거나 쓰는 것이 바람직하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line">public class RelativeBufferTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        //크기가 10인 ByteBuffer를 생성한다.</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(10);</span><br><span class="line">        System.out.println(&quot;Init Position : &quot; + buf.position());</span><br><span class="line">        System.out.println(&quot;, Init Limit : &quot; + buf.limit());</span><br><span class="line">        System.out.println(&quot;, Init Capacity : &quot; + buf.capacity());</span><br><span class="line"></span><br><span class="line">        // 현재 position이 0인데, 이곳에 mark를 해둔다.</span><br><span class="line">        buf.mark();</span><br><span class="line">        // a, b, c를 순서대로 버퍼에 넣는다.</span><br><span class="line">        buf.put((byte) 10).put((byte) 11).put((byte) 12);</span><br><span class="line">        // mark해둔 0 인덱스로 position을 되돌린다.</span><br><span class="line">        buf.reset();</span><br><span class="line"></span><br><span class="line">        //현재 position의 버퍼에 있는 데이터를 출력한다.</span><br><span class="line">        System.out.println(&quot;Value : &quot; + buf.get() + &quot;, Position : &quot; + buf.position());</span><br><span class="line">        System.out.println(&quot;Value : &quot; + buf.get() + &quot;, Position : &quot; + buf.position());</span><br><span class="line">        System.out.println(&quot;Value : &quot; + buf.get() + &quot;, Position : &quot; + buf.position());</span><br><span class="line">        //position 4는 아무 값도 넣지 않았지만 기본적으로 0이 입력됨을 볼 수 있다.</span><br><span class="line">        System.out.println(&quot;Value : &quot; + buf.get() + &quot;, Position : &quot; + buf.position());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>초기 값이 position은 0, limit와 capacity는 10으로 설정되어 있다. 이 코드에서 눈여겨볼 것은 마지막 출력 행에서 버퍼의 인덱스가 4인 위치에서 아무런 데이터를 넣지 않았는데 Null이 아닌 0이 나온다.</p><h3>2. 절대적 위치를 이용해서 1바이트씩 읽고 쓰기</h3><p>절대적 위치를 이용해서 버퍼에 데이터를 읽거나 쓰기 위한 메소드.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//절대적 위치로 읽고 쓰기</span><br><span class="line">public abstract byte get(int index);</span><br><span class="line">public abstract ByteBuffer put(int index, byte b);</span><br></pre></td></tr></table></figure><p>상대적인 방법이 현재 position을 이용해 데이터를 읽거나 썻다면 절대적인 방법은 어느 위치의 데이터를 읽고 쓸지 그 위치를 직접 지정해서 읽거나 쓰는 방식이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer but = ....</span><br><span class="line">byte b = buf.get(5);</span><br></pre></td></tr></table></figure><p>이처럼 5의 위치의 요소를 읽는다. 하지만 상대적 위치와는 달리 Position의 위치에는 변화가 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer but = ....</span><br><span class="line">buf.put(5, (byte) z);</span><br></pre></td></tr></table></figure><p>지정한 위치에 데이터를 쓰면 5번 위치의 요소에 z가 삽입되며 Position 위치 또한 변화가 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line">public class AbsoluteBufferTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //크기가 10인 ByteBuffer 배열을 생성한다.</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(10);</span><br><span class="line">        System.out.print(&quot;Init Position : &quot; + buf.position());</span><br><span class="line">        System.out.print(&quot;, Init Limit : &quot; + buf.limit());</span><br><span class="line">        System.out.println(&quot;, Init Capacity : &quot; + buf.capacity());</span><br><span class="line"></span><br><span class="line">        buf.put(3, (byte) 3);</span><br><span class="line">        buf.put(4, (byte) 4);</span><br><span class="line">        buf.put(5, (byte) 5);</span><br><span class="line">        //위치를 지정해서 쓴 경우에는 position이 변하지 않는다.</span><br><span class="line">        System.out.println(&quot;Position : &quot; + buf.capacity());</span><br><span class="line"></span><br><span class="line">        buf.put(3, (byte) 3);</span><br><span class="line">        buf.put(4, (byte) 4);</span><br><span class="line">        buf.put(5, (byte) 5);</span><br><span class="line">        //위치를 지정해서 쓴 경우에는 position이 변하지 않는다.</span><br><span class="line">        System.out.println(&quot;Position : &quot; + buf.position());</span><br><span class="line"></span><br><span class="line">        // 버퍼에 있는 데이터를 출력한다. 역시 position이 변하지 않는다.</span><br><span class="line">        System.out.println(&quot;Value : &quot; + buf.get(3) + &quot;, Position : &quot; + buf.position());</span><br><span class="line">        System.out.println(&quot;Value : &quot; + buf.get(4) + &quot;, Position : &quot; + buf.position());</span><br><span class="line">        System.out.println(&quot;Value : &quot; + buf.get(5) + &quot;, Position : &quot; + buf.position());</span><br><span class="line">        // position 9에는 아무 값도 넣지 않았지만 기본적으로 0이 입력됨을 볼 수 있다.</span><br><span class="line">        System.out.println(&quot;Value : &quot; + buf.get(9) + &quot;, Position : &quot; + buf.position());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>3. 배열을 이용해서 한꺼번에 많은 데이터를 읽고 쓰기</h3><p>배열을 이용해서 버퍼에 데이터를 읽거나 쓰기위해 제공 되는 메소드</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//버퍼의 데이터를 주어진 배열로 읽고 쓰기</span><br><span class="line">public ByteBuffer get(byte[] dst);</span><br><span class="line">public ByteBuffer get(byte[] dst, int offset, int length);</span><br><span class="line">public final ByteBuffer put(byte[] src);</span><br><span class="line">public ByteBuffer put(byte[] src, int offset, int length);</span><br></pre></td></tr></table></figure><p>만약, 버퍼에 데이터를 한꺼번에 많이 읽거나 써야할 때 지금까지 공부한 방법을 이용할 경우, 다음의 코드 템플릿 형태로 읽게 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; buffer.hasRemaining(); i++) &#123;</span><br><span class="line">    byteArray(i) = buffer.get();</span><br><span class="line">&#125;</span><br><span class="line">//또는</span><br><span class="line">int size = buffer.remaining();</span><br><span class="line">for (int i = 0; i &lt; size; i++)&#123;</span><br><span class="line">    byteArray[i] = buffer.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 루프를 이용해서 대량의 데이터를 읽거나 쓰는 것은 이제부터 설명할 메소드를 이용하는 것보다 코드가 길다는 것을 제외하고도 매번 반복적으로 get() 또는 put() 메소드를 호출해야 하는 비효율적인 방법이다. 버퍼에서는 이런 경우에 대비해서 배열을 이용해서 데이터를 버퍼에서 읽거나 쓸 수 있게 제공해 준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(10);</span><br><span class="line">Byte[] bulk = new byte[5];</span><br><span class="line">...</span><br><span class="line">byte b = buf.get(bulk);</span><br></pre></td></tr></table></figure><p>여기에서 buf.get(bulk)는 get(bulk, 0, bulk.length)와 같으며 bulk를 읽어 5개를 한번에 입력한다. 앞전에 본 상대적 입력에나 출력에서 position이 움직이지 않았지만 여기에서 byte 배열을 이용해서 한꺼번에 넣는 방법은 position이 움직여 6을 가리키게 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line">public class BulkReadTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(10);</span><br><span class="line">        buf.put((byte) 0).put((byte) 1).put((byte) 2).put((byte) 3).put((byte) 4);</span><br><span class="line">        buf.mark();</span><br><span class="line">        buf.put((byte) 5).put((byte) 6).put((byte) 7).put((byte) 8).put((byte) 9);</span><br><span class="line">        buf.reset();</span><br><span class="line"></span><br><span class="line">        byte[] b = new byte[15];</span><br><span class="line"></span><br><span class="line">        // 버퍼에서 얼마나 쓸 수 있는지를 계산한다.</span><br><span class="line">        int size = buf.remaining();</span><br><span class="line">        if (b.length &lt; size) &#123;</span><br><span class="line">            size = b.length;</span><br><span class="line">        &#125;</span><br><span class="line">        // 버퍼 또는 배열에서 이용할 수 있는 만큼만 이용한다.</span><br><span class="line">        buf.get(b, 0, size);</span><br><span class="line">        System.out.println(&quot;Position : &quot; + buf.position() + &quot;, Limit : &quot; + buf.limit());</span><br><span class="line"></span><br><span class="line">        //byte[]에 담은 데이터를 처리하기 위한 메소드다.</span><br><span class="line">        doSomething(b, size);</span><br><span class="line">    &#125;</span><br><span class="line">    // byte[]와 함께 배열이 얼마나 사용되었는지 크기를 함께 넘겨줘서 사용한다.</span><br><span class="line">    public static void doSomething(byte[] b, int size) &#123;</span><br><span class="line">        for(int i = 0; i&lt; size; i++) &#123;</span><br><span class="line">            System.out.println(&quot;byte = &quot; + b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>버퍼에 쓰기도 이와 비슷하게 사용할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(10);</span><br><span class="line">Byte[] bulk = new byte[5];</span><br><span class="line">...</span><br><span class="line">byte b = buf.put(bulk);</span><br></pre></td></tr></table></figure><h3>4. 버퍼 자체를 파라미터로 받아서 쓰기</h3><p>버퍼 자체를 파라미터로 받아서 쓰기 위해 제공해주는 메소드</p><p><code>//파라미터로 주어진 버퍼의 내용을 쓰기 public ByteBuffer put(ByteBuffer src);</code></p><p>이전까지 모두 get과 put의 쌍으로 이루어져 있는데 이 방식에는 put() 메소드밖에 존재하지 않는다. 그 이유는 aBuffer.put(bBuffer)와 bBuffer.get(aBuffer)는 같은 결과를 가져오기 때문이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer aBuf = ByteBuffer.allocate(10);</span><br><span class="line">ByteBuffer bBuf = ByteBuffer.allocate(5);</span><br><span class="line">....</span><br><span class="line">aBuf.put(bBuf);</span><br></pre></td></tr></table></figure><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 13장 인용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;01. 버퍼 개요&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://cfile23.uf.tistory.com/image/270D0C4F58C92481152819&quot; alt=&quot;img&quot;&gt;&lt;br&gt;
버퍼는 운영체제의 커널이 관리하는 시스템 메모리를 직접 사용
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Buffer" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Buffer/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="Buffer" scheme="http://jungha-cho.github.io/tags/Buffer/"/>
    
  </entry>
  
  <entry>
    <title>14. 채널 04. 소켓 채널</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOSocketChannel/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOSocketChannel/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:49:05.508Z</updated>
    
    <content type="html"><![CDATA[<h1>04. 소켓 채널</h1><p>소켓 채널은 파일 채널과 구별되는 몇 가지 다른 특징이 있다. 예를 들어, 비블록킹 모드가 지원되는 점이나 SelectableChannel을 상속해서 Selector와 함께 멀티플렉스 IO가 가능하다는 점 등을 들 수 있다. 하지만 이 두 채널은 근본적으로 목적과 사용처가 다르므로 구체적인 비교는 하지 않겠다. 소켓 채널의 출발점으로 JDK 1.4 이전의 소켓을 이용한 네트워크 프로그래밍에서 어떤 점이 문제였는지 그리고 NIO에서는 이것이 어떻게 해결됐는지를 간단히 알아보고 계속 진행하겠다.</p><p>기존의 소켓이나 IO를 이용한 네트워크 프로그래밍의 최대 단점은 블록킹된다는 점이었다. 클라이언트의 커넥션 요구를 받아들이는 서버소켓의 accept() 메소드부터 시작해서 클라이언트와 연결된 소켓에서 데이터를 읽어들이는 부분까지 블록킹되는 부분이 너무 많았다. 따라서 비블록킹이 지원되지 않는 기술로 비블록킹 효과를 내기 위한 여러 가지 방법 중 많은 부분에서 가장 이점이 많은 멀티스레드 모델을 이용하게 되었다. 하지만 이 모델은 클라이언트당 스레드 한 개를 사용해야 하므로 자원을 비 효율적으로 사용하게 되고 많은 클라이언트들이 접속해서 사용해야 될 스레드의 개수가 많아지면 스레드 컨텍스트 스위칭 등의 이유로 급격한 성능 저하를 가져왔다.</p><p>하지만 이제 더 이상 이런 방식으로 대량의 클라이언트를 처리 해야하는 서버를 만들지 않아도 된다. 바로 NIO에서 비블록킹 소켓 채널이 도입되고 이 소켓채널과 함께 멀티플렉스 IO를 지원하는 Selector가 도입되었기 떄문이다. 우선 여기에서는 소켓 채널들 각각에 대해서 알아보자.</p><p>소켓 채널은 ByteChannel과 ScatteringByteChannel, GatheringByteChannel 인터페이스들을 구현하고 있다. 따라서 소켓 채널은 읽기, 쓰기가 모두 가능하며 효율적인 읽기, 쓰기를 위한 Scatter/Gather도 이용할 수 있다. 하지만 서버소켓채널은 그렇지 않다. 서버소켓채널은 그 스스로 어떤 데이터도 전달할 수 없고 기존의 서버소켓과 마찬가지로 서버에 접속하려고 시도하는 클라이언트들을 처리하는 데에만 사용된다.</p><h3>1. 비블록킹 모드</h3><p>모든 소켓채널들은 비블록킹 모드로 동작할 수 있다. 소켓채널을 비블록킹 모드로 설정하는 방법은 간단하다. 바로 모든 소켓채널의 수퍼클래스인 SelectableChannel에서 소켓채널을 비블록킹 모드로 설정하는 메소드를 이용하면 된다.</p><p>SelectableChannel API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class SelectableChannel extends AbstractChannel implements &#123;</span><br><span class="line">    public abstract void configureBlocking(boolean block) throws IOException;</span><br><span class="line">    public abstract boolean isBlocking();</span><br><span class="line">    public abstract Object blockingLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SelectableChannel은 크게 두 가지 기능이 있는데, Selector와 함께 멀티플렉스 IO 작동을 하기 위해 소켓채널을 셀렉터에 등록하는 것과 관련된 기능이다. 그리고 다른 한가지는 소켓채널의 블록킹 모드 설정에 관련된 기능이다. 셀렉터와 관련된 것은 15장 셀렉터에서 자세히 다룰 것이고 이곳에서 블록킹 모드를 설정하는 것에 관련된 부분만을 살펴볼 것이다. 위의 API는 SelectableChannel 중에서 채널의 모드를 설정하는 것에 관련된 부분만을 나타낸 것이다. 모든 소켓채널들은 기본적으로 블록킹 또는 비블록킹 모드 중 한가지 모드인 상태로 존재하는데, 기본적으로 아무런 설정을 해주지 않으면 블록킹 모드가 된다. 위의 configureBlocking() 메소드의 파라미터 값으로 True를 설정하면 블록킹 모드, False를 설정하면 비블록킹 모드로 설정된다.</p><h3>2. 서버 소켓 채널</h3><p>서버 소켓 채널의 API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ServerSocketChannel extends AbstractSelectableChannel &#123;</span><br><span class="line">    public static ServerSocketChannel open() throws IOException;</span><br><span class="line">    public abstract ServerSocket socket();</span><br><span class="line">    public abstract ServerSocket accept() throws IOException;</span><br><span class="line">    public final int validOps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>서버 소켓 채널은 기존의 서버 소켓과 기본적으로 동일한 동작을 한다. 단 서버 소켓 채널은 비블록킹 모드로 동작할 수 있다는 점이 다르다. 서버소켓채널 객체는 정적 메소드인 open() 메소드를 통해 만든다. 보통 우리가 일반적으로 사용하는 new 키워드를 이용해서 서버소켓채널을 생성할 수 없다는 점에 주으하자. 서버소켓채널을 포함한 모든 소켓채널들은 생성자를 제공하지 않는다. 따라서 앞서 언급한 정적 팩토리 메소드인 open() 메소드를 통해서만 생성할 수 있다.</p><p>로컬 호스트 IP로 서버 소켓 채널을 바인드 하는 코드 템플릿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line">ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line"></span><br><span class="line">InetAddress ia = InetAddress.getLocalHost();</span><br><span class="line">//InetAddress ia = InetAddress.getByName(&quot;192.168.0.2&quot;);</span><br><span class="line">Int Port = 8080;</span><br><span class="line">InetSocketAddress isa = new InetSocketAddress(ia, port);</span><br><span class="line">serverSocket.bind(isa);</span><br></pre></td></tr></table></figure><h3>3. 소켓 채널</h3><p>네트워크 프로그래밍에 사용될 가장 일반적인 소켓채널(SocketChannel)에 대해 살펴보자.<br>소켓 채널 API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class SocketChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel &#123;</span><br><span class="line">    //소켓채널 생성 및 소켓채널과 연관된 소켓을 구하기 위한 메소드들</span><br><span class="line">    public static SocketChannel open() throws IOException;</span><br><span class="line">    public static SocketChannel open(SocketAddress remote) throws IOException;</span><br><span class="line">    public abstract Socket socket();</span><br><span class="line"></span><br><span class="line">    //소켓채널의 연결에 관련된 메소드들</span><br><span class="line">    public abstract boolean connect(SocketAddress remote) throws IOException;</span><br><span class="line">    public abstract boolean isConnectionPending();</span><br><span class="line">    public abstract boolean finishConnect() throws IOException;</span><br><span class="line">    public final int validOps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read(), write() 메소드를 제외한 메소드들을 기재했다. 소켓 채널에서의 read(), write() 메소드를 사용하는 것은 앞서 Scatter/Gather와 파일채널에서의 사용 방법과 그 동작 방식이 동일하다.</p><p>소켓 채널은 AbstractSelectableChannel을 상속한다. 따라서 SelectableChannel이 제공해주는 비블록킹 모드의 사용이 가능하다. 또한 ByteChannel, ScatteringByteChannel, GatheringByteChannel을 구현하고 있는데, ByteChannel의 특징인 읽기, 쓰기를 모두 지원하는 양방향성과 ScatteringByteChannel, GatheringByteChannel의 특징인 운영체제의 네이티브 코드의 도움을 받는 효율적인 읽기, 쓰기가 지원된다.</p><h3>4. 데이터그램 채널</h3><p>서버 소켓과 서버 소켓 채널, 소켓과 소켓채널과의 관계처럼 데이터그램 채널도 데이터그램 소켓과 연관 관계가 있다. DatagramSocketChannel은 이름이 너무 길어 DatagramChannel로 되었다고 한다. 앞서 봤던 소켓 채널들은 TCP/IP 같은 커넥션 기반의 스트림 프로토콜 모델인데 반해, 데이터그램 채널은 UDP/IP 같은 패킷 기반의 프로토콜 모델이다. TCP/IP와 UDP/IP는 1장 등 기존의 네트워크를 다루던 앞선 장에서 충분히 논의되었기 때문에 더 이상의 자세한 설명은 생략한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class DatagramChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel &#123;</span><br><span class="line">    public static DatagramChannel open() throws IOException;</span><br><span class="line">    public abstract DatagramSocket socket();</span><br><span class="line"></span><br><span class="line">    public abstract DatagramChannel connect(SocketAddress remote) throws IOException;</span><br><span class="line">    public abstract boolean isConnected();</span><br><span class="line">    public abstract DatagramChannel disconnect() throws IOException;</span><br><span class="line"></span><br><span class="line">    public abstract SocketAddress receive(ByteBuffer dst) throws IOException;</span><br><span class="line">    public abstract int send(ByteBuffer src, SocketAddress target) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 14장 인용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;04. 소켓 채널&lt;/h1&gt;
&lt;p&gt;소켓 채널은 파일 채널과 구별되는 몇 가지 다른 특징이 있다. 예를 들어, 비블록킹 모드가 지원되는 점이나 SelectableChannel을 상속해서 Selector와 함께 멀티플렉스 IO가 가능하다는 점 등을 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Channel" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Channel/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
  </entry>
  
  <entry>
    <title>13. 버퍼 04. Buffer 클래스가 제공하는 유틸리티 메소드</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOWhatIOBufferutil/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOWhatIOBufferutil/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:50:00.331Z</updated>
    
    <content type="html"><![CDATA[<h1>04. buffer 클래스가 제공하는 유틸리티 메소드</h1><p>이번 단에서는 버퍼 계열의 부모 클래스인 Buffer 클래스에 대해 살펴보자. 버퍼 클래스는 유용한 유틸리티 메소드를 많이 가지고 있다.</p><h3>1. clear() 메소드</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(10);</span><br><span class="line">...</span><br><span class="line">buf.clear();</span><br></pre></td></tr></table></figure><p>이처럼 clear() 메소드를 호출하게 되면 position, limit, mark 값의 속성들이 버퍼가 생성될 떄 초기값으로 초기화 된다.</p><h3>2. rewind() 메소드</h3><p>ByteBuffer buf = ByteBuffer.allocate(10);<br>…<br>buf.rewind();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">rewind() 메소드를 호출하면 position 속성값만 초기화 된다. rewind()역시 clear처럼 호출전에 mark값이 설정되어 있었다면 초기값인 -1로 초기화된다.</span><br><span class="line"></span><br><span class="line">### 3. flip() 메소드</span><br></pre></td></tr></table></figure><p>ByteBuffer buf = ByteBuffer.allocate(10);<br>…<br>buf.flip();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">이 메소드는 limit를 position이 있던 위치로 설정한 후에 position을 0으로 이동시킨다. 이 메소드 역시 flip()을 호출하기 전 mark 값이 설정되어 있었다면 mark 값 역시 -1로 초기화 시킨다.</span><br><span class="line">이미 사용했던 버퍼를 재사용하기 위해 버퍼의 clear() 메소드를 호출하고 데이터를 버퍼에 쓸것이다. 그리고 flip() 메소드로 재사용할 범위를 지정한 후 버퍼에서 데이터를 읽으면 된다.</span><br><span class="line"></span><br><span class="line"># 05. Buffer 하위 클래스 유틸리티 메소드</span><br><span class="line">### 1. compact() 메소드</span><br></pre></td></tr></table></figure><p>ByteBuffer buf = ByteBuffer.allocate(10);<br>…<br>buf.compact();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">position과 limit 사이에 남아있는 데이터를 버퍼의 맨 앞에부터 순서대로 덮어 쓴다. 쓴 위치만큼 position을 이동시키고 limit는 capacity와 동일하게 만든다. 또한 compact() 메소드 호출 전에 mark가 설정되어 있었다면 mark 값 역시 -1로 초기화 한다.</span><br><span class="line"></span><br><span class="line">이처럼 compact() 메소드는 버퍼 안의 데이터를 남김없이 모두 전송하고 싶을 떄 유용하게 사용할 수 있다.</span><br><span class="line"></span><br><span class="line">in 채널에서 읽은 데이터를 out 채널로 보낼 떄 버퍼의 데이터를 모두 전송하기 위해 compact() 메소드를 사용한 템플릿 코드이다.</span><br></pre></td></tr></table></figure><p>buf.clear();<br>// 읽을 데이터가 있으면 채널에서 버퍼로 데이터를 읽어들인다.<br>while(in.read(buf) &gt; 0 &amp;&amp; buf.hasRemaining()) {<br>buf.flip();<br>// 버퍼로 읽어들인 데이터를 채널에 전송한다.<br>out.write(buf);<br>// 전송하지 못한 데이터가 있으면 버퍼의 맨 앞부분으로 모두 복사해서 다음 번에 재전송 되게 한다.<br>buf.compact();<br>}</p><pre><code>### 2. duplicate() 메소드duplicate() 메소드는 버퍼에 복사본을 생성할 떄 사용하는 메소드다. 복사본이라고 했지만 데이터와 기본 속성들을 모두 복사한 새로운 버퍼를 생성하진 않고 단지 원본 버퍼와 같은 메모리 공간을 참조하는 버퍼를 생성한다.자료형의 속성만 참조할 뿐 position, limit, capactiy는 각자 관리한다.### 3. asReadOnlyBuffer() 메소드asReadOnlyBuffer() 메소드로 생성된 읽기전용 버퍼는 앞서 살펴본 duplicate() 메소드로 생성된 버퍼와 한가지를 제외하곤 동일하다.duplicate() 메소드로 생성된 버퍼는 put() 메소드의 호출로 데이터를 수정할 수 있다. 하지만 ReadOnly라는 이름처럼 오직 읽기만 가능하다.### 4. slice() 메소드duplicate(), asReadOnlyBuffer() 메소드로 생성된 버퍼들이 원본과 동일한 크기를 갖는 복사본을 생성하는 것이다. 반면 slice()는 버퍼의 일부분만을 복사하는 메소드다. slice()를 호출하면 원본 버퍼의 position 에서 limit까지만을 떼어내서 생성한다. 이렇게 생성된 버퍼 역시 자신만의 네가지 기본 속성을 갖고 원본 버퍼와 동일한 메모리 주소를 참조한다. 하지만 앞의 duplicate(), asReadOnlyBuffer와 달리 slice로 생성된 buffer는 각각의 기본 속성이 초기화 된다.출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 13장 인용</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;04. buffer 클래스가 제공하는 유틸리티 메소드&lt;/h1&gt;
&lt;p&gt;이번 단에서는 버퍼 계열의 부모 클래스인 Buffer 클래스에 대해 살펴보자. 버퍼 클래스는 유용한 유틸리티 메소드를 많이 가지고 있다.&lt;/p&gt;
&lt;h3&gt;1. clear() 메소
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Buffer" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Buffer/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="Buffer" scheme="http://jungha-cho.github.io/tags/Buffer/"/>
    
  </entry>
  
  <entry>
    <title>13. 버퍼 06. 버퍼 만들기</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOWhatIOBufferMake/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOWhatIOBufferMake/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:57:02.751Z</updated>
    
    <content type="html"><![CDATA[<h3>06. 버퍼 만들기</h3><p>버퍼는 new 생성자를 이용하지 않고 allocate() 팩토리 메소드를 사용했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ByteBuffer extends Buffer implements Comparable &#123;</span><br><span class="line">    // 팩토리 메소드를 사용해서 만드는 방법</span><br><span class="line">    public ByteBuffer allocate(int capacity);</span><br><span class="line"></span><br><span class="line">    // 이미 존재하는 배열을 이용해서 만드는 방법</span><br><span class="line">    public static ByteBuffer wrap(byte[] array);</span><br><span class="line">    public static ByteBuffer wrap(byte[] array, int offset, int length);</span><br><span class="line"></span><br><span class="line">    // 유틸리티 메소드들</span><br><span class="line">    public final boolean hasArray();</span><br><span class="line">    public final byte[] array();</span><br><span class="line">    public final int arrayOffset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>버퍼의 생성과 관련된 API.</p><p>여기에서 보이는 것들은 ByteBuffer에서 제공되는 메소드들이지만 다른 버퍼들도 파라미터와 리턴 값만 다르고 사용법은 동일하다.<br>우선 ByteBuffer 클래스가 추상 클래스이다. 부모 클래스인 Buffer와 일곱가지 각각의 Buffer 클래스의 하위 클래스들은 모두 추상클래스다. 따라서 생성자를 통해 직접적으로 객체를 만들 수 없고 대신 API에서 볼 수 있듯이 팩토리 메소드를 이용해서 만드는 방법과 존재하는 배열을 이용해서 만드는 방법을 제공한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(1000);</span><br></pre></td></tr></table></figure><p>이렇게 생성된 buf는 각 기본 속성 값들이 다음과 같이 초기화 된다.<br>mark = -1;    position = 0;    limit = 1000;    capacity = 1000;</p><p>TIP. 팩토리 메소드를 사용하는 이유는 생성자의 한계를 극복하기 위해서이다. 자바의 생성자를 통해 어떤 객체를 생성하면 항상 해당 형식의 인스턴스만을 생성해서 리턴할 뿐, 그 객체의 하위 클래스 형식을 리턴하지 못한다. 이것은 우리가 생성자 안에서 ㅇㅓ떤 구현을 통해 객체를 리턴할 기회조차도 갖지 못한 상태로 언어적 차원에서 자동적으로 이루어진다. 따라서 어떤 객체의 하위 형식을 리턴하려면 생성자와 같은 동작을 하는 정적 메소드, 즉 팩토리 메소드를 사용해야 한다.</p><p>NIO에서 ByteBuffer의 allocate() 메소드 호출로 생성되는 실제 형식은 ByteBufferㅏ 아닌 이것의 하위 형식인 HeapByteBuffer다. 다음은 allocate() 메소드의 실제 구현부분인데, HeapByteBuffer가 리턴되는 것을 확인할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ByteBuffer allocate(int capacity) &#123;</span><br><span class="line">    if (capacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    return new HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 팩토리 메소드를 사용함으로써 프로그래머는 인터페이스에 해당하는 ByteBuffer만을 바라보며 사용할 수 있고 API 개발자는 실제 구현에 해당하는 부분을 HeapByteBuffer에서 캡슐화할 수 있게 된다.</p><p>Wrap() 메소드</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] myArray = new byte[1024];</span><br><span class="line">ByteBuffer buf = ByteBuffer.wrap(myArray);</span><br></pre></td></tr></table></figure><p>이 코드로 버퍼를 생성하면 1024의 크기를 갖는 버퍼가 생성된다. 이때는 buf는 myArray를 참조하기 떄문에 myArray나 buf 중 하나를 변경하면 양쪽 모두에게 반영된다.</p><p>Wrap() 메소드는 배열의 특정 범위 만큼만 사용하도록 버퍼를 생성하는 방법도 제공한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] myArray = new byte[1024];</span><br><span class="line">ByteBuffer buf = ByteBuffer.wrap(myArray, 10, 100);</span><br></pre></td></tr></table></figure><p>이 코드로 생성된 버퍼는 position이 10, limit가 100으로 설정되어 생성된다. 하지만 slice()로 생성되는 버퍼처럼 일부분을 잘라내서 새로 생성하는 것이 아닌, myArray 전체를 그대로 생성하되 파라미터로 설정된 부분만을 이용할 수 있도록 초기화되어 생성된다. 따라서 clear() 메소드를 호출하면 myArray의 0부터 1024까지 접근해서 읽거나 쓸 수 있게 된다.</p><p>이 메소드는 주로 배열에 저장된 데이터를 채널로 보내거나 채널의 데이터를 배열로 읽어들이고 싶을떄 유용하게 사용된다.</p><p>allocate(), wrap() 메소드를 이용해서 생성된 버퍼는 모두 시스템 메모리가 아닌 JVM의 힙 영역에 저장되는 Non-direct 버퍼다. 넌다이렉트 버퍼에는 모두 내부적으로 해당 버퍼 형식의 보조 배열이 있다. allocate() 메소드로 생성한 버퍼도 앞서 wrap() 메소드로 생성한 버퍼도 앞서 wrap() 메소드로 생성한 버퍼가 파라미터로 넘겨준 배열을 실제 저장소로 사용하듯이 내부적으로 그렇게 보조 배열을 만들어서 저장소로 사용하는 것이다.</p><p>이것은 hasArray() 메소드 호출로 알 수 있다. allocate(), wrap() 메소드로 생성한 버퍼에 hasArray() 메소드를 호출하면 true가 리턴되는 것을 확인할 수 있다.<br>또한 array() 메소드ㄹㅗ 실제 저장소에 해당하는 보조 배열을 넘겨받을 수도 있고 arrayOffset() 메소드로 보조 배열 내에 있는 이 버퍼의 최초 요소의 오프셋을 확인할 수도 있다.</p><p>반면 시스템 메모리를 사용하는 다이렉트 버퍼의 경우 hasArray() 메소드를 호출하면 UnsupportedOperationException이 발생한다. 따라서 array(), arrayOffset() 메소드도 사용할 수 없고 이들은 호출하면 역시 UnsupportedOperationException이 발생한다.</p><p>버퍼 클래스들은 필요에 따라 프로세스 메모리를 사용할지, 시스템 메모리를 사용할지를 결정할 수 있도록 디자인되어 잇다. 하지만 시스템 메모리를 사용할 수 있는 다이렉트 버퍼는 ByteBuffer만 생성할 수 있다.</p><p>그 이유로 버퍼에는 메모리 맵 파일에 사용하는 ByteBuffer의 하위 클래스인 MappedByteBuffer가 있다. 이버퍼는 파일채녈(FileChannel)과 함께 메모리 맵 파일을 구현하는 데 사용되는 다이렉트 버퍼인데 파일 채널을 통해 생성해야 한다.</p><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 13장 인용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;06. 버퍼 만들기&lt;/h3&gt;
&lt;p&gt;버퍼는 new 생성자를 이용하지 않고 allocate() 팩토리 메소드를 사용했다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Buffer" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Buffer/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="Buffer" scheme="http://jungha-cho.github.io/tags/Buffer/"/>
    
  </entry>
  
  <entry>
    <title>Joel On Software, 기본으로 돌아가기</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JoelOnSoftwareBacktothebasic/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JoelOnSoftwareBacktothebasic/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:50:47.931Z</updated>
    
    <content type="html"><![CDATA[<h1>Java Concurrency in Practice, 기본으로 돌아가기</h1><p>소프트웨어 개발의 큰 그림은 층층이 쌓인 케이크 같다. 가장 높은 층에 소프트웨어 전략이 있고 아래에 .NET과 같은 아키텍처, 그아래 자바와 같은 소프트웨어 개발 제품이나 윈도우 같은 플랫폼을 생각할 수 있다.<br>좀더 아래 부분은? DLL? 객체? 함수? 바로 CPU다. 소프트웨어 개발에 있어 최저층에서 벌어지는 몇 가지 단순한 동작원리를 자세히 알지 못하거나 아예 잘못 알고 있기 때문에 문제가 생긴다.</p><p>궁전은 멋지게 지었지만, 기초 공사가 형편없다. 아래에 튼튼한 시멘트 판을 대신해 잡석을 깔았다고 가정하자.<br>겉보기에는 멋진 궁전인데 평평한 바닥에 놓은 욕조가 가끔가다 왜 삐걱대는지 도대체 알 수가 없다.</p><p>이처럼 기초 동작에 대한 이해가 필요하다는 것을 역설하고 있다.</p><p>예제로 C언어로 된 간단한 연습문제가 있다. C에서 문자열은 값이 0인 널 null 문자로 끝나는 몇바이트를 포함한다.<br>C언어에서 문자열은 아래의 두가지 문제점이 있다.</p><h3>1. 널 문자를 찾아서 문자열 끝까지 가보기 전에는 끝을 알아내는 방법이 없다.</h3><h3>2. 문자열 내부에는 어떤 0값도 포함할 수 없으므로, JPEG 그림과 같은 비정형 이진 자료 Binary Large OBject(BLOB)를 C 문자열 내부에 저장할 수 없다.</h3><p>문자열 하나를 다른 문자열에 덧붙이는 함수인 strcat을 살펴보자</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void strcat( char* dest, char* src )</span><br><span class="line">&#123;</span><br><span class="line">while ( *dest ) dest++;</span><br><span class="line">while ( *dest++ = *src++ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 함수는 널 문자를 찾은 뒤에서 부터 한 문자씩 짤라서 덧붙이고 있다.</p><p>이 함수는 커닝헌과 리치 시절에는 충분했을지 모르지만 한가지 문제점을 안고 있따.<br>러시아 페인트공 알고리즘을 사용하는 함수이기 때문에 성능 측면에서 최악의 성능을 보여 줄 수도 있다.</p><p>러시아 페인트공 알고리즘</p><ul><li>첫날 150M를 칠한 페인트공이 날짜가 지날수록 100M, 50M, 30M를 칠하게 됐따.</li><li>문제는 길이가 늘어날수록 페인트통의 위치가 멀어지기 때문이다.</li><li>페인트통을 시작점에 놓고 페인트칠을 한다고 가정했을때</li></ul><p>strcat을 사용할 떄 첫 부분은 매번 빌어먹을 널 문자를 찾아 목적지 문자열을 헤매다녀야 하므로 strcat 함수는 필요이상으로 느리며 작업규모가 커지면 성능이 현저히 떨어진다.</p><p>몇몇 똑똑한 프로그래머는 이렇게 고친다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char* mystrcat ( char* dest, char* src )</span><br><span class="line">&#123;</span><br><span class="line">while ( *dest ) dest++;</span><br><span class="line">while ( *dest++ = *src++ );</span><br><span class="line">return --dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막 문자열의 index를 반환하는 것이다.</p><p>파스칼 설계자들은 이런 문제점을 미리 알고 있었으며 문자열의 첫 바이트에 개수를 저장하는 방법으로 이를 해결했다.<br>바로 이런 문자열을 파스칼 문자열이라고 한다.</p><p>또 왜 기억공간을 정확하게 계산해야 할까?<br><code>char bigString[1000];</code>   /* 얼마나 할당해야 할지 알 수 없음 * /</p><p>해커가 이러한 코딩을 본다면 손쉽게 오버플로우 해킹과 웜 바이러스 제작에 쓰이는 기본 기술을 활용할 수 있다.</p><p>출처 : 조엘 스풀스키, 『 조엘 온 소프트웨어』, 박재호 이해영 옮김, 에이콘(2005.4), 2장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Java Concurrency in Practice, 기본으로 돌아가기&lt;/h1&gt;
&lt;p&gt;소프트웨어 개발의 큰 그림은 층층이 쌓인 케이크 같다. 가장 높은 층에 소프트웨어 전략이 있고 아래에 .NET과 같은 아키텍처, 그아래 자바와 같은 소프트웨어
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="기본으로 돌아가기" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/%EA%B8%B0%EB%B3%B8%EC%9C%BC%EB%A1%9C-%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0/"/>
    
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/tags/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
  </entry>
  
  <entry>
    <title>12. NIO 개요 04. 자바의 새로운 변화</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOWhatIONIO/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOWhatIONIO/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:50:23.587Z</updated>
    
    <content type="html"><![CDATA[<h1>04. 자바의 새로운 변화</h1><p>기존 IO와 NIO는 어떠한 변화가 있는가?</p><h3>1. 자바의 포인터 버퍼 도입</h3><p>가장 핵심적이면서 중요한 변화가 바로 NIO에서 Buffer 클래스를 도입했다는 점이다. 앞서 우리는 C/C++와 달리 자바의 IO가 비효율적인 원인을 살펴봤다.<br>물리적 메모리(버퍼)를 커널이 제어하느냐 프로세스가 제어하느냐에 따라, 그리고 DMA, 캐시, 가상 메모리 같은 운영체제가 제공해주는 효율적인 IO 기술을 사용하느냐 못하느냐, 쓸데없이 커널 영역에서 프로세스 영역으로의 데이터 복사 과정을 거치지않느냐에 따라서 효율과 비효율이 결정되었다.</p><p>JVM은 하나의 프로세스고 JDK 1.4 이전에 사용되는 모든 메모리는 JVM의 힙 영역에서 관리했다. 결국 IO 과정에서 항상 비효율적인 복사 과정을 거치고 블록킹되며 운영체제가 제공해주는 효율적인 기능도 전혀 사용하지 못했다. 하지만 1.4부터 새롭게 도입된 NIO에서는 커널에 의해 관리되는 시스템 메모리를 직접 사용할 수 있는 Buffer 클래스가 도입되었다. (DirectByteBuffer 한정) 이 클래스의 하부 구현은 C로 만들어져 있고 우리는 추상화되어 제공되는 자바 클래스인 Buffer만을 사용하면 된다. 결론적으로 Buffer에서 제공하는 많은 메소드를 이용함으로써 C/C++의 포인터가 자바에서도 생겼다고 볼 수도 있는 것이다.</p><h3>2. 네이티브 IO 서비스를 제공해주는 채널 도입</h3><p>기존의 스트림은 단방향이었다. 읽거나 쓰는 한가지만 가능했다. NIO에서는 이 스트림의 향상된 버전이라고 생각할 수 있는 Channel을 도입했다. 채널은 스트림처럼 읽거나 쓰는 단방향에서부터, 읽고 쓰는 양방향 통신이 가능한 세가지 형식이 존재한다. 또한 운영체제에서 제공해주는 다양한 네이티브 IO 서비스들을 이용할수 있게 해준다.</p><p>채널은 Buffer 클래스와 함께 작업하도록 만들어져 있다. 채널을 이용해서 시스템 메모리인 버퍼에 직접적으로 데이터를 읽거나 쓸 수 있게 되었다는 것이다. 또한 채널은 앞서 알아봤던 Scatter/Gather를 구현해서 효율적으로 IO를 처리할 수 있게 되었다.</p><p>버퍼 클래스와 채널은 실과 바늘로 비요할 수 있다. 버퍼가 시스템 메모리에 로드되면 앞서 배운 운영체제에서 지원하는 다양한 기능들을 채널을 통해 사용하는 것이다. 결국 네이티브 IO 서비스를 이용할 수 있게 해주는 채널이 도입되었다는 것과 이로인해 버퍼 클래스와 함께 작업하는 양방향 통신이 가능해 졌다는 것이 핵심이다.</p><h3>3. 셀렉터 도입</h3><p>셀렉터는 네트워크 프로그래밍의 효율을 높이기 위한 것인데 POSA2(Pattern-Oriented Software Architecture, volume 2)에서 소개된 Reactor 패턴의 구현체다. 기존의 자바 네트워크 프로그래밍에서는 한계가 있었다. 클라이언트 하나당 스레드 하나를 생성해서 처리해야 했는데 사용자가 늘어나면 스레드가 많이 생성됨으로 인해 급격한 성능 저하를 가져왔으며 또한 구조적으로 많은 스레드를 생성해야 했기 때문에 메모리 또한 비효율적으로 사용했다.</p><p>NIO에서는 네트워크 프로그래밍의 확장성과 유연성, 효율성을 높이기 위해서 버퍼, 채널과 함꼐 사용되는 셀렉터를 이용함으로써 단 한개의 스레드만으로 수천에서 수만명의 동시 사용자를 처리할 수 있는 서버를 만들 수 있게 되었다.</p><p>Q. 이제까지 본 것들이 NIO를 공부하기위해 필요한 제반 지식이라 할 수 있는 것들이다.IO의 흐름을 살펴보면서 자바 IO가 왜 느렸는지, 운영체제에서 IO 성능 향상을 위해 사용하는 버퍼, Scatter/Gather, 가상 메모리, 메모리 맵 파일, 파일 락킹에 대해서 공부했다. 이 책은 해당 기술의 배경이 되는 지식과 그 기술의 전반적인 부분을 살펴보고 앞으로 공부할 기술들에 대해 훨씬 더 쉽고 재미있게 접근할 수 있을 것이다.</p><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 12장 인용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;04. 자바의 새로운 변화&lt;/h1&gt;
&lt;p&gt;기존 IO와 NIO는 어떠한 변화가 있는가?&lt;/p&gt;
&lt;h3&gt;1. 자바의 포인터 버퍼 도입&lt;/h3&gt;
&lt;p&gt;가장 핵심적이면서 중요한 변화가 바로 NIO에서 Buffer 클래스를 도입했다는 점이다. 앞서 우리
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
  </entry>
  
  <entry>
    <title>13. 버퍼 07. ByteBuffer</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOWhatIOByteBuffer/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOWhatIOByteBuffer/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:57:03.897Z</updated>
    
    <content type="html"><![CDATA[<h1>07. ByteBuffer</h1><p>7가지 버퍼 중 ByteBuffer와 CharBuffer는 다른 버퍼와 차별화되는 몇몇 특징이 있다. 그 중에서도 ByteBuffer는 시스템 메모리를 직접 사용하는 다이렉트 버퍼를 만들 수 있는 유일한 버퍼 클래스기 때문에 가장 중요하다.</p><h3>1. 다이렉트 버퍼</h3><p>NIO의 많은 버퍼 중 왜 ByteBuffer만 다이렉트 버퍼로 만들 수 있게 했을까?<br>운영체제가 이용하는 가장 기본적인 데이터 단위가 바이트이고 시스템 메모리 또한 순차적인 바이트들의 집합이기 때문이다.</p><p>Int, Long, Float, Double, Char, Object 등 자바 프로그램에서 많은 데이터 형식들을 사용하지만 JVM은 운영체제와 IO 수행을 위해 통신할 때 데이터 모두를 운영체제가 인식할 수 있는 순차적인 바이트 형태로 바꿔서 전달한다. 또한 시스템 메모리의 구성 형태와 달리 자바에서 사용하는 바이트 배열은 시스템 메모리에서 사용하는 순차적인 바이트들의 집합이 아닌 객체 내에 바이트들을 저장하고 있는 형태기 때문에 커널이 관리하는 시스템 메모리에 직접 저장할 수 있는 형태가 아니다.</p><p>이러한 한계점을 극복하기 위해 NIO에서 다이렉트 버퍼가 도입되었고 ByteBuffer만이 시스템 메모리를 사용할 수 있는 다이렉트 버퍼로 생성할 수 있는 것이다</p><p>API 코드</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ByteBuffer extends Buffer implements Comparable &#123;</span><br><span class="line">    public static ByteBuffer allocateDirect(int capacity);</span><br><span class="line">    public abstract boolean isDirect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>템플릿 코드</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);</span><br><span class="line">boolean isDirect = directBuffer.isDirect();</span><br></pre></td></tr></table></figure><p>allocate() 메소들 이용한 것과 메소드 이름만 다를 뿐, 사용법은 같다는 것을 쉽게 알 수 있다.<br>allocateDirect() 메소드를 호출하면 다이렉트 버퍼가 생성된다. 넌다이렉트 버퍼와 달리 다이렉트 버퍼를 생성하기 위한 메소드는 allocateDirect() 메소드 하나뿐이다.<br>또한 해당 버퍼가 다이렉트 버퍼인지 아닌지를 확인하기 위해서 isDirect() 메소드를 제공한다. 리턴 값이 true면 다이렉트 버퍼이고, false이면 넌다이렉트 버퍼이다.</p><p>이렇게 생성된 다이렉트 버퍼는 채널과 네이티브 IO 루틴들이 이용하게 된다. 메모리 영역 안에서 채널을 이용하여 바이트들을 직접적으로 다이렉트 버퍼에 저장할 수 있고 또한 네이티브 코드를 통해 운영체제가 직접적으로 메모리 영역에서 다이렉트 버퍼에 데이터를 읽고 쓸 수 있게 된다. 따라서 효율적인 IO 작업이 가능하다.</p><p>자바는 C/C++와 같은 저수준 언어가 아닌데 어떻게 시스템 메모리인 다이렉트 버퍼를 생성하고, 조작하고, 가비지 컬렉트까지 할 수 있을까? 답은 JNI이다.</p><p>다시 본론으로 와서 ByteBuffer.allocateDirect() 메소드를 이용해서 다이렉트 버퍼를 생성하면 내부적으로 다음과 같은 일들이 벌어진다.</p><ul><li>메소드 파라미터로 주어진 크기만큼의 시스템 메모리를 JNI를 이용해 할당한다.</li><li>이 시스템 메모리를 래핑하는 자바 객체를 만들어 리턴한다.</li></ul><p>우리가 생성해서 리턴 받은 객체는 시스템 메모리를 래핑하고 있는 자바 객체이므로 우리는 이 객체를 사용해서 직접적인 시스템 메모리를 제어할 수 있고 곧바로 시스템 메모리에 반영될 것이다. 이 객체는 가비지 컬랙트 되면 이 버퍼가 래핑하고 있는 주소의 시스템 메모리도 동시에 안전하고 확실하게 해제(deallocate 또는 release) 된다.</p><p>채널의 타겟이 되는 것은 다이렉트 버퍼 뿐이다. 넌다이렉트 버퍼를 채널의 탁[ㅅ으로 설정하면 다음과 같은 과정을 거치기 때문에 성능이 저하된다.</p><ol><li>넌다이렉트 버퍼를 채널에 전달한다.</li><li>임시로 사용할 다이렉트 버퍼를 생성한다.</li><li>넌다이렉트 버퍼에서 임시로 만든 다이렉트 버퍼로 데이터를 복사한다.</li><li>임시 버퍼를 사용해서 채널이 저수준 IO를 수행한다.</li><li>임시 버퍼가 다 사용되면 마지막으로 임시 버퍼를 가비지 컬렉트한다.</li></ol><p>다이렉트 버퍼를 메모리에 로드하거나 릴ㄹ리즈 하는것은 넌다이렉트 버퍼를 생성, 제거하는 것에 비해 상당히 부하가 크므로 다이렉트 버퍼 풀을 만들어서 사용하는 것이 좋은 선택이 될 수 있다.</p><h3>2. 뷰 버퍼</h3><p>ByteBuffer에서는 특별한 형태의 뷰 버퍼를 만들 수 있다. 이와 비슷한 형태인 duplicate()와 slice() 메소드로 생성되는 버퍼가 있다. ByteBuffer에서도 position, mark, limit, capacity를 갖고 원본 버퍼와 데이터를 공유하는, 자신을 제외한 다른 여섯 가지 기본 형식의 뷰 버퍼를 생성할수 있는 팩토리 메소드를 제공한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ByteBuffer extends Buffer implements Comparable &#123;</span><br><span class="line">    public abstract CharBuffer asCharBuffer();</span><br><span class="line">    public abstract ShortBuffer asShortBuffer();</span><br><span class="line">    public abstract asIntBuffer();</span><br><span class="line">    public abstract asLongBuffer();</span><br><span class="line">    public abstract asFloatBuffer();</span><br><span class="line">    public abstract asDoubleBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 API에서 볼 수 있듯 다른 기본 형식 버퍼들의 뷰 버퍼를 리턴하는 메소드 여섯개가 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.IntBuffer;</span><br><span class="line"></span><br><span class="line">public class ViewBufferTest &#123;</span><br><span class="line">    public static void main(String[[] args) &#123;</span><br><span class="line">        //크기가 10인 ByteBuffer를 생성한다.</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(10);</span><br><span class="line"></span><br><span class="line">        //뷰 버퍼인 IntBuffer를 생성한다.</span><br><span class="line">        IntBuffer ib = buf.asIntBuffer();</span><br><span class="line">        //뷰 버퍼의 초기 값을 출력한다.</span><br><span class="line">        System.out.println(&quot;position = &quot; + ib.position() + &quot;, limit = &quot; + ib.limit() + &quot;, capacity = &quot; + ib.capacity());</span><br><span class="line">        //뷰 버퍼에 데이터를 쓴다.</span><br><span class="line">        ib.put(1024).put(2048);</span><br><span class="line">        //뷰 버퍼의 데이터를 출력한다.</span><br><span class="line">        System.out.println(&quot;index_0 = &quot; + ib.get(0) + &quot;, index_1 = &quot; + ib.get(1));</span><br><span class="line"></span><br><span class="line">        //원본 버퍼도 변경되었는지 확인하기 위해 출력한다.</span><br><span class="line">        while(buf.hasRemaining()) &#123;</span><br><span class="line">            System.out.print(buf.get() + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>3. 다른 데이터 형식으로 읽고 쓰기</h3><h3>4. 바이트 순서</h3><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 13장 인용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;07. ByteBuffer&lt;/h1&gt;
&lt;p&gt;7가지 버퍼 중 ByteBuffer와 CharBuffer는 다른 버퍼와 차별화되는 몇몇 특징이 있다. 그 중에서도 ByteBuffer는 시스템 메모리를 직접 사용하는 다이렉트 버퍼를 만들 수 있는 유일한
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="ByteBuffer" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/ByteBuffer/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="ByteBuffer" scheme="http://jungha-cho.github.io/tags/ByteBuffer/"/>
    
  </entry>
  
  <entry>
    <title>Joel On Software, 조엘 테스트 : 더 나은 코드를 위한 12단계</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JoelOnSoftwareCheckList/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JoelOnSoftwareCheckList/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:51:01.538Z</updated>
    
    <content type="html"><![CDATA[<p>조엘 테스트 체크 리스트</p><ol><li>소스코드 관리 시스템을 사용하고 있습니까?</li><li>한방에 빌드를 만들어낼 수 있습니까?</li><li>일일 빌드를 하고 있습니까?</li><li>버그 추적 시스템을 운영하고 있습니까?</li><li>코드를 새로 작성하기 전에 버그를 수정합니까?</li><li>일정을 업데이트하고 있습니까?</li><li>명세서를 작성하고 있습니까?</li><li>조용한 작업 환경에서 일하고 있습니까?</li><li>경제적인 범위 내에서 최고의 성능 도구를 사용하고 있습니까?</li><li>테스터를 별도로 두고 있습니까?</li><li>프로그래머 채용 인터뷰 때 코딩 테스트를 합니까?</li><li>무작위 사용 편의성 테스트를 수행하고 있습니까?</li></ol><p>5분 내로 간단하게 소프트웨어 회사의 현 주소를 진단할 수 있는 체크리스트이다.<br>무조건적으로 모든 상황에서 적용할 수 있는 것은 아니지만 일반적으로 12점 만점에 가까울때 일관성 있게 제품을 출시할 수 있는 잘 훈련된 팀이라고 볼 수 있다.</p><ol><li><p>소스 코드 관리 시스템을 사용하고 있습니까?<br>소스 코드 관리 시스템은 빌드용 소스 코드와 작업용 소스 코드를 분리 시킬수 있다는 장점만 있는 것이 아닌 듯 하다. 아직 모든 버전 관리 시스템을 사용해 보진 않았지만, 일반적으로 git과 svn을 사용하고 있다. git은 개인 코드를 관리하고 저장하는 용도로 svn은 업무용으로 사용하고 있다.</p></li><li><p>한방에 빌드를 만들어낼 수 있습니까?<br>잘 이해할 수 없는 부분인것 같다. 아직 대형 조직에서 대형 프로젝트를 진행해본 경험은 없지만, 일반적으로 체크아웃 후 코딩을 수행하고 모든 팀원의 소스를 커밋 후 합쳐진 코드를 빌드하고 컴파일하고 최종 패키징을 생성하고 해당 파일을 배포 방법에 따라 마무리를 할것이다. 예시로 이러한 길고 긴 패키징 과정이 한방에 진행되지 않는다면 실수하기가 쉬워진다는 것을 지적하고 있다. 또한 아무도 소스코드를 건드리지 않는 밤에 스크립트로 패키징 과정까지 한방에 진행할 수 있는 도구를 추천한다.</p></li><li><p>일일 빌드를 하고 있습니까?<br>소스코드 관리 시스템을 사용하다 보면, 빌드가 깨진 문제성 코드를 우연히 체크인하는 경우가 생긴다. 개발자가 새로 만든 소스파일을 자신의 컴퓨터에서 컴파일하는 데 성공하고 퇴근했다. 이때 소스 파일을 코드 저장소에 커밋하는 작업은 잊어먹었다. 이렇게 되면 후에 직원들은 일을 진행할 수 없게 된다.<br>아직까지 빌드가 깨진다는 경험은 하지 못했다. 하지만 조엘 온 소프트웨어에서는 일일 빌드를 체크함으로써 어떤 종류의 빌드 깨짐 현상도 은근 슬쩍 넘어가지 못하게 확인하는 작업의 필요성을 강조하고 있다. 대규모 팀을 운영할 경우에는 빌드 깨짐 현상을 확인하고 곧바로 수정하기 위해 점심시간에 일일 빌드를 수행하는 방법을 추천한다. 또 누가 됐든 빌드를 깨버린 개발자는 다른 사람이 빌드를 깨는 일이 생길 때까지 빌드를 도와주는 벌칙을 추천한다. 이러한 벌칙은 빌드를 깨지않게 추천하는 당근과 채찍이다. 또 모든 사람들이 번갈아가며 빌드 절차를 익힐 수 있는 좋은 제도라고 소개한다.</p></li><li><p>버그 추적 시스템을 운영하고 있습니까?<br>팀원이 단 한명일지라도 모든 버그를 체계적으로 분류한 버그 관리 시스템을 사용하지 않고 코드를 개발하면 품질 나쁜 코드를 양산한다. 어느정도 동감하는 말이다. 많은 개발자들이 관리체계 문서 작성에 인색하고 나 또한 그렇다. 나 조차도 버그는 내가 기억하기 때문에 나중에 수정하면 된다는 생각으로 넘어가는 일이 많기 때문에 버그 관리 체계는 꼭 필요하다고 생각한다.</p></li></ol><p>책에서 추천하는 버그 관리 시스템의 항목은 다음과 같다.</p><ul><li>버그를 재현하기 위한 완벽한 단계</li><li>예상 수행 결과</li><li>관찰한 (버그로 간주되는) 실제 수행 결과</li><li>수정을 맡을 개발 책임자</li><li>수정했는지 여부</li></ul><p>버그 추적 소프트웨어가 너무 복잡해서 오히려 업무에 방해가 된다면 위에서 소개하는 항목만 뽑아서 문서를 작성하기를 추천한다.</p><ol start="5"><li>코드를 새로 작성하기 전에 버그를 수정합니까?<br>조엘 온 소프트웨어 책을 읽으며 1~4장 통틀어 가장 재밌게 읽었던 부분이다. 마이크로소프트 윈도우용 워드 첫 버전은 대표적인 살인 행군이라고 알려져있다고 한다. 이 프로젝트는 영원히 끝나지 않을 듯이 보였으며, 일정이 계속 늦춰졌다. 전체 프로젝트 팀은 아까운 시간을 허비했고, 프로젝트 기간은 계속, 계속, 계속해서 연장됐으며, 스트레스는 말도 못할 지경이었다고 한다. 최종적으로 이 워드는 4년 정도가 지나서야 가까스로 출시됐고, 마이크로소프트는 팀 전체를 멕시코 휴양지로 보낸다음 심각하게 자기 반성을 했다고 한다.</li></ol><p>MS는 PM이 일정을 재촉한 나머지 개발자가 형편없는 코드라도 구현해서 서둘러 끝내려고 했다는 사실을 알았다. 정식 일정에 버그 수정 단계를 넣지 않았기 때문에 발생한 문제였다. 버그 개수를 낮게 유지하려는 어떤 시도도 없었으며, 오히려 상황을 나쁘게 만드는 시도만 판을 쳤기 떄문이다. 예를 들어 텍스트 행 높이를 계산하는 코드를 작성했던 개발자는 일부러 return 12;로 만들어놓고 자신이 만든 함수가 잘못됐다는 버그 보고서가 오기를 기다렸지만, 기도 안차게 관련 내용을 받지도 못했다고 한다. 일정은 기껏 기능이 버그로 바뀌기를 기다리는 점검항목에 불과했고 프로젝트가 끝난 다음에 이런 관례를 무제한 결함 양산 방법론이라 부르게 됐다고 한다. 이러한 문제를 해결하기 위해 MS는 전사적으로 무결점 방법론이라는 기법을 도입했고 개발자는 콧방귀를 꼇다. 관리자 명령만으로 버그 수를 줄일 수 있다고 생각하는 관리 기법처럼 보였기 떄문이다.</p><ol start="6"><li><p>일정을 업데이트하고 있습니까?</p></li><li><p>명세서를 작성하고 있습니까?<br>모든 사람이 명세서 작업에 동감은 하지만 솔선수범 하는 사람은 없다. 대다수의 개발자는 문서 작성을 싫어하기 때문이다. 하지만 설계단계에서 문제를 발견하면 텍스트 몇 줄만 수정하는 방법으로도 쉽게 해결할 수 있다. 하지만 코딩 완료 후에 문제를 수정하면 서로의 감정도 상허고 시간낭비는 물론이거니와 비용도 급격히 상승하게 되어 실제로 문제를 수정하는 작업 자체에 저항이 생긴다.</p></li><li><p>조용한 작업 환경에서 일하고 있습니까?<br>지식 노동자에게 조용한 작업공간을 주고 사생활을 보장함으로써 얻는 생산성 향상은 많은 문헌에 나와있다고 한다…이상!</p></li><li><p>경제적인 범위 내에서 최고 성능의 도구를 사용하고 있습니까?</p></li><li><p>테스터를 별도로 두고 있습니까?</p></li><li><p>프로그래머 채용 인터뷰 떄 코딩 테스트를 합니까?</p></li><li><p>무작위 사용 편의성 테스트를 수행하고 있습니까?</p></li></ol><p>출처 : 조엘 스폴스키 지음, 박재호 이해영 옮김, 『 조엘 온 소프트웨어, 유쾌한 오프라인 블로그 』, 에이콘(2005.5), 3장 인용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;조엘 테스트 체크 리스트&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;소스코드 관리 시스템을 사용하고 있습니까?&lt;/li&gt;
&lt;li&gt;한방에 빌드를 만들어낼 수 있습니까?&lt;/li&gt;
&lt;li&gt;일일 빌드를 하고 있습니까?&lt;/li&gt;
&lt;li&gt;버그 추적 시스템을 운영하고 있습니까?&lt;
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="조엘 테스트" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/%EC%A1%B0%EC%97%98-%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/tags/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="조엘 테스트" scheme="http://jungha-cho.github.io/tags/%EC%A1%B0%EC%97%98-%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>Joel On Software, Select Language</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JoelOnSoftwareSelectLanguage/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JoelOnSoftwareSelectLanguage/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:51:12.862Z</updated>
    
    <content type="html"><![CDATA[<p>1장에서 물어보는 것은 개발자가 업무를 수행할 때 특정 프로그래밍 언어를 선택하는 이유?인것 같다.<br>번개같은 속도는 C, 배포판을 윈도우로 한정 짓자면 MFC, C++ 또 맥, 윈도우, 리눅스 처럼 여러 플랫폼에서 구동시킬 경우 Java</p><p>작업시간이 촉박하지만 멋진 GUI는 비주얼 베이직 하지만 VB는 배포본의 크기가 커진다.<br>속력에 무관하고 어떠한 유닉스 운영체제에서도 돌아가는 명령행 도구는 Perl.<br>웹 브라우저는 JavaScript</p><p>요점은 문법, 언어적 특성, systax에만 기준을 두고 언어를 고르는건 우매한 짓이다.</p><p>즉, 각각의 언어적 특성을 이해하고 비즈니스에 맞게 또 플랫폼에 맞춰서 고르자.</p><p>출처 : 조엘 스풀스키, 『 조엘 온 소프트웨어』, 박재호 이해영 옮김, 에이콘(2005.4), 1장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1장에서 물어보는 것은 개발자가 업무를 수행할 때 특정 프로그래밍 언어를 선택하는 이유?인것 같다.&lt;br&gt;
번개같은 속도는 C, 배포판을 윈도우로 한정 짓자면 MFC, C++ 또 맥, 윈도우, 리눅스 처럼 여러 플랫폼에서 구동시킬 경우 Java&lt;
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/tags/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
  </entry>
  
  <entry>
    <title>Joel On Software, UniCode</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JoelOnSoftwareUnicode/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JoelOnSoftwareUnicode/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:51:21.427Z</updated>
    
    <content type="html"><![CDATA[<h2>4장 개발자가 꼭 알아둬야 할 유니코드와 문자 집합에 대한 고찰</h2><p>저자는 21세기 전문 개발자가 문자, 문자 집합, 인코딩, 유니코드를 모른다면 잠수함에서 6개월간 양파 껍질을 까게 한다고 한다. 어지간히 관련 문제로 머리가 아팠던것 같다. 또 '일반 텍스트는 ASCII이고, 8비트 문자열이다’라는 개소리는 그만하라고 다그친다. 또 범세계적으로 동작하는 소프트에어를 만드는데 꼭 필요한 지식이라고 한다.</p><p>역사적인 관점<br>커닝헨 &amp; 리치가 C를 고안했던 시절에는 영문자만 처리해도 충분했던 시절이었고 모든 글자를 32~127 사이의 숫자를 이용해서 표현할 수 있는 ASCII 코드만 존재했다. 공백은 32, 영문자 A는 65로 나타낸다. ASCII는 편리하게 7비트로 글자를 저장할 수 있다. 요즘 대다수 컴퓨터가 8비트 기준 바이트를 최소 단위로 사용함으로 ASCII 문자를 저장하고도 비트를 하나 더 확보할 수 있었기에 유연성이 컸다.</p><p>여기서 개념 정리겸 기본 8비트(바이트) 단위의 표기법 정리를 하고 넘어가야 할것 같다. 2의 보수와 기본 단위인 바이트에 대해 검색 중에 좋은 글이 있어서 블로그에 포스팅해 뒀다. 궁금하면 읽어보시길… <a href="http://devshock.tistory.com/2" target="_blank" rel="noopener">http://devshock.tistory.com/2</a></p><p>이어서 바이트는 8비트까지 여분이 있기에 얼씨구나 128에서 255사이에 위치한 숫자를 마음대로 쓸수 있기에 너무나도 많은 사람들이 호작질을 한다는게 문제였다고 한다. 미국 이외 지역에서 PC를 판매하기 시작하면서 온갖 OEM 문자 형식이 쏟아지기 시작했는데 몇몇 PC에서 130은 é를 표시하지만 이스라엘에서 팔린 컴퓨터에서 이 글자는 히브리 글자인 지멀(λ)로 표시하기에, 미국 사람이 이력서(résumé)라는 단어를 이스라엘로 보내면 rλsumλ로 도착한다. 이러한 OEM 문자 집합 혼돈의 시대에서 ANSI 표준 위원회가 등장한다. ANSI 표준을 정립하면서 128 미만 문자에 대해서 어떻게 처리할지 표준을 정리했다. 하지만 여전히 여러 지역에 따라 128 이상 문자를 다루는 여러가지 방법이 존재했는데 이를 코드 페이지라고 한다. 각각의 나라에서 자기 나라에 맞는 문자들을 128 이상 문자열에서 사용하도록 정의하면서 체계가 정립됐다. 반면 아시아에서는 사람을 환장하게 만드는 여러가지 요소를 고려해야 한다. 아시아 문자 집합은 결코 8비트에 들어갈 수 없는 수천가지 글자로 이루어져 있다. 이런 문제점은 DBCS ( Double Bytes Character Set )으로 부르는 두 바이트 문자 집합 시스템으로 해결했다. 몇몇 글자는 1바이트에 저장하고, 다른 글자는 2바이트에 저장하는 골 때리는 방식이다. 문자열을 따라 쉽게 앞으로 나갈 수는 있지만, 뒤로 돌아오기에는 무척 어려운 구조인데, 앞뒤로 왔다 갔다 하기 위해 S++나 S–를 사용하는 대신에 윈도우에서는 AnsiNext나 AnsiPrev 같은 함수를 호출하도록 개발자를 독려하고 있다.</p><p>하지만 여전히 대다수 사람들은 단순하게도 바이트가 글자이고, 글자는 8비트라고 가정하고 있다. 물론 문자열을 다른 컴퓨터로 옮기거나 컴퓨터 하나에서 언어를 둘 이상 처리하지 않는 경우에는 이런 가정이 통했을 거다. 하지만 인터넷 세상이 열리면서 특정 컴퓨터에서 다른 컴퓨터로 문자열이 이동하는 일이 자연스러워지면서 모든 가정에 금이 가기 시작했다.</p><p>그래도 불행 중 다행으로 우리에게는 유니코드가 있다.</p><h3>유니 코드 ( Unicode )</h3><p>유니코드는 지구상에 존재하는 모든 이성적인 쓰기 시스템은 물론이고 스타트렉에 나오는 클링온(Klingon)과 같이 공상 과학 영화에서나 나올 법한 언어까지 모두 포함하는 단일 문자 집합을 만들기 위한 노력 끝에 나온 결과물이다. 몇몇 사람은 유니코드가 각 글자마다 16비트를 차지하니까 65536개라는 수많은 문자를 사용할 수 있는 단순한 16비트 코드 시스템이라고 오해하고 있다. 실제로 유니코드는 글자를 다루는 일종의 철학이고 사물을 생각하는 유니코드 방식을 이해할 필요가 있다. 그렇지 않으면 유니코드가 어떻게 사용되는지 감도 오지 않을 것이다.</p><p>지금까지 우리는 글자를 디스크나 메모리에 저장할 수 있는 비트 몇 개로 치환한다고 가정했었다.</p><p><code>A - &gt; 0100 0001</code></p><p>유니코드에서 글자는 코드 포인트라는 단순히 이론적인 개념으로 가정한다. 메모리나 디스크에서 어떻게 코드 포인트를 표현하는지는 완전히 다른 얘기이다. 유니코드에서 글자 A는 관념적인 이상이고, 공중에 둥둥 떠다닌다.</p><p><code>A</code></p><p>이 관념적인 A는 B와 다르고 a와도 다르다. 하지만 A, Å, Α, Ä와는 동일하다. Times New Roman 폰트로 적은 A는 Helvetica 폰트로 적은 A와 동일한 문자지만, 소문자로 쓴 'a’와는 다르다는 개념은 크게 논쟁거리가 되지 않지만, 독일 글자인 ß가 진짜 글자일까? 단순히 ss를 쓰기 쉽게 만든 글자일까? 글자 모양이 단어 끝에서 바뀌면 다른 글자가 돼야 하나? 히브리어는 그렇고 아랍어는 그렇지 않다. 각 문자의 사정이야 어찌 됐든 유니코드 컨소시엄에 속한 똑똑한 분들은 이 사실을 몇 세기 전부터 알고 있었고 이를 수정 보완하는 작업을 거쳤기에 걱정할 필요가 없다. 이미 유니코드 컨소시엄에서 다 알아서 처리했기 때문이다.</p><p>유니코드 컨소시엄은 각 알파벳에 존재하는 관념적인 철자마다 고유 번호를 붙여놓았고, U+0645라는 식으로 표현한다. 이 고유 번호를 코드 포인트라고 부른다. U+는 '유니 코드’를 의미하며, 숫자는 16진수로 표현한다. U+0639는 아라비아 글자인 Ain을 나타낸다. 영어 A는 U+0041이다. 실질적으로 유니코드가 정의할 수 있는 글자 개수에는 제한이 없다. 사실 이미 코드 숫자가 65536을 넘었기 때문에 모든 유니코드 글자는 실제로 2바이트로 압축할 수 조차 없다. 여튼 16비트 유니코드는 미신이다.</p><p>이제 문자열을 다뤄보자<br>Hello를 유니코드로 표현할떄 다음과 가같은 코드 포인트 5개로 대응시킬 수 있다.</p><p><code>U+0048 U+0065 U+006C U+006C U+006F</code></p><p>단순한 코드 포인트 묶음이다. 지금까지는 표현 방법에 대한 문제였고 이제 이 문자열을 어떻게 이메일 메시지에서 표현하는지, 또 메모리에 올리는 지 얘기할 차례이다.</p><p>인코딩 ( Encoding )<br>2바이트라는 미신을 이끌어낸 유니코드 인코딩에 대한 초기 아이디어에 따르면, 단순 코드 포인트 숫자를 각각 두바이트로 저장하자는 것이었기에 Hello는 다음과 같이 표현할 수 있다.</p><p><code>00 48 00 65 00 6C 00 6C 00 6F</code></p><p>이렇게 표현할 수 있다. 하지만 다음과 같은 표현법은 어떠한가?</p><p><code>48 00 65 00 6C 00 6C 00 6F 00 ?</code></p><p>기술적으로 두가지 모두 가능하다. 초기에는 CPU에 맞춰 유니코드 코드 포인트를 빅 엔디안이나 리틀 엔디안 모드로 저장할 수 있었기 떄문이다. 따라서 유니코드 문자열 시작부분에 FE, FF를 저장하는 희한한 관례가 생기게 됐다. 이를 유니코드 바이트 순서 표시라고 부르며 상위와 하위 바이트 순서를 바꿀 경우 FF FE로 보이므로 이런 문자열을 읽는 경우에 다른 모든 바이트 순서를 반드시 뒤집을 필요가 있음을 알 수 있다. 하지만 이상과 달리 현실에서는 모든 유니코드 문자열의 시작 부분에 바이트 순서를 표시하지는 않는다.</p><p>하지만 미국 국적 개발자는 유니코드의 U+00FF 상위에 존재하는 코드 포인트를 사용하지 않고 일반 영문 텍스트만을 쓰면서 공간을 낭비하는 00들에 불만을 표현하기 시작했다. 대다수 사람들은 이런 이유로 유니코드를 여러 해 동안 무시했고, 그동안 상황은 더욱 나빠졌다.</p><p>하지만 이때 UTF-8로 불리는 기가막힌 개념이 등장했다. UTF-8은 유니코드 코드 포인트를 따르는 문자열을 저장하기 위한 또 다른 시스템으로 8비트 바이트를 이용해 매직 U+넘버를 기억공간에 저장한다.</p><p>UTF-8에서는 0에서 127사이에 존재하는 모든 코드 포인트를 단일 바이트로 저장한다. 128인 코드 포인트만 2~3 바이트에서 시작해 최대 6바이트까지 확장해서 저장한다.<br>즉, 첫번째 Byte가 어떤 값이냐에 따라 문자 표현을 1byte로 하기도 하고 2~3byte를 쓰기도 한다. 반면 UNICODE는 무조건 2byte를 사용하기 때문에 이런 부분에서 유연성을 가지는 것이다.</p><p>인코딩에 대해 가장 중요한 사실 한 가지<br>지금까지 설명한 내용을 모두 잊어버려도 가장 중요한 한가지는 기억하고 가야한다. 인코딩 방식을 모르는 문자열은 아무 의미가 없다는 사실이다. 더 이상 타조처럼 모래에 머리를 파묻고 '일반’텍스트는 ASCIIㄹ고 가정할 수는 없다.</p><p><code>'일반 텍스트'</code>라는 개념은 존재하지 않는다.</p><p>메모리나 파일이나 이메일 메시지 내부에 문자열이 있으면 이 문자열 인코딩이 무엇인지 알아야만 하고, 그렇지 못하면 이 문자열을 해석할 수도 없으며 사용자에게 올바르게 보여줄수도 없다.</p><p><a href="http://rakuraku.tistory.com/96" target="_blank" rel="noopener">http://rakuraku.tistory.com/96</a><br>출처 : 조엘 스폴스키 지음, 박재호 이해영 옮김, 『 조엘 온 소프트웨어, 유쾌한 오프라인 블로그 』, 에이콘(2005.5), 4장 인용S</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;4장 개발자가 꼭 알아둬야 할 유니코드와 문자 집합에 대한 고찰&lt;/h2&gt;
&lt;p&gt;저자는 21세기 전문 개발자가 문자, 문자 집합, 인코딩, 유니코드를 모른다면 잠수함에서 6개월간 양파 껍질을 까게 한다고 한다. 어지간히 관련 문제로 머리가 아팠던
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
      <category term="Unicode" scheme="http://jungha-cho.github.io/categories/Book/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/Unicode/"/>
    
    
      <category term="조엘온소프트웨어" scheme="http://jungha-cho.github.io/tags/%EC%A1%B0%EC%97%98%EC%98%A8%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"/>
    
  </entry>
  
  <entry>
    <title>Standard Of Java, Chapter 12. Annotation</title>
    <link href="http://jungha-cho.github.io/2017/04/10/StandardOfJavaAnnotation/"/>
    <id>http://jungha-cho.github.io/2017/04/10/StandardOfJavaAnnotation/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:51:32.203Z</updated>
    
    <content type="html"><![CDATA[<h3>Chapter 12. Annotation</h3><ul><li>어노테이션은 주석처럼 프로그램에 영향을 주지 않으면서 다른 프로그램이나 플러그인에게 유용한 정보를 제공한다.</li><li>Ex @Test 어노테이션은 테스트 프로그램에게 이 메소드는 테스트가 필요하다는 것을 알린다.</li><li>즉, 테스트 프로그램에게 알리는 용도일 뿐 프로그램 자체에는 아무런 영향을 미치지 않는다.</li></ul><h3>표준 어노테이션</h3><p><code>@Override</code>컴파일러에게 오버라이딩하는 메서드라는 것을 알린다.<br><code>@Deprecated</code>앞으로 사용하지 않을 것을 권장하는 대상에 붙인다.<br><code>@SuppressWarning</code>컴파일러의 특정 경고 메시지가 나타나지 않게 해준다.<br><code>@SafeVarargs</code> 지네릭스 타입의 가변인자에 사용한다 (JDK1.7)<br><code>@Functionallnterface</code>함수영 인터페이스 라는 것을 알린다. (JDK1.8)<br><code>@Native</code> native 메서드에서 참조되는 상수 앞에 붙인다. (JDK1.8)<br><code>@Target*</code>어노테이션이 적용 가능한 대상을 지정하는데 사용한다.<br><code>@Documented*</code>어노테이션 정보가 javadoc으로 작성된 문서에 포함되게 한다.<br><code>@Inherited*</code>어노테이션이 자손 클래스에 상속되도록 한다.<br><code>@Retention*</code>어노테이션이 유지되는 범위를 지정하는데 사용한다.<br><code>@Repeatable*</code>어노테이션을 반복해서 적용할 수 있게 한다.(JDK1.8)</p><h3>이 붙은 것들은 메타 어노테이션.</h3><p><code>@Override</code><br>오버라이딩 할떄 부모 메소드의 이름을 잘못 적어 오버라이드 하더라도 컴파일러는 새로운 메소드로 인식할 뿐 에러를 뿜지 않는다.<br>따라서 상속받고 오버라이딩 한 메소드에 @Override라고 적으면 에러를 뿜는다.<br><code>@Deprecated</code><br>JDK가 릴리즈 될떄 기존의 메소드나 클래스의 위험, 보안 등등 여러가지 문제로 다른 메소드로 대처하거나 없애고 싶을떄 이 어노테이션을 붙임으로써 권고를 띄운다.<br>즉, 새로 추가된 개선된 기능을 사용하도록 유도하는 것이다.<br><code>@FunctionalInterface</code><br>함수형 인터페이스를 선언할떄 이 어노테이션을 붙이면 컴파일러는 올바르게 선언했는지 확인한다. 실수를 줄이기 위해 사용하자.<br><code>@SuppressWarning</code><br>컴파일러가 보여주는 경고 메세지가 나타지 않게 억제해준다.<br>JDK의 버전이 올라갈 수록 경고는 추가된다.<br><code>Deprecation</code>은 앞의 <code>@Deprecated</code>가 붙은 대상을 사용할 떄<br><code>unchecked</code>는 지네릭스 타입을 지정하지 않았을떄 발생하는 경고<br><code>rawtypes</code>는 지네릭스를 사용하지 않아서 발생하는 경고<br><code>varargs</code>는 가변인자의 타입이 지네릭 타입일떄 발생하는 경고를 억제할떄 사용한다.</p><p>메타 어노테이션</p><p>어노테이션을 위한 어노테이션<br>어노테이션을 적용할떄 어노테이션의 적용대상이나 유지기간등을 지정한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target (&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface SuppressWarnings &#123;</span><br><span class="line">String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Target으러 지정할 수 있는 애너테이션 적용 대상의 종류<br><code>ANNOTATION_TYPE</code>애너테이션<br><code>CONSTRUCTOR</code>생성자<br><code>FIELD</code>필드 ( 멤버 변수, enum 상수 )<br><code>LOCAL_VARIABLE</code>지역 변수<br><code>METHOD</code>메서드<br><code>PACKAGE</code>패키지<br><code>PARAMETER</code>매개 변수<br><code>TYPE</code>타입 ( 클래스, 인터페이스, enum )<br><code>TYPE_PARAMETER</code>타입 매개변수 (JDK1.8)<br><code>TYPE_USE</code>타입이 사용되는 모든 곳 (JDK1.8)</p><p><code>@Retention</code><br>유지 정책<br><code>@Documented</code><br>애너테이션 정보가 JavaDoc 포함<br><code>@Inherited</code><br>어노테이션이 자손 클래스에 상속되도록 한다.</p><p>출처 : 남궁성, 『 자바의 정석 3/E』, 도우출판(2016.1.27), chapter 12 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Chapter 12. Annotation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어노테이션은 주석처럼 프로그램에 영향을 주지 않으면서 다른 프로그램이나 플러그인에게 유용한 정보를 제공한다.&lt;/li&gt;
&lt;li&gt;Ex @Test 어노테이션은 테스트 프로그램에게 이 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Annotation" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/Annotation/"/>
    
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Annotation" scheme="http://jungha-cho.github.io/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>Standard Of Java, Chapter 12. Generics</title>
    <link href="http://jungha-cho.github.io/2017/04/10/StandardOfJavaEnum/"/>
    <id>http://jungha-cho.github.io/2017/04/10/StandardOfJavaEnum/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:51:50.811Z</updated>
    
    <content type="html"><![CDATA[<h3>Chapter 12. Enum</h3><ul><li>열거형 정의 방법은 다양하다.</li><li>Enum Direction { EAST, SOUTH, WEST, NORTH }</li><li>열거형 상수간에 비교에는 ==을 사용할 수 있다.</li><li>Equals() 가 아닌 ==로 비교가 가능하다는 것은 그만큼 빠른 성능을 제공한다는 것이다.</li></ul><h2>compareTo()는 왼쪽이 크면 양수 오른쪽이 크면 음수 같으면 0을 반환한다.</h2><p>Switch문에도 활용 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Void move()&#123;</span><br><span class="line">switch (dir) &#123;</span><br><span class="line">case EAST : x++;</span><br><span class="line">break;</span><br><span class="line">case WEST : x—;</span><br><span class="line">break;</span><br><span class="line">case SOUTH : y++;</span><br><span class="line">break;</span><br><span class="line">case NORTH : y—;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Enum Direction&#123;</span><br><span class="line">EAST(1, “&gt;”), SOUTH(2, “V”), WEST(3, “&lt;“), NORTH(4, “^”);</span><br><span class="line">…..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>즉, 열거형을 사용하는 장점에 코드가 좀더 깔끔해진다는 것 뿐인가?</p></li><li><p>열거형의 활용법을 고민해봐야 되겠다.</p></li><li><p><a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/chapter12/AbstractEnum.java" target="_blank" rel="noopener">https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/chapter12/AbstractEnum.java</a></p></li><li><p>열거형에 추상 메소드를 추가해 열거형 상수가 해당 메소드를 만들도록 강제할수도 있다.</p></li><li><p>내부적으로 모든 열거형은 추상 메소드 Enum 클래스의 자손이고 각각의 상수는 각각 한개의 객체이다.</p></li><li><p>내부적으로 열거형은 &lt;T extends Enum<t>&gt;를 제네릭 타입으로 가지고 있고 비교를 위해 Comparable<t>를 구현하고 있따.</t></t></p></li><li><p>복잡한 상속과 구현간의 구조로 인해 열거형에 추상 메서드를 추가하면 각 열거형 상수가 추상 메서드를 구현하도록 강제하는 이유를 설명하고 있는데….</p></li><li><p>잘 이해되진 않는다. 추가 공부가 필요할 듯 하다.</p></li></ul><p>출처 : 남궁성, 『 자바의 정석 3/E』, 도우출판(2016.1.27), chapter 12 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Chapter 12. Enum&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;열거형 정의 방법은 다양하다.&lt;/li&gt;
&lt;li&gt;Enum Direction { EAST, SOUTH, WEST, NORTH }&lt;/li&gt;
&lt;li&gt;열거형 상수간에 비교에는 ==을 사용할 수 있다
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Generic" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/Generic/"/>
    
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Generic" scheme="http://jungha-cho.github.io/tags/Generic/"/>
    
  </entry>
  
  <entry>
    <title>Standard Of Java, Chapter 13. Thread</title>
    <link href="http://jungha-cho.github.io/2017/04/10/StandardOfJavaChater13Thread/"/>
    <id>http://jungha-cho.github.io/2017/04/10/StandardOfJavaChater13Thread/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:51:40.650Z</updated>
    
    <content type="html"><![CDATA[<h1>Chapter 13. Thread</h1><h3>멀티 쓰레딩의 장단점</h3><ol><li>CPU의 사용률을 향상시킨다.</li><li>사용자에 대한 응답성이 향상된다.</li><li>사용자에 대한 응답성이 향상된다,</li><li>작업이 분리되어 코드가 간결해 진다.</li></ol><h3>Context Switching</h3><ul><li>멀티 쓰레드 환경에서 문맥 전환( Context Switching )은 시간이 걸린다.</li><li>싱글코어와 멀티코어의 같은 작업에 대한 수행시간은 같거나 싱글 코어가 더 빠를수도 있다.</li><li>문맥 전환시 프로세스의 PCB에 저장되며, CPU의 레지스터 값, 프로세스의 상태, 메모리 관리 정보등을 포함한다.</li></ul><h3>Priority</h3><ul><li>쓰레드 우선순위는 쓰레드를 실행하기 전에만 변경할 수 있다.</li></ul><h3>Thread Group ( 쓰레드 그룹 )</h3><ul><li>쓰레드 그룹은 서로 관련된 쓰레드를 그룹으로 다루기 위한 것</li><li>쓰레드 그룹은 보안상의 이유로 도입된 개념이다.</li><li>자신이 속한 쓰레드 그룹이나 하위 쓰레드 그룹은 변경할 수 있지만 다른 쓰레드 그룹의 쓰레드를 변경할 수는 없다.</li><li>모든 쓰레드는 반드시 쓰레드 그룹에 포함되어 있어야 한다.</li><li>기본적으로 자신을 생성한 쓰레드와 같은 쓰레드 그룹에 포함 된다.</li><li>JVM은 main과 system이라는 쓰레드 그룹을 만들고 JVM 운영에 필요한 쓰레드들을 생성해서 이 쓰레드 그룹에 포함시킨다.</li><li>우리가 생성하는 모든 쓰레드 그룹은 main 쓰레드 그룹의 하위 쓰레드 그룹에 속하게 된다.</li></ul><h3>Daemon Thread ( 데몬 쓰레드 )</h3><ul><li>데몬 쓰레드는 다른 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드이다.</li><li>보조 역할이므로 일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제적으로 자동 종료되는데, 일반 쓰레드의 보조 역할 이므로 일반 쓰레드가 다 죽으면 존재 이유가 없다.</li><li>이 점을 제외 하고는 다른점이 없다.</li><li>가비지 컬렉터, 워드 프로세서의 자동 저장, 화면 자동 갱신</li></ul><h3>쓰레드의 동기화</h3><ul><li>Java.util.concurrent.locks, java.util.concurrent.atomic 패키지를 통해 다양한 방식으로 동기화를 구현할 수 있도록 지원, since jdk1.5</li><li>임계영역은 멀티 쓰레드 프로그램의 성능을 좌우하기 때문에 가능하면 메서드 전체에 락을 거는 것보다 synchronized 블럭으로 임계영역을 최소화 해서 보다 효율적인 프로그램이 되도록 노력해야 한다.</li><li>NotifyAll()은 모든 객체의 wating이 깨워지는것은 아니다. 객체마다 wating pool이 존재하기 때문이다.</li></ul><h3>Lock과 Condition을 이용한 동기화</h3><ul><li><p>Java,util.concurrent.locks 패키지가 제공하는 lock클래스를 이용하기.</p></li><li><p>synchronized 블럭은 자동적으로 잠기고 풀린다. 블럭 내에서 예외가 발생해도  lock은 자동적으로 풀리기 때문에 편리하다</p></li><li><p>하지만 같은 메서드 내에서만 lock을 걸 수 있다는 제약이 불편할때 java.util,concurrent.locks를 이용한다.</p></li><li><p>Reentrantlock : 재진입이 가능한 락, 가장 일반적인 베타 lock</p></li><li><p>Reentrantreadwritelock : 읽기에는 공유적이고 쓰기에는 베타적인 lock</p></li><li><p>stampedLock : reentrantreadwritelock에 낙관적인 lock의 기능을 추가</p></li><li><p>ReentrantReadWriteLock : 읽기 Lock은 동시에 읽기 가능. 읽기 Lock이 걸려있는 상태에서 Write 진입 불가, Write 락 중에서도 Read 불가.</p></li><li><p>StampedLock : 읽기와 쓰기를 위한 낙관적인 Lock. 쓰기와 읽기가 충돌할 떄만 쓰기가 끝난 후에 읽기 Lock을 건다.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">Try &#123;</span><br><span class="line">// 임계 영역</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일반적으로 finally로 묶어준다.<br>tryLock(); 은 lock을 얻으려고 기다리지 않느다. 지정된 시간 만큼만 기다리고 얻으면 true 아니면 false</p><h3>Volatile</h3><ul><li>멀티 코어 프로세서에서는 코어 마다 별도의 캐시를 가지고 있다.</li><li>코어는 메모리에서 읽어온 값을 캐시에 저장하고 캐시에서 값을 읽어서 작업한다.</li><li>다시 같은 값을 읽어올 떄는 먼저 캐시에 있는지 확인하고 없을때만 메모리에서 읽어온다.</li><li>But 도중에 메모리에 저장된 값이 다른 경우가 발생한다. 그래서 변수 stopped의 값이 바뀌었는데도 쓰레드가 멈추지 않고 계속 실행되는 것이다.</li><li>변수 앖에 volatile boolean stopFlag = false; 를 붙이면 캐시가 아닌 메모리에서 값을 읽어오기 때문에 캐시와 메모리간 값의 불일치가 해결된다.##</li><li>volatile 대신 synchronized 블럭을 사용해도 같은 효가를 얻을수 있다. 쓰레드가 synchronized 블럭으로 들어갈때와 나올때 캐시와 메모리간의 동기화가 이루어 지기 때문에 값의 불일치가 해소된다.</li></ul><h3>volatile로 long과 double를 원자화</h3><ul><li>JVM은 데이터를 4 바이트(=32bit) 단위로 처리하기 때문에 인트와 인트보다 작은 타입들은 한번에 읽거나 쓰는것이 가능하다.</li><li>이는 하나의 명령어로 처리 가능하고 더이상 나눌수 없는 최소의 작업 단위 임으로 작업 중간에 다른 쓰레드가 끼어들 틈이 없다.</li><li>그러나 크기가 8byte인 long과 double 타입의 변수는 하나의 명령어로 값을 읽거나 쓸수 없다. 따라서 다른 쓰레드가 끼어들 여지가 있다.</li><li>따라서 volatile long sharedVal; volatile double sharedVal;로 8byte를 원자화한다.</li><li>하지만 volatile은 변수의 읽기와 쓰기를 원자화 할뿐 동기화 하는것은 아니다.</li></ul><h3>Fork &amp; join 프레임 워크</h3><ul><li><p>코어가 늘어나는 CPU가 발전함에 따라 멀티코어를 잘 활용할 수 있는 멀티 쓰레드 프로그래밍이 중요해지고 있다.</p></li><li><p>JDK 1.7부터 fork&amp;join 프레임 웍이 추가되었고 이 프레임 웍은 하나의 작업을 작은 단위로 나눠서 여러 쓰레드가 동시에 처리하는 것을 쉽게 만들어 준다.</p></li><li><p>RecursiveAction : 반환값이 없는 작업을 구현할때, RecursiveTask : 반환값이 있는 작업을 구현할때</p></li><li><p>ForkJoinPool pool = new ForkJoinPool();</p></li><li><p>SumTask task = new SumTask(from, to);</p></li><li><p>Long result = pool.invoke(task);</p></li><li><p>ForkJoinPool은 해당 프레임웍에서 제공하는 쓰레드 풀로 지정된 쓰레드를 생성해 미리 만들어놓고 반복해서 재사용할 수 있게 한다.</p></li><li><p>쓰레드를 반복해서 생성하지 않아도 된다는 장점과, 너무 많은 쓰레드가 생성되어 성능이 저하되는 것을 막아준다는 장점이 있다.</p></li><li><p>쓰레드 풀은 쓰레드가 수행해야하는 작업이 담긴 큐를 제공하며 각 쓰레드는 자신의 작업 큐에 담긴 작업을 순서대로 처리한다.</p></li><li><p>쓰레드 풀은 기본적으로 코어의 개수와 동일한 개수의 쓰레드를 생성한다.</p></li><li><p>fork()는 비동기 메서드, join()은 동기 메서드이다.</p></li></ul><p>출처 : 남궁성, 『 자바의 정석 3/E』, 도우출판(2016.1.27), chapter 13 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Chapter 13. Thread&lt;/h1&gt;
&lt;h3&gt;멀티 쓰레딩의 장단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CPU의 사용률을 향상시킨다.&lt;/li&gt;
&lt;li&gt;사용자에 대한 응답성이 향상된다.&lt;/li&gt;
&lt;li&gt;사용자에 대한 응답성이 향상된다,&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Thread" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/Thread/"/>
    
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Thread" scheme="http://jungha-cho.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Standard Of Java, Chapter 12. Generics</title>
    <link href="http://jungha-cho.github.io/2017/04/10/StandardOfJavaGenerics/"/>
    <id>http://jungha-cho.github.io/2017/04/10/StandardOfJavaGenerics/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:52:01.721Z</updated>
    
    <content type="html"><![CDATA[<h3>Chapter 12. Generic</h3><h3>Generics란?</h3><ul><li>다양한 타입의 객체를 다루는 메소드나 컬렉션 클래스에 컴파일 시 Type을 체크해 주는 기능이다.</li><li>객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형 변환의 번거로움이 줄어든다.</li></ul><h3>Type 안정성?</h3><ul><li><p>의도하지 않은 타입의 객체가 저장되는 것을 막는다.</p></li><li><p>원래의 타입과 다른 타입으로 잘못 형 변환 되어 발생할 수 있는 오류를 줄여준다.</p></li><li><p>ArrayList temp와 ArrayList<string> temp의 차이인듯 하다.</string></p></li><li><p>각각 넣을때와 꺼낼때 타입 체크와 형변환을 생략할 수 있다.</p></li></ul><h3>Generics의 장점</h3><ul><li>타입 안정성을 제공한다.</li><li>타입 체크와 형변환을 생략할 수 있으므로 코드가 간결해 진다.</li></ul><h3>정리 하자면</h3><ul><li>다루고자 하는 객체의 타입을 미리 명시해 줌으로써 번거로운 형변환을 줄여준다는 얘기다.</li></ul><h3>Generic 클래스의 선언</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class name&lt;T&gt;&#123;</span><br><span class="line">T name;</span><br><span class="line"></span><br><span class="line">void setName (T item)&#123; this.name = item; &#125;</span><br><span class="line">T getName () &#123; return name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name&lt;String&gt; b = new name&lt;String&gt;(); // 타입 T 대신 실제 타입 지정</span><br><span class="line">b.setName(new Object()); // 에러, String만</span><br><span class="line">b.setName(“duh”);</span><br><span class="line"></span><br><span class="line">Name b = new name(); // 이전 방식으로도 생성 가능하다. 호환성 문제로 지원</span><br><span class="line">b.setName(“ABC”);// 지네릭 타입을 지정하지 않아서 안전하지 않다는 경고 발생</span><br></pre></td></tr></table></figure><p>name<t> 지네릭 클래스, T의 name, T name이라고 읽는다.</t></p><p>T타입 변수 또는 타입 매개변수 ( T는 타입 문자 )</p><p>Box원시 타입 ( raw type )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">또한 다형성과 상속관계에 따라 다음과 같은 T도 허용 가능하다.</span><br><span class="line">Name&lt;Korea&gt; newName = new KoreaName&lt;Korea&gt;; // 다형성</span><br><span class="line"></span><br><span class="line">Name&lt;Korea&gt; newName = new KoreaNmae&lt;Korea&gt;;</span><br><span class="line">newName.add(new Korea);</span><br><span class="line">newName.add(new childKorea); // 상속관계</span><br><span class="line">제한된 Generic 클래스</span><br><span class="line">매개타입 T를 제한하는 방법</span><br><span class="line">Class KoreaName(T extends Korea)&#123; // Korea의 자손만 타입으로 지정 가능</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">매개변수가 Interface를 구현해야 한다고 하더라도 extends를 사용한다.</span><br><span class="line">클래스 Korea의 자손이면서 SouthKorea를 구현해야 한다면..</span><br><span class="line">Class KoreaName&lt;T extends Korea &amp; SouthKorea&gt;&#123;…&#125;</span><br><span class="line"></span><br><span class="line">와일드 카드</span><br><span class="line">메소드 오버로딩시 Generic 타입이 다른것 만으로는 오버로딩이 성립되지 않는다. 오히려 메소드 중복 정의이다.</span><br><span class="line">이때 사용하기위해 고안된 것이 와일드 카드이다.</span><br><span class="line">&lt;? extends T&gt;   : 와일드 카드 상한 제한. T와 그 자손들만 가능</span><br><span class="line">&lt;? super T&gt;   : 와일드 카드 하한 제한. T와 그 부모들만 가능</span><br><span class="line">&lt;?&gt;     : 제한 없음</span><br><span class="line"></span><br><span class="line">Generic Type의 형변환</span><br></pre></td></tr></table></figure><p>출처 : 남궁성, 『 자바의 정석 3/E』, 도우출판(2016.1.27), chapter 7 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Chapter 12. Generic&lt;/h3&gt;
&lt;h3&gt;Generics란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다양한 타입의 객체를 다루는 메소드나 컬렉션 클래스에 컴파일 시 Type을 체크해 주는 기능이다.&lt;/li&gt;
&lt;li&gt;객체의 타입을 컴파일 시에 체크하
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Generic" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/Generic/"/>
    
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Generic" scheme="http://jungha-cho.github.io/tags/Generic/"/>
    
  </entry>
  
  <entry>
    <title>Standard Of Java, Interface</title>
    <link href="http://jungha-cho.github.io/2017/04/10/StandardOfJavaInterface/"/>
    <id>http://jungha-cho.github.io/2017/04/10/StandardOfJavaInterface/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:52:11.797Z</updated>
    
    <content type="html"><![CDATA[<h3>JAVA Interface</h3><ul><li><p>개발 시간을 단축시킬 수 있다. ( 설계도를 제공 )</p></li><li><p>표준화가 가능하다. (ex. Jdbc Interface )</p></li><li><p>서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다. ( 공통 부분을 묶어서 inteface로 작성하고 implements로 구현하게 하면 된다. )</p></li><li><p>독립적인 프로그래밍이 가능하다. ( 선언부와 구현부의 분리 )</p></li><li><p>구문 분석기는 Interface를 구현해서 원하는 함수를 실행 가능 하다</p></li><li><p>Chapter 7. 객체지향 프로그래밍 2, p. 389</p></li><li><p>분산환경 프로그래밍에서 그 위력을 발휘한다.</p></li><li><p>사용자 컴퓨터에 설치된 프로그램을 변경하지않고 서버측의 변경만으로도 사용자가 새로 개정된 프로그럄을 사용하는것이 가능하다.</p></li><li><p>실제로 자바에서는 다수의 데이터베이스 관련된 다수의 인터페이스를 제공하고 있다.</p></li><li><p>이는 데이터베이스에 종속적이지 않은 프로그램을 구현 가능하게 한다.</p></li></ul><h3>Arraycopy, fill</h3><ul><li><p>System.arraycopy(Object src, ins srcPos, Object dest, int destPos, int length){}</p></li><li><p>// 원본, 원본 시작 위치, 복사본, 복사본 시작위치, 복사본에서 읽어올 만큼</p></li><li><p>// 원본 시작위치에서 복사본에다가 읽어올 만큼 읽어옴</p></li><li><p>Arrays.fill(byte[] paramArrayOfByte, int paramInt1, int paramInt2, byte paramByte){}</p></li><li><p>// 원본 바이트 배열, 1부터 2까지 paramByte로 채우기</p></li></ul><h3>Instanceof</h3><ul><li>왼쪽의 피검사 오브젝트가 오른쪽의 검사 오브젝트인지 검사</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">If (ProcessManager.getThreadDLV(key) instanceof SMSSEND)</span><br><span class="line">&#123;</span><br><span class="line">thread = new Thread (((SMSSEND) ProcessManager.getThreadDLV(key)));</span><br><span class="line">&#125;</span><br><span class="line">Else if (ProcessManager.getThreadDLV(key) instanceof MMSSEND)</span><br><span class="line">&#123;</span><br><span class="line">thread = new Thread (((MMSSEND) ProcessManager.getThreadDLV(key)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>초기화 블럭!!</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class initBlock &#123;</span><br><span class="line">static &#123; /* 클래스 초기화 블럭 */ &#125;</span><br><span class="line">&#123; /*인스턴스 초기화 블럭 */ &#125;</span><br><span class="line">// …..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : 남궁성, 『 자바의 정석 3/E』, 도우출판(2016.1.27), chapter 7 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;JAVA Interface&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;개발 시간을 단축시킬 수 있다. ( 설계도를 제공 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;표준화가 가능하다. (ex. Jdbc Interface )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서로 관
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Interface" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/Interface/"/>
    
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Interface" scheme="http://jungha-cho.github.io/tags/Interface/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java, 일반적으로 통용되는 작명 관습을 따르라 ( naming convention )</title>
    <link href="http://jungha-cho.github.io/2017/04/10/EffectiveJavaNamingConvention/"/>
    <id>http://jungha-cho.github.io/2017/04/10/EffectiveJavaNamingConvention/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:46:14.398Z</updated>
    
    <content type="html"><![CDATA[<p>작명 규칙을 어기는 API는 사용하기 어렵다. 이 규칙을 어기는 구현은 유지보수하기 어렵다. 어느 쪽이건 간에, 철자에 관계된 작명 규칙을 어기면 그 코드를 이용할 프로그래머는 혼란스러워 할 뿐 아니라 짜증을 낼 것이고, 오류로 이어질 잘못된 가정들을 하게 될 것이다. - effective java</p><h3>패키지</h3><p>패키지 이름은 마침표를 구분점으로 사용하는 계층적 이름이어야 한다.</p><p>패키지 이름을 구성하는 각각의 컴포넌트는 알파벳 소문자로 구성하고, 숫자는 거의 사용하지 않는다.</p><p>여러분의 조직 바깥에서 이용될 패키지 이름은 해당 조직의 인터넷 도메인 이름으로 시작해야 하는데, edu.cmu, com.sun, gov.sna 처럼 최상위 도메인 이름이 먼저 온다.</p><p>예외적으로, 표준 라이브러리와 그 옵션 패키지 명은 java와 javax로 시작한다.</p><p>사용자는 java나 javax로 시작하는 패키지 이름을 만들면 안 된다.</p><p>패키지 이름의 나머지 부분은 어떤 패키지인지 설명하는 하나 이상의 컴포넌트로 구성된다. 패키지명 컴포넌트는 짧아야 하며, 보통 여덟 문자 이하로 만들어진다. 의미가 확실한 약어를 활용하면 좋다. 즉, utilities 대신 util 이라고 하면 좋다는 것, awt 같은 두문자(acronym)도 사용 가능하다.</p><p>일반적으로 패키지 명 컴포넌트는 하나의 단어나 약어라야 한다.</p><h3>자료형</h3><p>enum이나 어노테이션 자료형 이름을 비롯, 클래스나 인터페이스 이름은 하나 이상의 단어로 구성된다. 각 단어의 첫 글자는 대문자다. Timer나 FutureTask가 그 예다.</p><p>두문자 또는 max나 min처럼 널리 쓰이는 약어를 제외하면, 약어 사용은 피해야 한다.</p><p>두문자의 경우 전부 대문자로 써야하는지, 아니면 그 첫글자만 대문자로 써야 하는지에 대해서는 합의된것이 별로 없다.</p><h3>HTTPURL vs HttpUrl</h3><p>메서드, 필드<br>클래스나 인터페이스와 동일하지만 첫 글자는 소문자로 한다</p><h3>remove, ensureCapacity</h3><p>상수 필드<br>상수 필드는 모두 대문자로 구성하며 문자 사이에는 <code>_</code>로 구분한다.</p><h3>NEGATIVE_INFINITY</h3><p>static final 처럼 변경 불가능한 참조 자료형 일때 해당 필드는 상수 필드다.<br>예를 들면 enum 필드는 전부 상수 필드다.<br>static final이 변경 가능한 객체라도 참조되는 객체가 변경 불가능하면 역시 상수 필드다.<br>지역 변수<br>지역 변수 이름은 멤버 이름과 같은 철자 규칙을 따르지만 약어가 허용된다.</p><h3>i, xref, houseNumber</h3><p>자료형 인자</p><p>임의 자료형은 T</p><p>컬렉션 요소 자료형은 E</p><p>맵의 키와 값의 경우에는 T, U, V로 하거나 T1, T2, T3로 나열한다.</p><p>출처 : 조슈아 블로크, 『 Effective Java 2/E』, 이병준 옮김, 인사이트(2014.9.1), 2쪽 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;작명 규칙을 어기는 API는 사용하기 어렵다. 이 규칙을 어기는 구현은 유지보수하기 어렵다. 어느 쪽이건 간에, 철자에 관계된 작명 규칙을 어기면 그 코드를 이용할 프로그래머는 혼란스러워 할 뿐 아니라 짜증을 낼 것이고, 오류로 이어질 잘못된 가
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Convention" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/Convention/"/>
    
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/tags/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Convention" scheme="http://jungha-cho.github.io/tags/Convention/"/>
    
  </entry>
  
  <entry>
    <title>14. 채널 03. 파일 채널</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOFileChannel/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOFileChannel/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:47:11.241Z</updated>
    
    <content type="html"><![CDATA[<h1>03. 파일 채널</h1><p>각각의 파일채널 객체는 파일 디스크립터와 일대일 관계를 갖는다. 따라서 일반적으로 운영체제의 POSIX 시스템 콜과 대응되는 메소드를 제공한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel &#123;</span><br><span class="line">    public abstract long position ()</span><br><span class="line">    public abstract void position (long newPosition)</span><br><span class="line"></span><br><span class="line">    public abstract long size()</span><br><span class="line"></span><br><span class="line">    public abstract int read(ByteBuffer dst)</span><br><span class="line">    public abstract int read(ByteBuffer dst, long position)</span><br><span class="line">    public abstract int read(ByteBuffer[] dst)</span><br><span class="line">    public abstract int read(ByteBuffer[] dst, int offset, int length)</span><br><span class="line"></span><br><span class="line">    public abstract int write(ByteBuffer src)</span><br><span class="line">    public abstract int write(ByteBuffer src, long position)</span><br><span class="line">    public abstract int write(ByteBuffer src[])</span><br><span class="line">    public abstract int write(ByteBuffer src[], int offset, int length)</span><br><span class="line"></span><br><span class="line">    public abstract void truncate(long size)</span><br><span class="line">    public abstract void force(boolean metaData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각각의 파일채널은 파일 디스크립터와 일대일 관계를 맺는다. 따라서 각각의 파일채널 객체들은 파일 디스크립터와 같은 파일 포지션을 갖는다. 이 포지션은 앞서 살펴봤던 버퍼의 포지션과 같다. 파일 채널에서의 포지션은 현재 파일이 다음 번에 읽거나 쓸 위치를 가리키는 것이다.</p><p>어떤 파일은 파일 디스크립터 하나를 가지고 있는데 이 파일하나에 대해 여러개의 파일 또는 파일채널 인스턴스를 생성할 수 있다. 이렇게 되면 해당 파일의 파일 디스크립터를 공유하게 되므로 어떤 파일 하나 또는 파일채널 인스턴스가 포지션을 변경하면 다른 인스턴스에도 모두 바로 반영된다.</p><p>다음은 파일채널 인스턴스들이 파일 디스크립터를 공유하고 있는것을 보여주는 예제다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line">public class SharedFileChannelInstanceTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        RandomAccessFile raf = new RandomAccessFile(&quot;C:/test.doc&quot;, &quot;rw&quot;);</span><br><span class="line"></span><br><span class="line">        raf.seek(1000);</span><br><span class="line">        FileChannel fc = raf.getChannel();</span><br><span class="line">        System.out.println(&quot;File position : &quot; + fc.position());</span><br><span class="line"></span><br><span class="line">        raf.seek(500);</span><br><span class="line">        System.out.println(&quot;File position : &quot; + fc.position());</span><br><span class="line"></span><br><span class="line">        fc.position(100);</span><br><span class="line">        System.out.println(&quot;File position : &quot; + raf.getFilePointer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>같은 파일에 대한 인스턴스들인 임의 접근 파일과 파일채널은 어느 한쪽이 포지션을 변경하면 다른 쪽에서도 그변경이 곧 바로 반영된다는 것을 볼 수 있다.</p><p>파일 채널에서 제공하는 또 다른 기본 속성 메소드로는 size()가 있다. size()는 현재 파일 채널 객체에 접근하고 있는 파일의 크기를 long 형태로 리턴해주는 메소드다. 이제 파일 채널의 가장 기본적이면서 핵심적이라고 할 수 있는 읽기, 쓰기에 관련된 메소드를 살펴보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract int read(ByteBuffer dst)</span><br><span class="line">public abstract int write(ByteBuffer src)</span><br></pre></td></tr></table></figure><p>파일채널의 읽기, 쓰기 메소드 역시 포지션 속성과 연관되어 버퍼와 비슷한 동작을 수행하게 된다. 따라서 파일 채널 역시 버퍼의 읽기, 쓰기와 마찬가지로 read() 또는 write() 메소드로 파일에 데이터를 읽거나 쓰면 자동적으로 파일 포지션이 업데이트 된다.</p><p>구체적으로 위의 메소드들은 파라미터로 주어진 버퍼에서 데이터를 먼저 읽거나 쓴다. 그리고 이렇게 읽거나 쓰여진 데이터의 Byte만큼 파일의 포지션을 업데이트 하는 것이다. 기존의 파일 스트림과 같이 파일채널의 read() 메소드 역시 파일의 끝부분까지 다 읽은 경우 EOF(End Of File)을 의미하는 -1을 리턴한다.</p><p>파일채널의 write() 메소드로 파일에 데이터를 쓰는 도중에 파일의 끝부분에 다다르면 어떻게 될까? 이것이 버퍼와의 차이점인데, 버퍼의 경우 Exception을 던졌지만 파일 채널은 자동적으로 새롭게 쓰여질 바이트 만큼 파일의 크기를 자동적으로 늘린다.</p><p>파일 채널은 버퍼와 마찬가지로 절대적 방식으로 파일을 읽거나 쓸 수 잇는 메소드를 제공해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract int read(ByteBuffer dst, long position)</span><br><span class="line">public abstract int write(ByteBuffer src, long position)</span><br></pre></td></tr></table></figure><p>이 메소드들은 좀더 효율적으로 읽기, 쓰기 작업이 가능하다. 절대적 방식의 읽기, 쓰기에는 파일채널의 포지션을 변경할 필요가 없기 떄문이다. 따라서 채널의 변경이 필요 없으므로 IO 요청이 네이티브 코드에 직접적으로 전달된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final long read(ByteBuffer[] dsts)</span><br><span class="line">public final long read(ByteBuffer[] dsts, int offset, int length)</span><br><span class="line">public final long write(ByteBuffer srcs)</span><br><span class="line">public abstract long write(ByteBuffer srcs, int offset, int length)</span><br></pre></td></tr></table></figure><p>파일채널은 Scatter/Gather를 지원한다. 이것은 파일채널이 구현하는 인터페이스 목록을 보면 확실히 알 수 있다. 따라서 앞서 공부했던 Scatter/Gather 방식과 정확하게 같은 방식으로 파일채널은 읽기, 쓰기 메소드를 수행할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract void truncate(long size)</span><br><span class="line">public abstract void force(boolean metaData)</span><br></pre></td></tr></table></figure><p>truncate() 메소드는 인자로 주어진 크기로 파일을 잘라낸다. 즉, 파일의 현재 크기가 파라미터로 주어진 값보다 작거나 같으면 파일은 아무런 변화도 없게 된다. 하지만 파일이 파라미터로 주어진 값보다 작거나 같으면 파일은 아무런 변화도 없게 된다. 파일이 파라미터로 주어진 값보다 크다면 그 파일은 주어진 값의 크기로 잘라지게 된다.</p><p>force() 메소드는 파일의 업데이트된 내용을 강제적으로 기억장치에 기입하는 메소드다.</p><h3>2. 파일 락킹</h3><p>파일 채널이 지원하는 두 번쨰 특징적인 기능은 파일 락킹이다. 대부분의 운영체제들이 공유 락을 지원하기는 하지만 일부 운영ㅊ제에서는 공유 락을 지원하지 않는다. 자바는 플랫폼에서 상관없이 동일하게 동작해야 하기 때문에 공유 락을 지원하지 않는 운영체제와 파일 시스템에서 이것은 큰 문제가 될 수 있다.</p><p>자바의 NIO는 무조건 공유 락을 사용할 수 있다는 전제하에 만들어졌다. 다만, 해당 운영체제와 파일 시스템에서 공유 락이 지원되지 않을 경우에는 베타 락으로 설정하게 만든 것이다. 이것은 대부분의 운영ㅊ제와 파일 시스템이 공유 락을 지원한다는 점이 큰 이유가 되겠지만 또 다른 관점에서 NIO의 기본적인 노선인 성능 향상에 맞춘 것이라고 볼 수 있다. 항상 베타 락만을 사용하는 것보다는 공유 락과 함께 베타 락을 사용하는 것이 성능 향상에 더 도움이 되기 때문이다.</p><h3>3. 메모리 맵핑</h3><p>파일 채널이 지원하는 세번째 특징적인 기능은 메모리 맵 파일(Memory Mapped File)이다. 파일 채널 클래스는 map() 메소드를 제공하는데, 이 메소드의 호출을 통해 열려진 파일과 특별한 형태의 ByteBuffer(ByteBuffer) 사이에 가상 메모리가 생성된다. 이렇게 생성된 가상 메모리는 파일을 저장소로 사용하고 이 가상 메모리 영역은 이 메소드 호출로 리턴되는 MappedByteBuffer 객체가 래핑(Wrapping)하게 된다.</p><p>이렇게 생성된 MappedByteBuffer는 메모리 기반 버퍼처럼 동작한다. 그러나 이 버퍼의 저장소는 메모리가 아니라 파일이다. 따라서 이 버퍼에 어떤 내용을 읽거나 쓰면 그것은 곧바로 그 파일에 반영된다. 그렇기 때문에 MappedByteBuffer의 get() 메소드를 호출하면 파일로부터 데이터를 읽어오는데, 현재 파일의 내용이 반영된다. 혹 get() 메소드를 호출하기 바로 직전에 다른 프로세스에 의해 읽어올 부분의 데이터가 변경도었다면 그 변경된 내용이 읽혀올 것이다. 반대로 쓰기 권한이 있는 경우 put() 메소드를 호출하면 곧바로 MappedByteBuffer가 사용하는 파일을 업데이트 할 것이다. 메모리 맵핑 기법을 통한 파일 접근은 기존의 전통적인 자바 IO를 통한 방법과 떄로는 채널을 이용해서 데이터를 읽고 쓰는 방법보다도 훨씬 더 효율적이다.</p><p>시간을 소비하는 명시적인 시스템 콜이 필요 없기 떄문이다. 하지만 더욱 중요한 이유는 운영 체제의 가상 메모리 시스템은 자동적으로 메모리 페이지들을 캐시한다는 점이다. 이런 메모리 페이지들은 JVM의 메모리 영역인 힙을 전혀 사용하지 않고 시스템 메모리를 사용해서 캐시한다. 이렇게 한번 메모리 페이지가 정상적으로 만들어지면 그 데이터를 얻기 위해 다른 시스템 콜을 할 필요도 없이 하드웨어의 최고 속도로 그 데이터에 접근할 수 있기 때문이다. 따라서 지속적으로 참조되거나 빈번하게 업데이트되는 섹션 또는 인덱스를 포함하는 크고 복잡한 형태의 파일들은 메모리 매핑을 통해 엄청난 성능 향상을 가져올 수 있다. 이떄 파일 락킹과 결하시키면 크리티컬 섹션에 대한 안정적인 트랜잭션도 가능하다. 하지만 여기서 큰 파일이라는 것에 주의하다. 메모리 매핑은 크기가 작은 파일에 사용할 경우 오히려 기존 방식보다도 더욱 안좋은 성능을 가져온다.</p><h3>4. 채널 간 직접 전송</h3><p>파일채널이 제공하는 네 번쨰 특별한 기능은 채널에서 직접 채널로 데이터를 효율적으로 보낼 수 있도록 최적화된 다음의 메소드들이다.</p><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 14장 인용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;03. 파일 채널&lt;/h1&gt;
&lt;p&gt;각각의 파일채널 객체는 파일 디스크립터와 일대일 관계를 갖는다. 따라서 일반적으로 운영체제의 POSIX 시스템 콜과 대응되는 메소드를 제공한다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Channel" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Channel/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="Channel" scheme="http://jungha-cho.github.io/tags/Channel/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java, 일반적인 프로그래밍 원칙들</title>
    <link href="http://jungha-cho.github.io/2017/04/10/EffectiveJavaGeneralProgrammingRule/"/>
    <id>http://jungha-cho.github.io/2017/04/10/EffectiveJavaGeneralProgrammingRule/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:46:06.813Z</updated>
    
    <content type="html"><![CDATA[<h3>지역 변수의 유효범위를 최소화하라</h3><ul><li><p>처음으로 사용하는 곳 바로 위에 선언하라</p></li><li><p>거의 모든 지역 변수 선언에는 초기값이 포함되어야 한다.</p></li><li><p>while문 보다는 for문을 사용하라</p></li><li><p>메소드의 크기를 줄이고 특정 기능에 집중하라</p></li><li><p>하나의 메소드에 서로 다른 기능을 구현하면 유효 변수가 침해 될수 있으므로</p></li><li><p>for문 보다는 for-each문을 사용하라</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ex )</span><br><span class="line">For (Suit suit : suits)</span><br><span class="line">For (Suit suit : suits)</span><br><span class="line">deck.add(new Card(suit, rank));</span><br></pre></td></tr></table></figure><h3>For-each문의 장점</h3><ul><li>지역 변수 유효범위 자동적으로 최소화</li><li>For문에 비해 간단명료</li><li>버그 발생 가능성 적음</li><li>성능도 for문에 뒤지지 않음</li></ul><p>But 필터링, 변환, 병렬 순회에서는 for-each문은 못씀</p><p>For-each문으로는 컬렉션과 배열 뿐만아닐 Iterable 인터페이스를 구현하는 어떤 객체도 순회할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Public interface Iterable&lt;E&gt; &#123;</span><br><span class="line">// 이 Iterable 안에 있는 원소들에 대한 반복자 반환</span><br><span class="line">Iterator&lt;E&gt; iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>어떤 라이브러리가 있는지 파악하고, 적절히 활용하라</p><p>정확한 답이 필요하다면 float와 double은 피하라</p><p>BigDecimal, int, Long을 사용하라</p><h3>객체화된 기본 자료형 대신 기본 자료형을 이용하라</h3><p>가능하다면 기본 자료형을 사용하라, 기본자료형이 더 단순하고 빠르다.<br>자동 객체화는 번거로운 일을 줄여주긴 하지만 객체화된 기본 자료형을 사용할때 생길수 있는 문제들까지 없애주진 않는다.<br>객체화된 기본 자료형 객체 두개를 ==으로 비교한다는 것은 그두 객체의 신원을 비교한다는 것이다.<br>객체화딘 기본 자료형과 기본 자료형을 한 표현식 안에 뒤섞으면 비객체화가 자동으로 일어나며 그과정에서 NullPointerException이 발생할 수 있다.<br>기본 자료형 값을 객체화 하는 과정에서 불필요한 객체들이 만들어지면 프로그램 성능이 저하될수도 있다.</p><p>자바의 자료형 시스템은 크게 두 가지이다.</p><ul><li>Int, double, boolean 등 기본 자료형(primitive type)</li><li>String, List 등 참조 자료형(reference type)</li></ul><h3>자동 객체화와, 자동 비객체화, auto unboxing, auto boxing의 차이점을 명확히 하라</h3><p>기본 자료형과 객체화된 기본 자료형 사이에는 세 가지 큰 차이점이 있다.<br>기본 자료형은 값만 가지지만 객체화된 기본 자료형은 값 외에도 Identity를 가진다. 따라서 객체화된 기본 자료형 갹채가 두개 있을때, 그 값은 같더라도 identity가 다를수 있다.<br>기본 저료형에 저장되는 값은 전부 기능적으로 완전한 값이지만, 객체화된 기본 자료형에 저장되는 값에는 그 이외에도 아무 기능도 없는 값, 즉 NULL이 하나 있다.<br>기본 자료형은 시간이나 공간 요구량 측면에서 일반적으로 객체 표현형보다 효율적이다.</p><p>ps. ==연산자를 조심하라, 객체 끼리 비교에서는 객체가 같은지 신원을 비교한다.</p><p>ps2. 객체화된 기본 자료형에 == 연산자를 사용하는 것은 거의 항상 오류라고 봐야한다.</p><p>ps3. 객체화된 자료형은 자료형 내부의 값을 담을 지역 변수에 담아서 비교하고 연산하는게 가장 확실한 방법이다.</p><p>ps4. 기본 자료형과 객체화된 기본자료형을 한 연산안에 엮어 놓으면 갹채화된 기본자료향은 자동으로 기본 자료형으로 변환된다.</p><h3>다른 자료형이 적절하다면 문자열 사용은 피하라</h3><ul><li>문자열로 해서는 안되는 일</li><li>문자열은 값 자료형을 대신하기에는 부족하다.</li><li>데이터가 네트워크나 표준 입출력으로 들어올때 데이터의 자료형으로 맞춰 변환하라</li><li>문자열은 혼합 자료형(aggregate)을 대신하기에는 부족하다</li></ul><p>//문자열을 혼합 자료형으로 써먹은 부적절한 사례<br>String compoundKey = className + ‘#’ + i.next();</p><p>문자열 연결시 성능에 주의하라</p><h3>리플렉션 대신 인터페이스를 이용하라</h3><p>일반적인 프로그램은 프로그램 실행중에 리플렉션을 통해 객체를 이용하려 하면 안된다는 것이다<br>리플렉션을 아주 제한적으로만 ㅏ용하면 오버헤드는 피하면서도 리플렉션의 다양한 장점을 누릴수 있다<br>객체 생성ㅇㄴ 릴플렉션으ㅡ로 하고 객체 참조는 인터페이스나 상위 클래스를 통하면 된다</p><h3>네이티브 메서드는 신중하게 사용하라</h3><p>네이티브 메서드를 통해 성능을 개선하는 것은 추천하고 싶지 않다,<br>네이티브 코드에 있는 아주 작은 버그라도 시스템 전체를 훼손 시킬수 있다</p><h3>신중하게 최적화하라</h3><p>모든 ㅍ로그래머가 알아둬야 하는 최적화 관련 격언이 세 가지 있다.<br>맹목적인 어리석음을 비롯한 다른 어떤 이유보다도 효율성이라는 이름으로 저질러지는 죄악이 더 많다(효율성을 바드시 성취하는 것도 아니면서 말이다.)<br>작은 효율성에 대해서는 말하자면 97%정도ㅔ 대해서는 잊어버려라 섣부른 최적화는 모든 악의 근원이다.<br>최적화를 할 때는 아래의 규칙을 따르라</p><ul><li>규칙 1 : 하지마라</li><li>규칙 2: (전문가들만 따를 것) 아직은 하지 마라 - 완벽히 명료한 최적화 되지 않은 해답을 얻을 때까지는</li></ul><p>출처 : 조슈아 블로크, 『 Effective Java 2/E』, 이병준 옮김, 인사이트(2014.9.1), 10쪽 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;지역 변수의 유효범위를 최소화하라&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;처음으로 사용하는 곳 바로 위에 선언하라&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;거의 모든 지역 변수 선언에는 초기값이 포함되어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;while문 보
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="일반 원칙" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/%EC%9D%BC%EB%B0%98-%EC%9B%90%EC%B9%99/"/>
    
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/tags/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
  </entry>
  
  <entry>
    <title>규칙2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라</title>
    <link href="http://jungha-cho.github.io/2017/04/10/EffectiveJavaRule2/"/>
    <id>http://jungha-cho.github.io/2017/04/10/EffectiveJavaRule2/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:46:23.908Z</updated>
    
    <content type="html"><![CDATA[<h1>규칙2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라</h1><h3>생성자 인자가 많을때 프로그래머들은 보통 점층적 생성자 패턴 ( telescoping constructor pattern )을 적용한다.</h3><ul><li>필수 인자를 받는 생성자와 선택적 인자를 추가해 생성자를 더 추가하는 형식.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class constructor&#123;</span><br><span class="line">public constructor ( int i1, int i2 ) &#123; … &#125;</span><br><span class="line">public constructor ( int i1, int i2, string h1 ) &#123; … &#125;</span><br><span class="line">public constructor ( int i1, int i2, string h1, int i3 ) &#123; … &#125;</span><br><span class="line">public constructor ( int i1, int i2, string h1, int i3, double d1 ) &#123; … &#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 하다 보면, 설정할 필요가 없는 필드에도 인자를 전달해야 할 수도 있다.</p><ul><li>점층적 생성자 패턴은 잘 동작하지만 인자 수가 늘어나면 클라이언트 코드를 작성하기가 어려어지고, 무엇보다 읽기 어려운 코드가 되고 만다.</li><li>그 많은 인자가 무슨 값인지 알기 어렵게 되고 그 의미를 알려면 인자를 주의깊게 보아야한다.</li><li>클라이언트가 두 인자의 순서를 뒤집어도 컴파일러는 알지 못하고 프로그램 실행 도중 문제가 발생할 수도 있다.</li></ul><h3>생성자에 전달되는 인자 수가 많을 때 적용 가능한 두 번째 대안은 ( JavaBeans ) 패턴이다.</h3><ul><li>인자 없는 생성자를 호출하여 객체부터 만든다.</li><li>설정 메서드들을 호출하여 필수 필드 뿐만 아니라 선택적 필드의 값들 까지 채운다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class JavaBeansPattern &#123;</span><br><span class="line">private int beanSIze = -1;</span><br><span class="line">private int patternSize = 0;</span><br><span class="line"></span><br><span class="line">public JavaBeansPattern () &#123; &#125;</span><br><span class="line"></span><br><span class="line">public void setBeanSize( int val ) &#123; beanSize = val; &#125;</span><br><span class="line">public void setPatternSize( int val ) &#123; patternSize = val; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>점층적 생성자 패턴에 있던 문제는 없다.</li><li>코드의 양이 많아 질 수 있따.</li><li>객체를 생성하기 쉽다.</li><li>읽기도 좋다.</li></ul><h3>하지만, 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관성 ( Consistency )가 일시적으로 깨질 수 있다.</h3><ul><li>일관성이 꺠진 객체를 사용할 때 생기는 문제는 실제 버그 위치에서 한참 떨어진 곳에서 발생하므로 디버깅이 어렵다.</li></ul><h3>이와 관련된 또 다른 문제는, 자바빈 패턴으로는 변경 불가능 ( immutable ) 클래스를 만들 수 없다는 것이다.</h3><p>또 쓰레드 안전성 ( Thread-Safety ) 를 제공하기 위해 해야할 일도 더 많아진다.</p><h3>점층적 생성자 패턴의 안전성에 자바빈 패턴의 가독성을 결합한 세 번째 대안은 바로 빌더 패턴이다.</h3><ol><li>필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에 ( or 정적 팩터리 메서드에 ) 전달해 빌더 객체 ( builder object )를 만든다.</li><li>그런 다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다.</li><li>그리고 마지막으로 아무런 인자 없이 build 메서드를 호출하여 변경 불가능 ( immutable ) 객체를 만드는 것이다.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Public class BuilderPattern &#123;</span><br><span class="line">private final int gateWayPort;</span><br><span class="line">private final int gateWayIp;</span><br><span class="line">private final int waySize;</span><br><span class="line">private final int gateSize;</span><br><span class="line"></span><br><span class="line">public static class Builder &#123;</span><br><span class="line">// 필수 인자</span><br><span class="line">private final int gateWayPort</span><br><span class="line">private final int gateWayIp;</span><br><span class="line"></span><br><span class="line">// 기본값으로 초기화</span><br><span class="line">private int waySize = 0;</span><br><span class="line">private int gateSize = 0;</span><br><span class="line"></span><br><span class="line">public Builder(int gateWayPort, int gateWayIp) &#123;</span><br><span class="line">this.gateWayPort = gateWayPort;</span><br><span class="line">this.gateWayIp = gateWayIp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Builder waySize(int val)</span><br><span class="line">&#123; waySize = val; return this; &#125;</span><br><span class="line">public Builder gateSize(int val)</span><br><span class="line">&#123; gateSize = val; return this; &#125;</span><br><span class="line"></span><br><span class="line">public BuilderPattern build() &#123;</span><br><span class="line">return new BuilderPatern(this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private BuilderPattern(Builder builder) &#123;</span><br><span class="line">gateWayPort = builder.gateWayPort;</span><br><span class="line">gateWayIp = builder.gateWayIp;</span><br><span class="line">waySize = builder.waySize;</span><br><span class="line">gateSize = builder.gateSize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BuilderPattern 객체는 변경 불가능하다.</li><li>모든 인자의 기본값이 한곳에 모여있다.</li><li>빌더에  정의된 설정 메서드는 빌더 객체 자신을 반환하므로, 설정 메서드를 호출하는 코드는 쭉 이어서 쓸 수 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BuilderPattern bpObject = new BuilderPattern.Builder(22, 19216802).</span><br><span class="line">waySize(20).gateSize(50);</span><br></pre></td></tr></table></figure><h3>이 코드는 작성하기 쉽고 무엇보다 읽기 쉽다.</h3><h3>Ada나 Python 같은 언어는 선택적 인자에 이름을 붙일 수 있도록 허용하는데, 그것과 비슷한 코드를 작성할 수 있기 떄문이다.</h3><ul><li>생성자와 마찬가지로, 빌더 ㅍ턴을 사용하면 인자에 불변식 ( invariant )을 적용할 수 있다.</li><li>Build 메서드 안에서 해당 불변식이 위반되었는지 검사할 수 있는 것이다.</li><li>빌더 객체에서 실제 객체로 인자가 복사된 다음에 불변식들을 검사할 수 있다는 것.</li><li>그 불변식을 빌더 객체의 필드가 아니라 실제 객체의 필드를 두고 검사할 수 있다는 것은 중요하다.</li><li>불변식을 위반한 경우 build 메서드는 IllegalStateException을 던져야 한다.</li><li>이 예외 객체를 살펴보면 어떤 불변식을 위반했는지 알아낼 수도 있어야 한다.</li><li>여러 인장 관련된 불변식을 강제하는 또 한 가지 방법은 불변식이 적용될 값 전부를 인자로 받는 설정자 메서드(setter method)를 정의하는 것이다.</li><li>생성자와 비교했을떄 빌더 패턴이 갖는 또 한 가지 작은 장점은 빌더 객체는 여러 개의 varargs 인자를 받을 수 있다.</li><li>빌더 패턴은 유연하다.</li><li>하나의 빌더 객체로 여러 객체를 만들 수 있다.</li><li>다른 객체를 생성해야 할 때마다 빌더 객체의 설정 메서드를 호출하면 다음에 생성될 객체를 바꿀 수 있다.</li><li>빌더 객체는 어떤 필드의 값은 자동으로 채울수 있다. 객체가 만들어질떄 마다 자동적으로 증가되는 일련번호 같은 것은 좋은 예다.</li></ul><p>인자가 설정된 빌더는 훌륭한 추상 팩터리다. 다시 말해서 클라이언트는 그런 빌더를 어떤 메서드에 넘겨서 해당 메서드가 클라이언트에게 하나 이상의 객체를 만들어 주도록 할 수 있다.</p><ul><li>제네릭 자료형 하나면 어떤 자료형의 객체를 만드는 빌더냐에 관계없이 모든 빌더에 적용할 수 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 자료형이 T인 객체에 대한 빌더</span><br><span class="line">Public interface Builder&lt;T&gt; &#123;</span><br><span class="line">public T build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 인터페이스가 있다면 BuilderPattern.Builder 클래스는 Builder<builderpattern>를 implements 하도록 선언할 수 있다.<br>빌더 객체를 인자르 받는 메서드는 보통 한정적 와일드카드 자료형 ( bounded wildcard Type )을 통해 인자의 자료형을 제한한다.</builderpattern></p><p>// 클라이언트가 전달한 Builder 객체를 사용하여 트리의 노드를 만든다.<br>Tree builderTree(Builder&lt;? Extends Node&gt; nodeBuilder() { … }</p><h3>Class.newInstance는 컴파일 시점에 예외 검사가 가능해야 한다는 규칙을 깨뜨린다.</h3><p>빌더 패턴에도 단점은 있다. 객체를 생성하려면 우선 빌더 객체를 생성해야 한다.<br>실무에서 빌더 객체를 만드는 오버헤드가 문제가 될 소지는 없어 보이지만, 성능이 중요한 상황에선 그렇지 않을수도 있다.<br>또한, 빌더 패턴은 점층적 생성자 패턴보다 많은 코드를 요구하기 때문에 인자가 충분히 많은 상황( 네개 이상 )에서 이용해야 한다.<br>지금은 인자가 적더라도 나중에 새로운 인자를 추가해야 할 상황이 올 수도 있따.</p><p>우선은 생성자와 정적 팩터리로 시작 -&gt; 인자 개수가 통제할 수 없을 정도로 많아지면 빌더 패턴을 적용하자.<br>하지만, 처음부터 빌더 패턴을 적용하는 것이 나을떄도 있다.</p><h3>빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적 인자인 상황에 유용하다.</h3><p>출처 : 조슈아 블로크, 『 Effective Java 2/E』, 이병준 옮김, 인사이트(2014.9.1), 규칙2 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;규칙2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라&lt;/h1&gt;
&lt;h3&gt;생성자 인자가 많을때 프로그래머들은 보통 점층적 생성자 패턴 ( telescoping constructor pattern )을 적용한다.&lt;/h3&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Builder" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/Builder/"/>
    
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/tags/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Builder" scheme="http://jungha-cho.github.io/tags/Builder/"/>
    
  </entry>
  
  <entry>
    <title>규칙3 private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라</title>
    <link href="http://jungha-cho.github.io/2017/04/10/EffectiveJavaRule3/"/>
    <id>http://jungha-cho.github.io/2017/04/10/EffectiveJavaRule3/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:46:28.700Z</updated>
    
    <content type="html"><![CDATA[<h3>규칙3 private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라</h3><h3>기존의 싱글턴 패턴 생성 방법 2가지</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// public final 필드를 이용한 싱글턴</span><br><span class="line">Public class Elvis &#123;</span><br><span class="line">public static final Elvis INSTANCE = new Elvis();</span><br><span class="line">private Elvis()&#123; … &#125;</span><br><span class="line"></span><br><span class="line">public void leaveTheBuilding() &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 정적 팩터리를 이용한 싱글턴</span><br><span class="line">Public class Elvis &#123;</span><br><span class="line">private static final Elvis INSTANCE = new Elvis();</span><br><span class="line">private Elvis() &#123; … &#125;</span><br><span class="line">public static Elvis getInstance() &#123; return INSTANCE; &#125;</span><br><span class="line"></span><br><span class="line">public void leaveTheBuilding() &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 두가지 방법은 AccessibleObject, setAccessible 메서드의 도움을 받아 권한을 획득한 클라이언트는 리플렉션 기능을 통해 private 생성자를 호출할 수 있따.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// enum 싱글턴 - 더 낫다.</span><br><span class="line">Public enum Elvis &#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"></span><br><span class="line">public void leaveTheBuilding() &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>좀더 간결하다.</li><li>직렬화가 자동으로 처리된다.</li><li>직렬화가 아무리 복잡하게 이루어져도 여러 객체가 생길 일이 없으며, 리플랙션을 통한 공격에도 안전하다.</li></ul><p>널리 사용되는 접근법은 아니지만, 원소가 하나뿐인 enum 자료형이야 말ㄹ 싱글턴을 구현하는 가장 좋은 방법이다.</p><p>출처 : 조슈아 블로크, 『 Effective Java 2/E』, 이병준 옮김, 인사이트(2014.9.1), 규칙3 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;규칙3 private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라&lt;/h3&gt;
&lt;h3&gt;기존의 싱글턴 패턴 생성 방법 2가지&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Singleton" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/Singleton/"/>
    
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/tags/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Singleton" scheme="http://jungha-cho.github.io/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라</title>
    <link href="http://jungha-cho.github.io/2017/04/10/EffectiveJavaRule1/"/>
    <id>http://jungha-cho.github.io/2017/04/10/EffectiveJavaRule1/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:46:19.564Z</updated>
    
    <content type="html"><![CDATA[<h1>규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라</h1><h3>객체의 생성과 삭제</h3><ul><li>객체를 만들어야 하는 시점과 그 방법</li><li>객체 생성을 피해야 하는 경우와 그 방법</li><li>적절한 순간에 객체가 삭제되도록 보장하는 방법</li><li>삭제 전에 반드시 이루어져야 하는 청소 작업들을 관리하는 방법</li></ul><h1>규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라</h1><ul><li>기본 ( primitive ) 타입의 b를 객체형 Boolean으로 반환한다.</li><li>참조 ( reference ) 로 반환한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Public static Boolean valueOf ( boolean b ) &#123;</span><br><span class="line">return b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>즉, Public 생성자 대신 객체 생성이 가능한 방법이 하나 더 있다.<br>또한, public으로 선언된 생성자 대신에 정적 팩터리 메서드를 제공하는 방법의 장단점은 다음과 같다.</p><h3>첫 번째, 생성자와는 달리 정적 팩터리 메서드에는 이름 ( name )이 있다.</h3><ul><li>생성자에 전달되는 인자들은 어떤 객체가 생성되는지를 설명하지 못한다.</li><li>정적 팩터리 메서드는 이름을 잘 짓기만 한다면 사용하기도 쉽다.</li><li>클라이언트 코드의 가독성 ( readability )도 높아진다.</li></ul><p>예를 들어 소수 ( prime )일 가능성이 높은 BigInteger 객체를 생성하는 생성자<br>BigInteger(int, int, Random)는 BigInteger.probablePrime과 같은 이름의 정적 팩터리 메서드로<br>표현 했으면 더 이해하기 쉬웠을 것이다.</p><p>또한, 클래스에는 시그니처 ( signature ) 별로 하나의 생성자만 넣을 수 있다. 이 제약을 피하는 한 가지 방법은 인자의 순서를 바꾸는 것이다.<br>하지만, 이 방법은 정말로 끔찍하다. API 사용자는 각각의 생성자 용도를 절대로 기억하지 못할 것이다. 또 결국 실수로 엉뚱한 생성자를 호출하게 될 것이다.<br>반면 정적 팩터리 메서드에는 이름이 있으므로 그런 문제는 생기지 않는다.</p><h3>두 번째, 정적 팩터리 메서드는 생성자와는 달리 호출할 떄마다 새로운 객체를 생성할 필요는 없다는 것이다.</h3><ul><li>미리 만들어 둔 객체의 재활용</li><li>미리 만들어 둔 객체를 캐시해 놓고 재사용</li></ul><p>앞서 살펴본 Boolean.valueOf(Boolean) 메서드가 이 기법을 활용한 좋은 사례다.<br>결코, 객체를 생성하지 않는 것이다. 이 기법은 경량 ( Flyweight ) 패턴과 유사한 사례다.<br>동일한 객체가 요청되는 일이 잦고, 특히 객체를 만드는 비용이 클 떄 적용하면 성능을 크게 개선할 수 있다.</p><p>정적 팩터리 메서드를 사용하면 같은 객체를 반복해서 반환할 수 있으므로 어떤 시점에서 어떤 객체가 얼마나 존재할지를<br>정밀하게 제어할 수 있다. 그런 기능을 갖춘 클래스는 개체 통제 클래스 ( Instance-Controlled Class )라고 부른다.</p><h3>개체 통제 클래스를 작성하는 이유</h3><ul><li>개체 수를 제어하면 싱글톤 ( Singleton ) 패턴을 따르도록 할 수 있다.</li><li>객체 생성이 불가능한 클래스를 만들 수 있다.</li><li>변경이 불가능한 클래스의 경우 두 개의 같은 객체가 존재하지 못하도록 할 수도 있다. ( a == b 일 때만 a.equals(b)가 참이 되도록 할 수 있다. )</li><li>이렇게 구현된 클래스는 == 연산자를 이용해 비교할 수 있으므로 성능이 향상된다. ( 열거(Enum) 자료형이 이 기법을 사용한다. )</li></ul><h3>세 번째, 정적 팩터리 메서드는 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다는 것이다.</h3><ul><li>반횐되는 객체의 클래스를 훨씬 유연하게 결정할 수 있다.</li><li>이 유연성을 활용해 Public으로 선언되지 않은 클래스의 객체를 반환하는 API를 만들 수 있다. ( 구현 세부사항을 감출 수 있다. )</li><li>이 기법은 인터페이스 기반 프레임워크 ( Interface-based Framework ) 구현에 적합하다.</li></ul><h3>Public 정적 팩터리 메서드가 반환하는 객체의 클래스가 Publicd일 필요가 없다.</h3><ul><li><p>메서드에 주어지는 인자를 이용하면 어떤 클래스의 객체를 만들지도 동적으로 결정할 수 있다.</p></li><li><p>반환될 객체의 클래스가 정적 팩터리 메서드의 반환값 자료형에 부합하기만 하면 된다.</p></li><li><p>릴리스 되는 소프트웨어의 버전에 따라서 반환될 객체의 클래스 구현을 달리할 수 있으므로 소프트웨어를 유지보수하거나 성능을 개선하기도 좋다.</p></li><li><p>JDK 1.5에 도입된 java.util.EnumSet에는 public으로 선언된 생성자가 없고 정적 팩터리 메서드뿐이다.</p></li><li><p>이 메서드들은 Enum 상수 개수에 따라 두 개 구현체 가운데 하나를 골라 해당 클래스의 객체를 만들어 반환 한다.</p></li><li><p>Enum 상수들이 64개 이하일 경우 RegularEnumSet을 반환하는데 내부적으로 long형 변수 하나만 사용한다.</p></li><li><p>64개 이상일 경우 JumboEnumSet을 반환하는데 이 객체는 내부적으로 long형 배열을 사용한다.</p></li></ul><p>정적 팩터리 메서드만 있는 클래스를 만들면 생기는 가장 큰 문제는, public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것이다.<br>두 번째 단점은 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다는 것이다.</p><p>valueOf, of, getInstance, newInstance, getType, newType</p><p>출처 : 조슈아 블로크, 『 Effective Java 2/E』, 이병준 옮김, 인사이트(2014.9.1), 2장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라&lt;/h1&gt;
&lt;h3&gt;객체의 생성과 삭제&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;객체를 만들어야 하는 시점과 그 방법&lt;/li&gt;
&lt;li&gt;객체 생성을 피해야 하는 경우와 그 방법&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Factory" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/Factory/"/>
    
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/tags/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Factory" scheme="http://jungha-cho.github.io/tags/Factory/"/>
    
  </entry>
  
  <entry>
    <title>규칙4 객체 생성을 막을 때는 private 생성자를 사용하라</title>
    <link href="http://jungha-cho.github.io/2017/04/10/EffectiveJavaRule4/"/>
    <id>http://jungha-cho.github.io/2017/04/10/EffectiveJavaRule4/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:46:32.596Z</updated>
    
    <content type="html"><![CDATA[<h3>규칙4 객체 생성을 막을 때는 private 생성자를 사용하라</h3><ul><li>객체를 만들 수 없도록 하려고 클래스를 abstract로 선어내 봤자 소용없다.</li><li>Private 생성자를 클래스에 넣어서 객체 생성을 방지하자는 것이다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 객체를 만들 수 없는 클래스</span><br><span class="line">Public class CjhClass &#123;</span><br><span class="line">// 디폴트 생성자가 자동 생성되지 못하도록 해서 객체 생성을 방지한다</span><br><span class="line">private CjhClass() &#123;</span><br><span class="line">throw new AccertionError();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>생성자가 private임으로 외부에서는 사용할 수 없다.</li><li>AssertionError는 반드시 필요한 것은 아니지만 내부에서 실수로 사용할때 바로 알수 있게 하기 위해서다.</li><li>이렇게 하면 하위 클래스도 만들 수 없다. 모든 생성자는 상위 클래스위 생성자를 명시적으로든 묵시적으로든 호출할 수 있어야 하는데, 호출 가능한 생성자가 상위 클래스에 없기 떄문이다.</li></ul><p>출처 : 조슈아 블로크, 『 Effective Java 2/E』, 이병준 옮김, 인사이트(2014.9.1), 규칙4 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;규칙4 객체 생성을 막을 때는 private 생성자를 사용하라&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;객체를 만들 수 없도록 하려고 클래스를 abstract로 선어내 봤자 소용없다.&lt;/li&gt;
&lt;li&gt;Private 생성자를 클래스에 넣어서 객체 생성을 방지하자
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="new" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/new/"/>
    
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/tags/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="new" scheme="http://jungha-cho.github.io/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency in Practice, 개요</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaConcurrencyinPracticeIntroduce/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaConcurrencyinPracticeIntroduce/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:41:50.706Z</updated>
    
    <content type="html"><![CDATA[<h1>01. 개요</h1><p>한 종류의 일을 순차적으로 처리하는 프로그램은 작성하기 쉽고 오류도 별로 생기지 않는다.<br>또 여러 종류 일을 순차적으로 처리하는 프로그램 보다 테스트하기도 쉽다.<br>종류별 작업마다 또는 시뮬레이션 작업의 각 요소마다 스레드를 하나씩 할당하면 마치 순차적인 작업처럼 처리할 수 있고,<br>스케줄링, 교차 실행되는 작업, 비동기 I/O, 자원 대기 등의 세부적인 부분과 상위의 비즈니스 로직에 해당하는 부분을 분리할 수 있다.<br>다시 말해 복잡하면서 비동기적인 작업 흐름을 각기 별도 스레드에서 수행되는 더 단순하고 동기적인 작업 흐름 몇 개로 나눌 수 있다.<br>이런 작업 흐름에서는 특정한 동기화 시점에서만 상호 작용이 발생한다.</p><p>이러한 장점은 서블릿이나 RMI ( Remote Method Invocation )와 같은 프레임웍에서 종종 활용된다.<br>프레임웍은 요청 관리, 스레드 생성, 로드 밸런싱, 그리고 작업 흐름 내에서 적절한 시점에 적절한 애플리케이션 컴포넌트에게 요청을 분배하는 등 상세한 부분을 처리한다.</p><h3>1.2.3 단순한 비동기 이벤트 처리</h3><p>여러 클라이언트 프로그램에서 소켓 연결을 받는 서버 애플리케이션의 경우 각 연결 마다 스레드를 할당하고 동기 I/O를 사용하도록 하면 개발 작업이 쉬워진다.<br>읽을 데이터가 없을 때 소켓에서 읽으려고 하면 애플리케이션은 추가 데이터가 들어올때까지 read 연산에서 대기한다.</p><p>지금까지의 운영체제는 하나의 프로세스가 생성할 수 있는 스레드 개수에 상대적으로 제약이 심해 최대 수백 개 정도만을 생성할 수 있다.<br>그러다보니 운영체제에서는 유닉스 시스템의 select나 poll 시스템 콜 처럼 효율적인 다중화 I/O 수단을 개발했고, 표준 자바 API에도 대기 상태에 들어가지 않는 I/O를 지원할 수 있도록 Java.nio 같은 패키지가 추가됐다.</p><h3>1.2.4 더 빨리 반응하는 사용자 인터페이스</h3><p>GUI 애플리케이션은 보통 스레드 하나로 동작했다. 메인 이벤트 루프에서 직좁 호출한 코드가 너무 오래 동안 실행되면 다음 이벤트를 처리할 수 없어 사용자 인터페이스가 멈춘 것처럼 보이기도 한다. ( freeze )<br>AWT나 스윙과 같은 GUI 프레임웍은 메인 이벤트 루프를 이벤트 전달 스레드로 전달했다.</p><h3>1.3.1 안전성 위해 요소</h3><p>스레드 안정성은 생각보다 미묘하기도 하다. 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 순서가 때론 놀라울 만큼 예측하기가 어렵다.</p><h3>1.4 스레드는 어디에나</h3><p>모든 자바 프로그램은 기본적으로 스레드를 사용한다. JVM을 시작시키면 main 메소드를 실행할 주 스레드 뿐 아니라 가비지 컬렉션이나 객체 종료와 같은 JVM 내부 작업을 담당할 스레드도 생성한다. AWT와 스윙 사용자 인터페이스 프레임웍은 사용자 인터페이스의 이벤트를 관리할 스레드를 생성하며 timer는 대기중인 작업을 실행할 스레드를 생성한다.</p><p>이처럼 프레임웍은 프로그램 컴포넌트를 호출할 떄 프레임웍 내부의 스레드에서 호출하기 떄문에 자동으로 프로그램이 스레드를 활용하는 것과 동일한 효과를 준다. 컴포넌트는 언제나 프로그램 내부의 상태에 접근하기 떄문에 해당 상태에 접근하는 모든 코드 경로에 해당하는 컴포넌트 역시 스레드에 안전해야 한다.</p><p>타이머 : Timer를 사용하면 TimerTask에 지정된 작업이 프로그램이 아닌 Timer가 관리하는 스레드에서 실행되기 때문에 순차적인 프로그램을 복잡하게 만들수도 있다. 만약 기본 프로그램의 스레드가 사용하는 데이터에 timerTask의 작업이 접근하면 timertask 뿐 아니라 해당 데이터에 접근하는 다른 모든 클래스도 스레드에 안전하게 만들어야 한다. 이런 경우 가장 쉬운 방법은 TimerTask가 접근하는 객체 자체를 스레드에 안전하게 만드는 것이다. 즉 공유된 데이터 객체 내부에 스레드 안전성을 캡슐화 하는것이다.</p><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 1장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;01. 개요&lt;/h1&gt;
&lt;p&gt;한 종류의 일을 순차적으로 처리하는 프로그램은 작성하기 쉽고 오류도 별로 생기지 않는다.&lt;br&gt;
또 여러 종류 일을 순차적으로 처리하는 프로그램 보다 테스트하기도 쉽다.&lt;br&gt;
종류별 작업마다 또는 시뮬레이션 작업의 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>규칙5 불필요한 객체는 만들지 말라</title>
    <link href="http://jungha-cho.github.io/2017/04/10/EffectiveJavaRule5/"/>
    <id>http://jungha-cho.github.io/2017/04/10/EffectiveJavaRule5/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:46:37.172Z</updated>
    
    <content type="html"><![CDATA[<h3>규칙5 불필요한 객체는 만들지 말라</h3><ul><li>기능적으로 동일한 객체는 필요할 떄마다 만드는 것보다 재사용하는 편이 낫다.</li><li>객체를 재사용하는 프로그램은 더 빠르고 더 우아하다.</li><li>변경 불가능 ( immutable ) 객체는 언제나 재사용할 수 있다</li></ul><p>절대로 피해야 할 극단적인 예</p><p>String s = new String(“CjhProject”);     // No!!</p><p>위 문장은 실행될 떄마다 String 객체를 만드는데 “CjhProject” 그 자체로도 String 객체다.</p><p>String s = “CjhProject”;     // 이게 더 낫다.</p><p>생성자와 정적 팩터리 메서드를 함꼐 제공하는 변경 불가능 클래스의 경우 생성자 대신 정적 팩터리 메서드를 이용하면 불필요한 객체 생성을 피할 수 있을떄가 많다.<br>예를 들어, Boolean(String) 보다는 Boolean.valueOf(String) 쪽이 대체로 바람직하다.<br>생성자는 호출할 떄마다 새 객체를 만들지만, 정적 팩터리 메서드는 그럴 필요도 없고 실제로 그러지도 않을 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Public class Person &#123;</span><br><span class="line">private final Date birthDate;</span><br><span class="line"></span><br><span class="line">// 이렇게 하면 안 된다!</span><br><span class="line">public boolean isBabyBoomer() &#123;</span><br><span class="line">// 생성 비용이 높은 객체를 쓸데없이 생성한다.</span><br><span class="line">Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(“GMT”));</span><br><span class="line">gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">Date BoomStart = gmsCal.getTime();</span><br><span class="line">gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">Date boomEnd = gmtCal.getTime();</span><br><span class="line">return birthDate.compareTo(boomStart) &gt;= 0 &amp;&amp;</span><br><span class="line">birthDate.compareTo(boomEnd) &lt; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Public class Person &#123;</span><br><span class="line">private final Date birthDate;</span><br><span class="line">// 다른 필드와 메서드, 생성자는 생략</span><br><span class="line"></span><br><span class="line">/** 베이비 붐 시대의 시작과 끝 **/</span><br><span class="line">private static final Date BOOM_START;</span><br><span class="line">private static final Date BOOM_END;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(“GMT”));</span><br><span class="line">gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">BOOM_START = gmtCal.getTime();</span><br><span class="line">gmtCal_set(1965, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">BOOM_END = gmtCal.getTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isBabyBoomer() &#123;</span><br><span class="line">return birthDate.compareTo(BOOM_START) &gt;= 0 &amp;&amp;</span><br><span class="line">   birthDate.compareTo(BOOM_END) &lt; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>이렇게 개선된 Person 클래스는 Calendar, TimeZone 그리고 Date객체를 클래스가 초기화 될 때 한 번만 만든다.</h3><ul><li>만일 개선된 Person 클래스가 초기화 된 다음에 한번도 호출되지 않는다면, BOOM_START, BOOM_END는 쓸데없이 초기화 된것이다.</li><li>이는 초기화 지연 ( lazy initialization ) 기법을 사용하면 피할 수 있다.</li><li>하지만 초기화 지연 기법은 구현이 복잡해지고 성능 개선도 어렵다.</li></ul><h3>JDK 1.5부터는 쓸데없이 객체를 만들 새로운 방법이 더 생겼다. 자동 객체화 ( Autoboxing )이다.</h3><ul><li>프로그래머들이 자바의 기본 자료형과 그 객체 표현형을 섞어 사용할 수 있도록 해 준다.</li><li>이 둘간의 변환은 자동으로 이루어 진다.</li><li>오토박싱 덕분에 기본 자료형과 그 객체 표현형 사이의 차이가 희미해지긴 했지만, 아주 없어진것은 아니다. 의미적인(semantic) 차이는 미미하지만, 성능 차이는 무시하기 어렵다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 무시무시할 정도로 느린 프로그램, 어디서 객체가 생성되는지 살펴보자</span><br><span class="line">Public static void main(String[] args) &#123;</span><br><span class="line">Long sum = 0L;</span><br><span class="line">for ( long i = 0; i &lt; Integer.MAX_VALUE; I++) &#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sum이 long이 아니라 Long으로 쓰여진 덕분에 쓸데없는 객체가 2의 31승 만큼 만들어진다.</li></ul><h3>객체 표현형 대신 기본 자료형을 사용하고, 생각지도 못한 자동 객체화가 발생하지 않도록 유의하라</h3><ul><li><p>객체를 만들어서 코드의 명확성과 단순성을 높이고 프로그램의 능력을 향상시킬 수 있다면, 일반적으로는 만드는 것이 좋다.</p></li><li><p>마찬가지로, 직접 관리하는 객체 풀(object pool)을 만들어 객체 생성을 피하는 기법은 객체 생성 비용이 극단적으로 높ㅈ 않다면 사용하지 않는것이 좋다.</p></li><li><p>객체 풀을 만드는 비용이 정당화 될 만한 객체의 예로 가장 고전적인 것은 데이터베이스 연결이다.</p></li><li><p>데이터베이스에 접속하는 비용이 충분히 높으므로 이런 객체들은 재사용하는것이 이치에 맞다.</p></li><li><p>또한 데이터베이스의 라이센스 정책에 따라서 데이터베이스와 맺는 연결의 수가 제한될 수도 있다.</p></li></ul><p>출처 : 조슈아 블로크, 『 Effective Java 2/E』, 이병준 옮김, 인사이트(2014.9.1), 규칙5 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;규칙5 불필요한 객체는 만들지 말라&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기능적으로 동일한 객체는 필요할 떄마다 만드는 것보다 재사용하는 편이 낫다.&lt;/li&gt;
&lt;li&gt;객체를 재사용하는 프로그램은 더 빠르고 더 우아하다.&lt;/li&gt;
&lt;li&gt;변경 불가능 ( im
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Instance" scheme="http://jungha-cho.github.io/categories/Book/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/Instance/"/>
    
    
      <category term="이펙티브자바" scheme="http://jungha-cho.github.io/tags/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"/>
    
      <category term="Instance" scheme="http://jungha-cho.github.io/tags/Instance/"/>
    
  </entry>
  
  <entry>
    <title>바이트 단위 IO 클래스</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOByteStream/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOByteStream/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:46:58.140Z</updated>
    
    <content type="html"><![CDATA[<h3>바이트 단위 IO 클래스</h3><p>바이트 단위 IO 클래스는 가장 기본이 되는 IO 클래스이다. 컴퓨터에 존재하는 모든 데이터는 바이트 단위로 구성되어 있기 때문이다. 바이트 스트림 클래스는 모두 추상 클래스인 InputStream과 OutputStream의 자식 클래스다. 이는 입력과 관련된 모든 바이트 스트림은 InputStream에 있는 메소드를 포함하며 출력과 관련된 모든 바이트 스트림은 OutputStream에 있는 메소드를 포함한다는 의미이다.</p><p>inputstream outputstream에 대한 이미지 검색결과 InputStream과 OutputStream은 Object를 상속한다.</p><h3>1. InputStream과 OutputStream</h3><p>바이트 관련 Input과 Output의 최상위 클래스인 InputStream과 OutputStream을 모른다면 나머지 바이트 스트림 관련 클래스도 모른다는 의미이다. 그러므로 이 두개의 클래스를 이해해야 이를 상속받는 하위 클래스도 이해할 수 있다.</p><h3>InputStream과 OutputStream은 앞서 추상클래스라고 했다. 이는 InputStream과 OutputStream은 new 연산자를 이용해서 객체화시킬 수 없다는 것을 의미한다.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = new InputStream();</span><br></pre></td></tr></table></figure><p>따라서 InputStream 클래스는 다음과 같은 형태로만 사용할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = new InputStream 클래스를 상속받은 클래스의 생성자();</span><br></pre></td></tr></table></figure><p>System.in을 이용해서 키보드로 부터 입력받기</p><p>System.in은 InputStream의 형식이다. 이는 InputStream에 있는 모든 메소드를 사용할수 있다는 의미다.<br>또한 System.in은 표준 입력을 받는다. 하지만 키보드에서 문자를 누른다고 해서 곧장 read() 메소드를 통해 읽어들이는 것은 아니다.</p><p>키보드를 눌렀을 경우 눌려진 값은 운영체제가 관리하는 키보드 버퍼에 쌓이고 JVM에게는 값이 전달되지 않기 때문이다. JVM에게 값을 전달하려면 키보드의 엔터키를 입력해야 한다. 엔터키를 입력하게 되면 키보드 버퍼에 있던 값과 엔터 키 값이 한꺼번에 JVM에게 전달되는 것이다.</p><p>이렇게 전달된 문자열은 read() 메소드를 통해 차례대로 한 바이트씩 읽어 들일 수 있다.</p><h3>2. FileInputStream과 FileOutputStream</h3><p>FileInputStream과 FileOutputStream은 각각 InputStream과 OutputStream을 상속받으며, 파일로부터 바이트 단위로 입력받고, 대상 파일에 바이트 단위로 출력할 수 있는 클래스다.</p><p>이 두개의 클래스의 생성자는 파일명이나 파일 정보가 있는 File 클래스에 대한 객체를 전달받는다. 그리고 FileInputStream의 경우 생성자에 전달한 파일명이 실제로 존재하지 않는 파일명이면 java.io.FileNotFoundException을 발생시킨다.</p><p><a href="http://System.in" target="_blank" rel="noopener">System.in</a>, System.out, System.err의 세가지 스트림을 제외하고, 앞으로 IO 클래스를 사용할 때는 다음 내용을 반드시 지켜야 한다.</p><ul><li>try문에서 사용할 IO 클래스를 선언한다. 보통 null 값을 할당한다.</li><li>try 블록 안에서 IO 클래스의 객체를 생성한다.</li><li>finally 블록 안에서 IO 클래스의 close() 메소드를 호출한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class FileInputStream &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        if(args.length != 1)&#123;</span><br><span class="line">            System.out.println(&quot;use :java fileview file name&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            fis = new FileInputStream(args[0]);</span><br><span class="line">            int i = 0;</span><br><span class="line">            while((i = fis.read()) != -1)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">                System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;catch(IOException e)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>파일을 읽어 출력하는 프로그램의 개선 문제</p><p>평범한 파일 입출력 프로그램의 대부분은 효율이 떨어진다. 이 문제를 개선하기 위해서는 운영체제에 대한 기본 지식이 필요하다.<br>우리가 사용하는 운영체제는 하드웨어를 제어하는 기능이 있다. 자바에서 파일을 읽어들이라고 명령을 내리면, 내부적으로는 운영체제에게 부탁해서 물리적 장치인 하드디스크로부터 읽어오게 되는 것이다. 그런데 이 읽어오는 부분에서 몇 가지 중요한 점을 고려해야 한다.</p><ul><li>자바 프로그래밍으로 1byte를 읽어오라고 실행하면, 운영체제는 실제로 1byte를 읽지 않고 보통 인접한 256byte나 512byte를 읽게 된다. 이는 1000byte 파일을 1바이트씩 읽어오라고 실행하면, 내부적으로는 512byte씩 1000번 읽어온다는 것을 의미한다.</li><li>이런 문제를 해결하려면 1byte씩 읽어 들이는 것이 아니라, 운영체제가 실제로 읽어 들이는 단위로 읽어 들여야 한다.</li><li>즉 1000바이트 파일이라면 2번만 디스크를 읽어 들이면 되기 때문에 상당히 효율적으로 프로그램이 동작하게 되는것이다.</li><li>이 특징은 작은 크기의 파일을 읽어 들일때는 차이를 느낄 수가 없으며 파일의 크기가 커질수록 효과를 실감하게 된다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class ImprovedFileInputStream</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        if(args.length != 1)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Use : Java File Name&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            fis = new FileInputStream(args[0]);</span><br><span class="line">            int readCount = 0;</span><br><span class="line">            byte[] buffer = new byte[512];</span><br><span class="line">            while( ( readCount = fis.read(buffer) ) != -1)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.write(buffer, 0, readCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException ex)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            catch(IOException e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드의 핵심은 이부분 이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int readCount = 0;</span><br><span class="line">byte[] buffer = new byte[512];</span><br><span class="line">while( ( readCount = fis.read(buffer) ) != -1)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.write(buffer, 0, readCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>512byte의 배열을 전달함으로써 파일으로부터 읽어 들인 내뇽이 바이트 배열인 buffer에 저장된다. 저장된 바이트 배열은 write() 메소드로 화면에 출력되게 된다.</p><h3>3. DataInputStream과 DataOutputStream</h3><p>DataInputStream과 DataOutputStream은 자바의 primitive type 데이터인 int, float, double, boolean, short, byte 등의 정보를 입력하고 출력하는데 알맞은 클래스이다.</p><p>DataInputStream은 생성자에서 InputStream을 받아들이며, DataOutputStream은 생성자에서 OutputStream을 받아들인다.<br><code>거듭 강조하지만 InputStream을 인자로 받아들인다는 것은 InputStream의 자식이나 자손 클래스를 받아들인다는 것이다.</code></p><p>귀찮아서 DataOutputStream은 생략한다. DataInputStream과 구성은 비슷하나 출력 메소드가 주를 이룬다.</p><p>DataInputStream과 DataOutputStream을 이용한 파일의 저장과 읽기</p><p>둘다 인자가 없는 생성자, 기본 생성자가 없다. InputStream, OutputStream을 인자로 받는 생성자만 있다. 따라서 Input과 Output은 파일을 읽어들이고 출력하는 객체를 인자로 전달해야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class DataOutputStreamTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FileOutputStream fos = null;</span><br><span class="line">        DataOutputStream dos = null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            fos = new FileOutputStream(&quot;data.bin&quot;);</span><br><span class="line">            dos = new DataOutputStream(fos);</span><br><span class="line">            dos.writeBoolean(true);</span><br><span class="line">            dos.wirteByte((byte)5);</span><br><span class="line">            dos.wirteInt(100);</span><br><span class="line">            dos.wirteDouble(200.5);</span><br><span class="line">            dos.wirteUTF(&quot;Hello World&quot;);</span><br><span class="line">            System.out.println(&quot;Saved&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;catch(IOException e)&#123;&#125;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                dos.close();</span><br><span class="line">            &#125;catch(IOException e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayInputStream과 ByteArrayOutputStream</span><br></pre></td></tr></table></figure><p>이 두 클래스는 말 그대로 바이트 배열을 차례대로 읽어 들이기 위한 클래스다. ByteArrayOutputStream은 내부적으로 저장 공간이 있어서 ByteArrayOutputStream에 있는 메소드를 이용해서 출력하게 되면 출력되는 모든 내용들이 내부적인 저장 공간에 쌓이게 된다. 그 후에 ByteArrayOutputStream에 있는 toByteArray()를 실행하면 저장된 모든 내용이 바이트 배열로 반환된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fis = new FileInputStream(args[0]);</span><br><span class="line">baos = new ByteArrayOutputStream();</span><br><span class="line">byte[] buffer = new byte[512];</span><br><span class="line">int readCount = 0;</span><br><span class="line">// 파일로부터 읽어 들인 바이트 배열을 ByteArrayOutputStream에 쓴다.</span><br><span class="line">while( (readCount = fis.read(buffer)) != -1 )</span><br><span class="line">&#123;</span><br><span class="line">    baos.write(buffer, 0, readCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>파일이나 배열의 내용을 읽어 들여 출력하는 클래스 작성</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void print (InputStream in)</span><br><span class="line">&#123;</span><br><span class="line">    byte[] buffer = new byte[512];</span><br><span class="line">    int readCount = 0;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        while( (eadCount = in.read(buffer)) != -1 )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.write(buffer, 0, readCount);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static한 print() 메소드는 InputStream을 인자로 받아들인다. 이는 InputStream의 자식 클래스나 자손 클래스의 객체를 모두 받아들일 수 있다는 것을 의미한다. 즉, FileInputStream이나 ByteArrayInputStream 등의 객체에 대한 참조를 전달받을 수 있는 것이다. 전달받은 후에는 InputStream에 있는 read() 메소드를 이용해서 읽어 들인 후, 표준 출력 장치로 출력하고 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(args[0].equals(&quot;file&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    FileInputStream fis = null;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        fis = new FileInputStream(&quot;file.dat&quot;);</span><br><span class="line">        //Static 메소드 print () 호출</span><br><span class="line">        print(fis);</span><br><span class="line">    &#125;</span><br><span class="line">    catch(Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 4장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;바이트 단위 IO 클래스&lt;/h3&gt;
&lt;p&gt;바이트 단위 IO 클래스는 가장 기본이 되는 IO 클래스이다. 컴퓨터에 존재하는 모든 데이터는 바이트 단위로 구성되어 있기 때문이다. 바이트 스트림 클래스는 모두 추상 클래스인 InputStream과 Ou
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Byte" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Byte/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="Byte" scheme="http://jungha-cho.github.io/tags/Byte/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency in Practice, Thread</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaConcurrencyinPracticeThread/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaConcurrencyinPracticeThread/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:46:54.709Z</updated>
    
    <content type="html"><![CDATA[<h1>02. 스레드</h1><p>자바 언어가 스레드를 강력하게 지원하게 된 이유 중 하나는 자바가 실행되는 기반인 JVM 자체가 하나의 프로세스기 때문이다?<br>IDE 백그라운드에서 입력 내용에 대한 오류를 검사하면서 바로바로 바로잡아 준다.<br>한글과 같은 문서 프로그램 또한 문법 검사를 백그라운드에서 진행하며 자동 저장 또한 지원한다.<br>즉, 스레드는 동시에 실행될 수 있는 또 다른 실행흐름을 갖게 한다.</p><p>쓰레드 사용의 두가지 방법</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread 상속을 통한 구현 방법 ( White Box )</span><br><span class="line">Runnable 구현을 통한 구현 방법 ( Black Box )</span><br></pre></td></tr></table></figure><p>GoF의 디자인 패턴에서는 객체 구현이 클래스 상속보다 더 나은 방법이다. 라고 정의한다.<br>디자인 패턴에서는 상속을 통한 재사용을 ( White-Box reuse )라고 하고 구현을 통한 재사용을 ( Black-Box reuse )라고 한다.<br>왜 상속 보다는 구현을 통한 재사용이 더 나은 선택인가?</p><p>상속 - 어떤 객체를 상속하면 private으로 선언되지 않는 모든 변수와 메소드, 생성자가 하위 클래스에 노출된다.<br> 하위 클래스에서 수퍼 클래스의 내부가 보인다는 의미로 디자인 패턴에서는 상속을 통한 재사용을 White-Box Reuse라고 한다. 반면 상속의 장점은 오버라이딩을 통해 수퍼클래스의 구현을 손쉽게 재정의할 수 있다는 것이다. 그럼에도 불구하고 상속을 이용해서 재사용할 때 무엇이 문제이길래?</p><p>이에 세가지 이유가 있다.</p><ul><li><strong>첫째,</strong> 수퍼클래스가 하위클래스에 불필요하게 많은 부분이 노출된다는 것이다. 이것은 객체지향의 원칙중 하나인 캡슐화에 위배된다. 또한 하위 클래스가 상위 클래스의 구현에 종속되고 수퍼클래스 구현이 변경되어야 할 경우가 생기면 하위 클래스도 변경해야 하는 문제점을 야기한다.</li><li><strong>둘째,</strong> 컴파일 시점에서 이미 객체 형식이 결정된다는 것이다. A 클래스가 B 클래스의 수퍼클래스다. 라는 식의 정보가 이미 컴파일 시점에서 결정되어버리기 때문에런타임 시점에서 상속받은 수퍼클래스의 구현을 유연하게 바꿀수 없다.</li><li><strong>셋째,</strong> 시스템이 진화(라이브러리는 시간이 지날수록 새로운 기능이 추가되고 버그 수정을 위해 변경된다) 할수록 상속 관계가 복잡해져서 그 시스템의 상속 트리를 정확하게 이해하고 있지 않으면 시스템의 수정과 확젱에 손댈 수 없는 상황까지 발생할 가능성이 있다.</li></ul><p><strong>구현 ( Implements )</strong><br>객체 구현은 객체가 다른 객체의 참조자를 얻는 방식으로 런타임 시에 동적으로 이루어진다.<br>따라서 다른 객체의 참조자를 얻은 후 그 참짜를 이용해서 객체의 기능을 이용하기 떄문에 객체의 인터페이스만을 바라보게 됨으로써 캡슐화가 잘 이루어질 수 있다.<br>하지만 구현에도 단점은 오용에 따른 단점과 주의해야 할 점이 존재한다.</p><p>첫째, 구현은 객체 간의 관계가 수직관계가 아닌 수평 관계가 된다. 따라서 큰 시스템에서 많은 부분에 걸쳐 합성이 사용될 떄 객체나 메소드 명이 명확하지 않으면 코드 가독성이 떨어지고 이해하기 어려워진다.<br>따라서 구현을 사용할 떄에는 그 용도에 따라 클래스들을 패키지로 적절하게 분리해야 하고 각각의 사용 용도가 명확하게 드러나도록 인터페이스를 잘 설계해야 한다.</p><p>스레드의 종료<br>stop() 메소드는 여러 문제점으로 이 메소드를 사용하지 말 것을 권고하고 있다.<br>현재 크게 두가지 방법으로 구현할 수 있따.</p><ul><li><p><strong>첫째,</strong> while(!stopped) 처럼 flag를 사용하는 것이다.<br>이 방법에는 몇가지 문제점이 있따.<br>Run() 메소드 안의 특정 로직에서 무한 루프를 돌거나 조건 루프를 도는 시간이 너무 오래 걸리는 작업을 하면 Stopped 플래그를 검사할 수 없다.</p></li><li><p><strong>둘째,</strong> Interrupt() 메소드를 이용한다.<br>interrupt() 메소드는 현재 수행하고 있는 명령을 바로 중지시킨다.<br>만약 interrupt() 메소드를 호출하는 시점에 Object 클래스의 wait(), wait(long), wait(long, int) 메소드나 Thread 클래스의 join(), join(long), join(long, int), sleep(long), sleep(long, int) 메소드가 호출된 경우에는 InterruptedException을 발생시킨다.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Try&#123;</span><br><span class="line">while(!Thread.currentThread().isInterrupted() &#123; … &#125;</span><br><span class="line">&#125;catch ( InterruptedException e) &#123;</span><br><span class="line">// 예외를 처리한다.</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">// 마무리 해야할 작업을 수행한다.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>데몬 스레드와 join()</strong><br>자바에서는 애플리케이션 내부의 모든 스레드가 종료되지 않으면 jvm이 종료되지 않는다.<br>But 데몬 스레드는 백그라운드 작업을 위한 스레드의 하위 개념인데 위 조건에서 예외인 스레드이다.</p><p><strong>Join()</strong><br>join은 t.join() 처럼 실행하게 되면 t 스레드의 실행이 종료될때까지 기다리다가 끝이 나면 자신의 나머지 작업을 이어간다.</p><ul><li>스레드 그룹</li><li>스레드 우선순위</li><li>멀티스레드와 동기화</li><li>JVM의 런타임 데이터 영역</li></ul><p>PC레지스터 영역</p><ul><li>현재 스레드가 수행하고 있는 코드의 명령과 주소들을 저장한다.</li><li>JVM 안에서 실행되는 모든 스레드는 각자 자신으 PC ( PROGRAM COUNT ) 레지스터가 있다. 각 스레드들은 특정 객체의 메소드를 호출하고 그 메소드를 실행하는 도중 다른 객체의 특정 메소드를 호출하는 등의 과정이 생기는데,  PC 레지스터는 해당 스레드가 어떤 부분을 어떤 명령으로 실행할지에 대해 기록하는 영역이다.</li></ul><p>JVM 스택 영역</p><ul><li>지역 변수, 파라미터, 리턴 값과 지역 객체 레퍼런스를 저장한다. 각각의 스레드들이 자신만의 스택을 만들어서 사용한다.</li><li>JVM 스레드는 private JVM 스택을 갖게된다. JVM 안의 모든 스레드들은 각자 자신만의 고유 스택 영역을 갖는다. 자신만의 고유 영역 스택이기 때문에 다른 스레드가 자신의 스택 영역에 접근할 수 없다. 이 스택 영역에는 지역변수와 지역 객체 레퍼런스, 메소드 파라미터, 메소드 리턴 값 등 어떤 메소드 안에서 사용되어지는 값들이 저장된다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CallByValue &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">StringBuffer a = new StringBuffer(“AAAA”);</span><br><span class="line">StringBuffer b = new StringBuffer(“BBBB”);</span><br><span class="line">swapMethod(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swapMethod(StringBuffer a, StringBuffer b)&#123;</span><br><span class="line">String temp = x.toString();</span><br><span class="line">x.delete(0, x.length());</span><br><span class="line">x.append(y.toString());</span><br><span class="line">y.delete(0, y.length());</span><br><span class="line">y.append(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자바는 참조 형식의 언어이이기 때문에 어떤 객체를 이용하기 위해 그 객체의 레퍼런스를 사용한다.</p><p>힙 영역</p><ul><li>생성된 객체(Array도 객체임)들을 저장한다. 모든 스레드에 의해서 공유된다.</li><li>힙은 JVM의 모든 스레드들이 공유하는 데이터 영역이다. 인스턴스화된 모든 객체가 저장되는 곳이다. new 키워드로 어떤 객체를 생성할 떄 이 영역에 해당 객체가 저장되고 그 객체가 더 이상 사용되지 않을떄, 즉 해당 객체의 참조가 모두 끊어졌을때 가비지 컬렉션 목록에 포함되고 그 후 적절한 시점에 JVM 스스로 가비지 컬렉터로 그 객체가 점유하고 있던 메모리를 반환한다.</li></ul><p>메소드 영역</p><ul><li>각 클래스 또는 인터페이스의 런타임 컨스턴트 풀 영역, 메소드, 생성자를 저장한다. 모든 스레드에 의해서 공유된다.</li><li>메소드 영역은 힙과 같이 JVM의 모든 스레드들이 공유하는 데이터 영역이다.</li></ul><p>런타임 컨스턴트 풀 영역</p><ul><li>각 클래스 또는 인터페이스 클래스 변수, static 변수, 클래스 객체 레퍼런스를 저장한다.</li><li>런타임 컨스턴트 풀 영역은 각 클래스에 대한 인스턴스 변수와 인스턴스 레퍼런스, 그리고 static 변수와 static 인스턴스 레퍼런스가 저장되는 영역이다.</li><li>메소드 영역에 의해 할당되고 또한 메소드 영역이 관리하기 떄문에 모든 JVM 스레드들이 공유하게 된다.<br>네이티브 메소드 스택 영역- 일명 C 스택으로 불린다. JNI의 네이티브 메소드 호출 시 사용되는 스택 영역이다.</li><li>네이티브 메소드 스택 영역은 흔히 C 스택이라 불리우는 영역으로 JNI를 사용할 경우 네이티브 메소드에서 사용되는 값을 저장할 때 사용되는 데이터 영역이다.</li></ul><p><code>Lock, Monitor, Synchronized</code><br>메소드에 Synchronized를 선언하는 방법과 블록 형태로 사용하는 방법이 있따.</p><p><code>synchronized</code> 키워드를 사용하면 모니터(monitor)가 해당 객체의 락을 검사한다.<br>모니터는 락의 현재 사용여부를 검사함으로써 각 객체를 보호하는데, 락과 마찬가지로 모니터도 각 객체의 레퍼런스와 연결되어 있따.<br>어떤 클래스를 new 키워드를 사용해서 인스턴스화 하면 락과 함께 자동으로 생성된다.</p><p>synchronized 키워드를 사용한 메소드나 블록에 접근하게 되면 그 synchronized와 연관된 모니터는 해당 객체의 레퍼런스를 검사한ㄷ.<br>이떄 락이 아직 다른 어떤 스레드에게 사용되어지지 않고 있다면 JVM에게 알려준다.<br>JVM은 monitorenter라는 JVM 내부 명령으로 해당 객체의 락을 요청한 스레드에게 준다.<br>반대로 락이 어떤 스레드에 의해 사용되고 있다면 락이 반환될때까지 더이상 진행되지 않고 그 스레드는 대기한다.<br>스레드가 락을 얻은 후에 synchronized 메소드나 블록을 다 마치고 나면 monitorexit라는 JVM 내부 명령을 자동 실행해 해당 스레드가 얻은 객체의 락을 즉시 반환한다.</p><p>ThreadLocal - 공유 자원의 특정 데이터만을 접근하는 각각의 스레드가 다른 값을 갖도록 만들어 유지하고 싶을 때도 있다.<br>ThreadLocal은 흔하게 사용되는 클래스는 아니지만 java.nio.charset 패키지의 Charset 클래스와 java.util.loggin 패키지의 LogRecord 클래스에서 그 실제 구현 예를 볼 수 있다.</p><p>생성자 - 소비자 패턴<br>더그 리 (Doing Lea) 가 만든 concurrent util 패키지를 참조하자. 더그 리가 만든 패키지의 예제 코드가 공개되어 있다.</p><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 2장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;02. 스레드&lt;/h1&gt;
&lt;p&gt;자바 언어가 스레드를 강력하게 지원하게 된 이유 중 하나는 자바가 실행되는 기반인 JVM 자체가 하나의 프로세스기 때문이다?&lt;br&gt;
IDE 백그라운드에서 입력 내용에 대한 오류를 검사하면서 바로바로 바로잡아 준다.&lt;
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="Thread" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/Thread/"/>
    
    
      <category term="Thread" scheme="http://jungha-cho.github.io/tags/Thread/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency in Practice, Objec Share</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaConcurrencyinPracticeSharedObject/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaConcurrencyinPracticeSharedObject/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:46:50.620Z</updated>
    
    <content type="html"><![CDATA[<h1>03. 객체 공유</h1><h3>3.1 가시성</h3><p>가시성은 그다지 직관적으로 이해할 수 있는 문제가 아니기 때문에 흔히 무시하고 넘어가는 경우가 많다.<br>동기화 기능을 지정하지 않으면 컴파일러나 프로세서, jvm 등이 프로그램 코드가 실행되는 순서를 임의로 바꿔 실행하는 이상한 경우가 발생하기도 한다. 다시 말하자면, 동기화 되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 반드시 이런 순서로 동작할 것이다 라고 단정지을 수 없다.</p><h3>3.1.1 스테일 데이터</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">public class MutableInteger &#123;</span><br><span class="line">    private int value;</span><br><span class="line"></span><br><span class="line">    public int get() &#123; return value; &#125;</span><br><span class="line">    public void set(int value) &#123; this.value = value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>동기화되지 않은 상태로 정수 값을 보관하는 클래스</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class SynchronizedInteger &#123;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private int value;</span><br><span class="line"></span><br><span class="line">    public synchronized int get() &#123; return value; &#125;</span><br><span class="line">    public synchronized void set(int value) &#123; this.value = value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>동기화된 상태로 정수 값을 보관하는 클래스</p><h3>3.1.2 단일하지 않은 64비트 연산</h3><p>동기화되지 않은 상태에서 특정 스레드가 변수의 값을 읽으려 한다면 스테일 상태의 값을 읽어갈 가능성이 있긴 하지만, 그래도 전혀 엉뚱한 값을 가져가는 것이 아니라 바로 이전에 다른 스레드에서 설정한 값을 가져가게 된다. 말하자면 '전혀 난데 없는 값이 생기지는 않는다’는 정도로 생각할 수 있겠다.</p><p>하지만 64비트를 사용하는 숫자형에 volatile 키워드를 사용하지 않는 경우에는 난데없는 값마저 생길 가능성이 있다. 자바 메모리 모델은 메모리에서 값을 가져오고(fetch) 저장(store)하는 연산이 단일해야 한다고 정의하고 있지만, volatile로 지정되지 않은 long이나 double형의 64비트 값에 대해서는 메모리에 쓰거나 읽을 때 두 번의 32비트 연산을 사용할 수 있도록 허용하고 있다. 따라서  volatile을 지정하지 않은 long 변수의 값을 쓰는 기능과 읽는 기능이 서로 다른 스레드에서 동작한다면, 이전 값과 최신 값에서 각각 32비트를 읽어올 가능성이 생긴다.</p><h3>3.1.3 락과 가시성</h3><p>락은 상호 배제(mutual exclusion) 뿐만 아니라 정상적인 메모리 가시성을 확보하기 위해서도 사용한다. 변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화 시켜야 한다.</p><h3>3.1.4 volatile 변수</h3><p>자바 언어에서는 volatile 변수로 약간 다른 형태의 좀더 약한 동기화 기능을 제공하는데 ,다시 말해 volatile로 선언된 변수의 값을 바꿨을 떄 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해준다. 특정 변수를 선언할 떄 volatile 키워드를 지정하면, 컴파일러와 런타임 모두 '이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치 해서는 안 된다’고 이해한다. volatile로 지정된 변수는 프로세서의 레지스터에 캐시 되지도 않고, 프로세서 외부의 캐시에도 들어가지 않기 때문에 volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해둔 최신의 값을 읽어갈 수 있다.</p><p>실제로 <code>volatile</code> 변수가 갖는 가시성 효과는 <code>volatile</code>로 지정된 변수 자체의 값에 대한 범위보다 약간 확장되어 있다. 스레드 A가 <code>volatile</code> 변수에 값을 써넣고 스레드 B가 해당 변수의 값을 읽어 사용한다고 할 떄, 스레드 B가 <code>volatile</code> 변수의 값을 읽고 나면 스레드 A가 변수에 값을 쓰기전에 볼 수 있었던 모든 변수의 값을 스레드 B도 모두 볼 수 있다는 점이다. 따라서 메모리 가시성의 입장에서 본다면 <code>volatile</code> 변수를 사용하는 것과 <code>synchronized</code> 키워드로 특정 코드를 묶는 게 비슷한 효과를 가져오고, <code>volatile</code> 변수의 값을 읽고나면 <code>synchronized</code> 키워드로 특정 코드를 묶는 게 비슷한 효과를 가져오고, <code>volatile</code> 변수의 값을 읽고 나면 <code>synchronized</code> 블록에 진입하는 것과 비슷한 상태에 해당한다.</p><p>동기화하고자 하는 부분을 명확하게 볼 수 있고, 구현하기가 훨씬 간단한 경우에만 volatile 변수를 활용하자. 반대로 작은 부분이라도 가시성을 추론해봐야 하는 경우에는 volatile 변수를 사용하지 않는 것이 좋다. volatile 변수를 사용하는 적절한 경우는, 일반적으로 변수에 보관된 클래스의 상태에 대한 가시성을 확보하거나 중요한 이벤트가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우 등이 해당된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean asleep;</span><br><span class="line">...</span><br><span class="line">while (!asleep)</span><br><span class="line">    countSomeSheep();</span><br></pre></td></tr></table></figure><p>양 마리 수 세기</p><p>보다시피 volatile 변수는 굉장히 간편하게 사용할 수 있는 반면 제약 사항도 있다.<br>락을 사용하면 가시성과 연산의 단일성을 모두 보장받을 수 있다. 하지만 volatile 변수는 연산의 단일성은 보장하지 못하고 가시성만 보장한다.</p><p>정리하자면, volatile 변수는 다음과 같은 상황에서만 사용하는 것이 좋다.</p><ul><li>변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재</li><li>해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않다.</li><li>해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우</li></ul><h3>3.2 공개와 유출</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Set&lt;Secret&gt; knownSecrets;</span><br><span class="line"></span><br><span class="line">public void initialize() &#123;</span><br><span class="line">    knownSecrets = new HashSet&lt;Secret&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>객체 공개</h3><p>public static 변수에 객체를 설정하면 가장 직접적인 방법으로 해당 객체를 모든 클래스와 모든 스레드에서 변수를 사용 할 수 있도록 공개하는 셈이다. initialize 메소드는 HashSet 클래스의 인스턴스를 생성해 public static으로 지정된 knownSecrets 변수에 저장하고, knownSecrets 변수에 저장된 HashSet 객체는 스코프에 관계없이 완전히 공개된다.</p><h3>3.2.1 생성 메소드 안전성</h3><h3>3.3 스레드 한정</h3><h3>3.3.3 ThreadLocal</h3><p>스레드 내부의 값과 값을 갖고 있는 객체를 연결해 스레드 한정 기법을 적용할 수 있도록 도와주는 좀더 형식적인 방법으로 <code>ThreadLocal</code>이 있따. <code>ThreadLocal</code> 클래스에는 get과 set 메소드가 있는데 호출하는 스레드마다 다른 값을 사용할 수 있도록 관리해준다. 다시 말해 <code>ThreadLocal</code> 클래스의 get 메솓를 호출하면 현재 실행 중인 스레드에서 최근 set 메소드를 호출해 저장했던 값을 가져올 수 있다.</p><p>JDBC 연결은 스레드에 안전하지 않기 떄문에 멀티스레드 애플리케이션에서 적절한 동기화 없이 연결 객체를 전역 변수로 만들어 사용하면 애플리케이션 역시 스레드에 안전하지 않다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">    public Connection initialValue() &#123;</span><br><span class="line">        return DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public static Connection getConnection() &#123;</span><br><span class="line">    return connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConnectionHolder</code></p><p>이처럼 JDBC 연결을 보관할 때 ThreadLocal을 사용하면 스레드는 저마다 각자의 연결 객체를 갖게 된다. 특정 스레드가 ThreadLocal.get 메소드를 첨으로 호출하면 initialValue 메소드에서 값을 만들어 해당 스레드에게 초기 값으로 넘겨준다.</p><p>만약 원래 단일 스레드에서 동작하던 기능을 멀티스레드 환경으로 구성해야 할 떄, 그 의미에 따라 다르지만 공유된 전역 변수를 ThreadLocal을 활용하도록 변경하면 스레드 안전성을 보장할 수 있다. 단일 스레드 애플리케이션에서 프로그램 전체를 대상으로 사용하던 캐시를 멀티스레드 애플리케이션에서는 여러 개의 스레드별 캐시로 나눠 사용하는 편이 더 효과적일 것이다.</p><h3>3.4 불변성</h3><p>직접적으로 객체를 동기화 하지 않고도 안전하게 사용할 수 있는 방법 가운데 마지막으로 알아볼 내용은 바로 불변 객체이다. 만약 객체의 상태가 변하지 않는다고 가정하면 어떨까? 지금까지 발생했던 복잡하고도 다양한 문제가 일순간에 사라진다.</p><h3>3.5.6 객체를 안전하게 공유하기</h3><p>언제든 객체에 대한 참조를 가져다 사용하는 부분이 있다면, 그 객체로 어느 정도의 일을 할 수 있는지를 정확하게 알고 있어야 한다. 객체를 사용하기 전에 동기화 코드를 적용해 락을 확보해야 하는지? 객체 내부의 값을 바꿔도 괜찮은지, 아니면 값을 읽기만 해야 하는 것인지? 대부분의 동기화 오류는 이와 같이 일반적인 몇 가지 수칙을 이해하지 못하고 프로그램을 작성하는 데서 싹트기 시작한다. 또한, 반대로 객체를 외부에서 사용할 수 있도록 공개할 떄에는 해당 객체를 어떤 방법으로 사용할 수 있고, 사용해야 하는지에 대해서 정확하게 설명해야 한다.</p><p>여러 스레드를 동시에 사용하는 병렬 프로그램에서 객체를 공유해 사용하고자 할 때 가장 많이 사용되는 몇 가지 원칙을 살펴보면 다음과 같다.<br><code>스레드 한정</code> : 스레드에 한정된 객체는 완전하게 해당 스레드 내부에 존재하면서 그 스레드에서만 호출해 사용할 수 있다.<br><code>읽기 전용 객체를 공유</code> : 읽기 전용 객체를 공유해 사용한다면 동기화 작업을 하지 않더라도 여러 스레드에서 언제든지 마음껏 값을 읽어 사용할 수 있다. 물론 읽기 전용이기 때문에 값이 변경될 수는 없다. 불변 객체와 결과적으로 불변인 객체가 읽기 전용 객체에 해당한다고 볼 수 있다.<br><code>스레드에 안전한 객체를 공유</code> : 스레드에 안전한 객체는 객체 내부적으로 필수적인 동기화 기능이 만들어져 있기 때문에 외부에서 동기화를 신경 쓸 필요가 없고, 여러 스레드에서 마음껏 호출해 사용할 수 있다.<br><code>동기화 방법을 적용</code> : 특정 객체에 동기화 방법을 적용해두면 지정한 락을 획득하기 전에는 해당 객체를 사용할 수 없다. 스레드에 안전한 객체 내부에서 사용하는 객체나 공개된 객체 가운데 특정 락을 확보해야 사용할 수 있도록 막혀 있는 객체 등에 동기화 방법이 적용되어 있다고 볼 수 있다.</p><p>출처 :브라이언 괴츠, 더그 리, 팀 피얼스, 조셉 보우비어, 데이빗 홈즈, 조슈아 블로쉬 공저, 『 멀티코어를 100% 활용하는 자바 병렬 프로그래밍』, 에이콘(2008.7.30), 3장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;03. 객체 공유&lt;/h1&gt;
&lt;h3&gt;3.1 가시성&lt;/h3&gt;
&lt;p&gt;가시성은 그다지 직관적으로 이해할 수 있는 문제가 아니기 때문에 흔히 무시하고 넘어가는 경우가 많다.&lt;br&gt;
동기화 기능을 지정하지 않으면 컴파일러나 프로세서, jvm 등이 프로그램
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="객체 공유" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EA%B0%9D%EC%B2%B4-%EA%B3%B5%EC%9C%A0/"/>
    
    
      <category term="자바병렬프로그래밍" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EB%B3%91%EB%A0%AC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>14. 채널</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOChannel/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOChannel/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:47:02.460Z</updated>
    
    <content type="html"><![CDATA[<h1>14. 채널</h1><p>채널은 일종의 게이트웨이이다. 기존의 파일이나 소켓 등에서 사용하던 스트림이 네이티브 IO 서비스를 이용할 수 있도록 도아주는 메소드를 제공한다. 하지만 채너은 기존의 스트림과 구별되는 몇 가지 큰 차이점이 존재한다. 채널은 데이터를 보내거나 데이터를 받기 위한 타겟으로 ByteBuffer를 사용한다는 점이다. ByteBuffer를 사용함으로써 직간접적으로 여러 가지 다양한 네이티브 서비스를 이용할 수 있기 때문이다.</p><p>또 이렇게 채널을 통해 데이터를 주고 받으면, 운영체제 수준의 네이티브 IO 서비스들을 직간접적으로 이용할 수 있다는 점이다. 따라서 기본적으로 채널을 통한 IO 통신은 기존의 스트림보다 좀더 효율적이고 기존에 지원되지 않았던 메모리 맵 파일, 파일 락킹 같은 기능들도 이용할 수 있게 된다.</p><p>마지막으로 채널은 스트림과 달리 단방향 뿐만 아니라 양방향 통신도 가능하다. 항상 양방향 통신을 이용할 수 있는 것은 아니지만 소켓 채널의 경우 별다른 설정 없이 양방향 통신이 가능하지만 파일 챈ㄹ의 경우에는 그렇지 않다.</p><h1>02. 채널의 기본 인터페이스</h1><p>채널은 버퍼와 달리 인터페이스 기반으로 되어 있으므로 채널이 해야 할 행동에 대한 정의만 하고 그 세부적인 구현은 각각의 하위 구현 클ㄹ스에서 담당하게 되어 있다. 이렇게 설계된 이유는 인터페이스 위주의 설계가 확장성이 뛰어나고 좀더 유엲ㄴ 시스템 구조를 갖게 되는 점도 있지만, 가장 결정적인 이유는 다른 곳에 있다. 그 이유는 각각의 운영체제마다 IO에 관련된 시스템 콜 명령어와 그 처리 루틴이 다르기 때문이다. 따라서 자바 플랫폼이 다르더라도 같은 동작을 해야하기 떄문에 어떤 행동을 해야 하는지에만 초점을 맞춘 채널 인터페이스를 정의하고 그 세부적인 행동에 대한 구현은 각 운영체제에 맞춰 대부분 네이티브 언어를 사용해서 구현하도록 만들 수 밖에 없었던 것이다.</p><p>이러한 이유로 자바 플랫폼이면 어디서나 코드를 수정하지 않아도 동일하게 동작한다(write once, run anyway)는 자바의 기본 철학에 위배되지 않게 구현하기 위해 이미 도입되었어야 할 기능들이 이런 구현상의 어려움으로 뒤늦게 나온것이다.</p><h3>1. Channel, InterruptibleChannel</h3><p>Channel 인터페이스는 채널의 최상위 인터페이스다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package java.nio.channel;</span><br><span class="line"></span><br><span class="line">import java.io.Closeable;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public interface Channel extends Closeable &#123;</span><br><span class="line">    public boolean isOpen();</span><br><span class="line">    public void close() throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>채널이 현재 열려 있는지의 여부를 확인하기 위한 isOpen() 메소드와 채널이 열려있을 경우, 채널을 닫기 위한 close() 메소드, 이렇게 두개만 정의하고 있다.</p><p>InterruptibleChannel 인터페이스는 비동기적으로 채널을 닫거나(close) 인터럽트(Interrupt)할 수 있는 인터페이스다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface InterruptibleChannel extends Channel &#123;</span><br><span class="line">    public void close() throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API</p><p>이 인터페이스는 Channel 인터페이스를 상속 받고 Channel 인터페이스의 Close() 메소드를 오버라이딩한다. 이 인터페이스로 인해 기존의 스트림과 달리 명백하게 채널을 닫을 수 있게 되었다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">    static FileInputStream in = null;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        in = new FileInputStream(&quot;C:/wwwroot/test.doc&quot;);</span><br><span class="line">        TestThread t = new TestThread(in);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        System.out.println(in.available());</span><br><span class="line"></span><br><span class="line">        t.interrupt();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        System.out.println(in.available());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestThread extends Thread &#123;</span><br><span class="line">        FileInputStream in = null;</span><br><span class="line">        public TestThread(FileInputStream o) &#123;</span><br><span class="line">            in = o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int v = 0;</span><br><span class="line">                while ( ( v = in.read() ) != -1 ) &#123;</span><br><span class="line">                    System.out.println(&quot;Thread start...&quot;);</span><br><span class="line">                    System.out.println(v);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;catch (Exception e) &#123;</span><br><span class="line">                System.out.println(&quot;Thread end...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드를 실행하게 되면 스레드와 스트림의 상태 불일치가 일어난다. in.close() 부분을 finally문으로 처리하면 상태 불일치가 발생하지 않겠지만 이러한 현상이 일어날 가능성도 있다. 이러한 상태 불일치를 발생시키지 않고 채널과 스레드의 상태를 명확하게 하기 위한 인터페이스가 바로 InterruptibleChannel이다. 대부분의 세부적인 기능을 제공하는 채널들이 이 인터페이스를 구현하고 있는데, 이 인터페이스를 구현한 채널들은 두 가지 방법으로 채널과 스레드의 상태를 명확하게 유지할 수 있게 해준다.</p><p>첫째, 비동기적인 방식으로 채널을 닫을 수 있다. InterruptibleChannel 인터페이스를 구현한 채널 내에서 입출력 작업을 하던 중 블록된 스레드가 있는 경우, 다른 스레드가 이 채널의 close() 메소드를 호출해서 채널을 종료할 수 있다. 이렇게 채널을 종료하면 블록되어 있던 스레드는 AsynchronousCloseException을 받게 된다.</p><p>둘째, 앞서와 반대의 경우다. InterruptibleChannel 인터페이스를 구현한 채널 내에서 입출력 작업을 하던 중 블록된 스레드가 있는 경우, 다른 스레드가 블록된 스레드의 interrupt() 메소드를 호출할 수 있다. 이렇게 블록된 스레드의 Interrupt() 메소드를 호출하면 채널이 닫히고 그 후 블록된 스레드는 ClosedByInterruptException을 받게 된다. 또 그 블록된 스레드 상태는 Interrupt로 설정된다.</p><p>이처럼 InterruptibleChannel 인터페이스를 구현한 채널들은 스레드 상태를 명확하게 유지할 수 있다.</p><h3>2. ReadableByteChannel, WritableByteChannel, ByteChannel</h3><p>ReadableByteChannel은 파라미터로 주어진 ByteBuffer로 채널안의 데이터를 읽어들이는 read()메소드만 제공한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package java.nio.channels;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line">public interface ReadableByteChannel extends Channel &#123;</span><br><span class="line">    public int read(ByteBuffer dst) throws IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WritableByteChannel은 앞서와 반대로 ByteBuffer에 저장된 데이터를 채널로 쓰기 위한 write() 메소드만을 제공한다.</span><br><span class="line">package java.nio.channels;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line">public interface WritableByteChannel extends Channel &#123;</span><br><span class="line">    public int write(ByteBuffer src) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ByteChannel은 ReadableByteChannel과 WritableByteChannel을 상속해서 채널로부터 데이터를 읽어들이거나 채널로 데이터를 쓰는 두 가지 동작을 모두 할 수 있는 인터페이스이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.Channels;</span><br><span class="line">import java.nio.channels.ReadableByteChannel;</span><br><span class="line">import java.nio.channels.WritableByteChannel;</span><br><span class="line"></span><br><span class="line">public class SimpleChannelTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ReadableByteChannel src = Channels.newChannel(System.in);</span><br><span class="line">        WritableByteChannel dest = Channels.newChannel(System.out);</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(1024);</span><br><span class="line">        while(src.read(buffer) != -1) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            while(buffer.hasRemaining()) &#123;</span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>입력갑을 단순히 출력해주는 예제.</p><p>java.nio.channels.channels 클래스에는 채널에서 사용하는 유틸리티 클래스로 기존의 스트림을 채널로 또는 채널을 스트림으로 손쉽게 변환해주는 여러 유용한 메소드가 있다. newChannel() 메소드를 이용해서 ReadableByteChannel과 WritableByteChannel을 생성했다.</p><h3>4. ScatteringByteChannel, GatheringByteChannel</h3><p>Scatter/Gatter는 운영체제가 지원하는 기술이다. NIO의 채널에서는 효율적인 입출력을 위해 운영체제가 지원하는 네이티브 IO 서비스인 Scatter/Gather를 사용할 수 있도록 ScatteringByteChannel, GatheringByteChannel 인터페이스를 제공하고 있다.</p><p>Scatter/Gather는 버퍼 여러개를 한번의 IO 작업으로 처리할 수 있게 해주는 강력한 기능이다.</p><p>단순히 보면 여러 버퍼를 다루기 위한 반복문을 피하고 코드가 간단해진다는 장점도 있다. 하지만 이 인터페이스가 정말로 강력한 것은 바로 시스템 콜과 커널 영역에서 프로세스 영역으로의 버퍼 복사를 줄여주거나 또는 완전히 없애준다는 점이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer[] buf = ....;</span><br><span class="line">for ( int i = 0 ; i &lt; buf.length ; i ++ ) &#123;</span><br><span class="line">// ByteBuffer 배열의 사이즈 만큼 읽기 시스템 콜을 수행한다.</span><br><span class="line">// 만약, 커널과 프로세스 간의 동일한 물리적 메모리를 참조하지 않는다면</span><br><span class="line">// 반복문을 실행하는 횟수만큼 커널 영역에서 프로세스 영역으로</span><br><span class="line">// 버퍼 복사가 이루어진다.</span><br><span class="line">readableByteChannel.read(buf[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ByteBuffer[] buf = ...;</span><br><span class="line">// 단 한번의 시스템 콜을 수행한다.</span><br><span class="line">// 만약, 앞선 경우와 같이 동일한 물리적 메모리를 참조하지 않는 경우</span><br><span class="line">// 단 한번의 커널 영역에서 프로세스 영역으로의 버퍼 복사가 이루어진다.</span><br><span class="line">scatteringByteChannel.read(buf);</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.ScatteringByteChannel;</span><br><span class="line"></span><br><span class="line">public class ScatterTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fin = new FileInputStream(&quot;C:/news.txt&quot;);</span><br><span class="line">        ScatteringByteChannel channel = fin.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer header = ByteBuffer.allocate(100);</span><br><span class="line">        ByteBuffer body = ByteBuffer.allocate(200);</span><br><span class="line">        ByteBuffer[] buffers = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">        int readCount = (int) channel.read(buffers);</span><br><span class="line">        channel.close();</span><br><span class="line">        System.out.println(&quot;Read Count : &quot; + readCount);</span><br><span class="line">        System.out.println(&quot;\n//-----------------------------//\n&quot;);</span><br><span class="line"></span><br><span class="line">        header.flip();</span><br><span class="line">        body.flip();</span><br><span class="line"></span><br><span class="line">        byte[] b = new byte[100];</span><br><span class="line"></span><br><span class="line">        heade.get(b);</span><br><span class="line">        System.out.println(&quot;Header : &quot; + new String(b));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n//------------------------------//\n&quot;);</span><br><span class="line"></span><br><span class="line">        byte[] bb = new byte[200];</span><br><span class="line">        body.get(bb);</span><br><span class="line">        System.out.println(&quot;Body : &quot; + new String(bb));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.GatheringChannel;</span><br><span class="line"></span><br><span class="line">public class GatheringTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileOutputStream fo = new FileOutputStream(&quot;C:/test.txt&quot;);</span><br><span class="line">        GatheringByteChannel channel = fo.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer header = ByteBuffer.allocateDirect(20);</span><br><span class="line">        ByteBuffer body = ByteBuffer.allocateDirect(40);</span><br><span class="line">        ByteBuffer[] buffers = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">        header.put(&quot;Hello &quot;.getBytes());</span><br><span class="line">        body.put(&quot;World!&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">        header.flip();</span><br><span class="line">        body.flip();</span><br><span class="line"></span><br><span class="line">        channel.write(buffers);</span><br><span class="line">        channel.close();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scatter/Gather를 적절한 곳에 사용하면 여러 면에서 정말 강력한 기술이 된다. 예를 들어 네트워크 프로그래밍을 하는데 TCP 기반 서버/클라이언트 통신 프로토콜을 만들어 사용할때 프로토콜에 해당하는 부분은 헤더 버퍼에 실제 전달할 내용은 바디 버퍼에 넣어 전달할 수 있다.</p><h3>03. 파일 채널</h3><ul><li>첫째 ByteChannel 인터페이스를 구현한다. 이 인터페이스를 구현하기 때문에 읽고 쓸수 있는 양방향성을 가질 수 있다. 하지만 항상 그렇진 않다.</li><li>둘째 AbstractInterruptibleChannel 추상 클래스를 구현하고 있다. 이 클래스는 InterruptibleChannel 인터페이스를 구현한 클래스인데 비동기적인 방식으로 채널을 닫을 수 있게 되며 스레드와 채널 간의 상태 불일치가 발생하지 않도록 보장해준다.</li><li>셋째 ScatteringByteChannel, GatheringByteChannel 인터페이스를 구현한다는 점이다. 따라서 ByteBuffer 배열을 이용해서 효율적으로 읽기와 쓰기가 가능하다.</li></ul><p>파일 채널은 항상 블록킹 모드이며 비블록킹 모드로 설정할 수 없다.<br>파일채널 객체는 직접 만들 수 없다<br>파일채널 객체는 이미 열려있는 파일 채널 객체로부터 getChannel() 메소드를 호출해서 생성된다. getChannel() 메소드로 리턴된 파일채널 객체는 파일 객체아 같은 파일에 연결되고 또한 같은 접근 권한을 갖게 된다.<br>대부분의 채널처럼 파일채널도 가능하면 네이티브 IO 서비스를 사용하기 위해 노력한다.<br>파일채널 클래스 스스로는 추상 클래스다. 파일채널 클래스의 실제 구현체는 getChannel() 메소드를 통해 얻어지는데 이렇게 얻어진 파일채널의 실제 구현체는 자신이 제공하는 메소드의 일부 또는 전부를 네이티브 코드를 사용해서 만들어 네이티브 IO 서비스를 최대한 이용하게 되어 있다.<br>파일채널 객체는 스레드에 안전하다.<br>같은 파일 채널 인스턴스에 대해 여러 스레드들이 동시에 메소드들을 호출해도 동기화 문제가 발생하지 않는다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package java.nio.channels;</span><br><span class="line"></span><br><span class="line">public abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel &#123;</span><br><span class="line">    // 1. 기본 속성</span><br><span class="line">    public abstract int read (ByteBuffer dst)</span><br><span class="line">    public abstract int write (ByteBuffer src)</span><br><span class="line">    public abstract long size ()</span><br><span class="line">    public abstract long position ()</span><br><span class="line">    public abstract void position (long newPosition)</span><br><span class="line">    public abstract void truncate (long size)</span><br><span class="line">    public abstract void force (boolean metaData)</span><br><span class="line"></span><br><span class="line">    // 2. 파일 락킹</span><br><span class="line">    public final FileLock lock()</span><br><span class="line">    public abstract FileLock lock (long position, long size, boolean shared)</span><br><span class="line">    public final FileLock tryLock()</span><br><span class="line">    public abstract FileLock tryLock (long position, long size, boolean shared)</span><br><span class="line"></span><br><span class="line">    // 3. 메모리 맵핑</span><br><span class="line">    public abstract MappedByteBuffer map (MapMode mode, long position, long size)</span><br><span class="line">    public static class MapMode</span><br><span class="line">    &#123;</span><br><span class="line">        public static final MapMode READ_ONLY</span><br><span class="line">        public static final MapMode READ_WRITE</span><br><span class="line">        public static final MapMode PRIVATE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4. 채널 간 직접 전송</span><br><span class="line">    public abstract long transferTo (long position, long count, WritableByteChannel target)</span><br><span class="line">    public abstract long transferFrom (ReadableByteChannel src, long position, long count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>파일 채널은 이 API에서 보듯이 크게 네가지 부분으로 나눠서 살펴볼 수 있다.</p><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 14장 인용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;14. 채널&lt;/h1&gt;
&lt;p&gt;채널은 일종의 게이트웨이이다. 기존의 파일이나 소켓 등에서 사용하던 스트림이 네이티브 IO 서비스를 이용할 수 있도록 도아주는 메소드를 제공한다. 하지만 채너은 기존의 스트림과 구별되는 몇 가지 큰 차이점이 존재한다.
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Channel" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Channel/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="Channel" scheme="http://jungha-cho.github.io/tags/Channel/"/>
    
  </entry>
  
  <entry>
    <title>05. 문자 스트림 : 문자 단위 IO 클래스</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOCharIOClass/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOCharIOClass/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:47:05.704Z</updated>
    
    <content type="html"><![CDATA[<h3>05. 문자 스트림 : 문자 단위 IO 클래스</h3><p>문자 단위 IO클래스는 자바가 처음 등장했을떄에는 포함되지 않았다. 이후, 2바이트 문화권에서 2바이트 문자를 입출력하는 클래스를 요청하게 되었고 나중에 추가하게 된 것이다.</p><p>보통 바이너리 파일을 입출력할 때에는 바이트 단위의 IO 클래스를 사용하게 되고, 문자 단위의 IO 클래스를 사용하게 될 때에는 문자 스트림을 이용하게 된다.</p><p>바이트 단위 IO 클래스와 문자 단위 IO 클래스 모두 사용법은 비슷하다. 다른 점이 있다면 바이트 단위로 입출력하느냐, 문자 단위로 입출력하느냐의 차이가 있을 뿐이다. 그리고 바이트 단위 IO 클래스와 문자 단위 IO 클래스는 완전히 따로 사용하지 않는다는 것이 중요하다.</p><p>문자 단위 IO 클래스의 <code>InputStreamReader</code>와 <code>OutputStreamWrite</code> 클래스가 있는데 이 두가지 클래스는 바이트 단위 IO 클래스와 문자 단위 IO 클래스 간에 다리 역할을 함으로써 서로 협력해서 사용할 수 있게 해준다.</p><p>문자 단위 IO 클래스도 바이트 단위 IO 클래스와 마찬가지로 네트워크 프로그래밍, JDBC 프로그래밍, XML 프로그래밍에서 사용된다. 그렇지만 JDBC 프로그래밍의 경우에는 대용량 텍스트를 데이트베이스에 저장하고 읽어오고자 할 때, 문자 단위 IO 클래스를 사용한다.</p><h3>01. 문자 단위 IO 클래스</h3><p><img src="http://cfile21.uf.tistory.com/image/255D444E58BFF2D516D83F" alt="image"></p><p>문자 단위 IO 클래스의 사용법은 바이트 단위 IO 클래스와 다르지 않다. 다만, 바이트 단위로 입출력을 하는 것이 아니라, 문자 단위로 입출력을 한다는 것이다.</p><p>상속도를 보면 알 수 있는 것 처럼 Object를 상속 받는 Reader와 Writer는 문자 단위 IO의 최상위 클래스 이기 때문에 문자 단위 IO를 이해하기 위해서는 이 Reader와 Writer를 이해하는 것이 중요하다.</p><h3>02. Reader와 Writer</h3><p><code>Reader</code>와 <code>Writer</code>는 문자 단위 입출력 스트림에서 가장 기본이 되는 클래스로 모두 추상 클래스이다. 즉, <code>Reader</code>와 <code>Writer</code>는 객체화가 될수 없다.<br><code>Reader</code>와 <code>Writer</code>는 <code>InputStream</code>과 <code>OutputStream</code>과 사용법이 거의 비슷하다. 다만, 바이트 단위 입출력 스트림은 바이트나 바이트의 배열을 읽고 쓰는 것에 비해서, 문자 단위 입출력 스트림은 문자나 문자 배열을 읽고 쓴다.</p><p><code>Reader</code>와 <code>Writer</code> 클래스는 추상 클래스로 객체화할 수 없다. 하지만 앞서 배웠던 것처럼 <code>Reader</code>와 <code>Writer</code> 클래스는 부모 클래스로서 중요한 의미가 있다.<br><code>Reader</code>와 <code>Writer</code>는 객체화 될 수 없지만 부모클래스로서 다음과 같이 사용할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader r = new FileReader(&quot;a.txt&quot;);</span><br></pre></td></tr></table></figure><h3>03. InputStreamReader와 OutputStreamWriter</h3><p>InputStreamReader는 Reader를 OutputStreamWriter는 Writer를 상속받는다. 즉 문자 단위 입출력에 필요한 클래스다. 하지만 두 클래스는 각각 InputStream과 OutputStream을 생성자에서 받아들인다.</p><p><a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지의 IO 클래스에서 중요한 것은 생성자이다. 또한 생성자가 중요한 이유는 생성자에 전달한 인자가 무엇이냐에 따라서 읽어 들여야 할 대상과 써야 할 대상이 달라진다. 즉, InputStreamReader는 바이트 단위로 읽어 들이는 InputStream을 통해 데이터를 읽어 들여 문자 단위로 읽어 들이는 방식으로 변형한다.<br>또 OutputStreamWriter는 바이트 단위로 쓰는 OutputStream을 이용해서 문자 단위로 쓰는 것을 바이트 단위로 쓰도록 변형한다는 것을 의미한다.</p><p>InputStreamReader의 동작 과정</p><p><code>읽어야 할 대상 -&gt; InputStream -&gt; InputStreamReader -&gt; 메소드</code></p><p>OutputStreamWriter의 동작 과정</p><p><code>써야 할 대상 &lt;- OutputStream &lt;- OutputStreamWriter &lt;- 메소드</code></p><h3>1. 문자 단위로 파일 내용을 읽어 들여 화면에 출력하기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class StreamReaderTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        if(args.length != 1)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Use : Java StreamReaderTest FileName&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = null;</span><br><span class="line">        InputStreamReader isr = null;</span><br><span class="line">        OutputStreamWriter osw = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            fis = new FileInputStream(args[0]);</span><br><span class="line">            isr = new InputStreamReader(fis);</span><br><span class="line">            osw = new OutputStreamWriter(System.out);</span><br><span class="line">            char[] buffer = new char[512];</span><br><span class="line">            int readCount = 0;</span><br><span class="line">            while ( ( readCount = isr.read(buffer) ) != -1 )</span><br><span class="line">            &#123;</span><br><span class="line">                osw.writer(buffer, 0, readCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">                isr.close();</span><br><span class="line">                osw.close();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>파일의 내용을 읽으려고 FileInputStream을 사용하고 화면에 출력하려고 System.out을 사용할 것이다. 그렇지만 각깍 클래스들은 바이트 단위 IO 클래스이다. 따라서 문자 단위로입출력을 하려면 InputStreamReader와 OutputStreamWriter를 이용해서 문자 단위 입출력으로 변환해야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = null;</span><br><span class="line">InputStreamReader isr = null;</span><br><span class="line">OutputStreamWriter osw = null;</span><br></pre></td></tr></table></figure><p>FileInputStream을 통해서 읽어 들이는 InputStreamReader를 생성하고 System.out을 통해서 출력하는 OutputStreamWriter를 생성한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char[] buffer = new char[512];</span><br><span class="line">int readCount = 0;</span><br><span class="line">while ( ( readCount = isr.read(buffer) ) != -1 )</span><br><span class="line">&#123;</span><br><span class="line">    osw.writer(buffer, 0, readCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputStreamReader의 Read() 메소드를 이용해 문자 배열 형태로 읽은 후 OutputStreamWriter에 있는 write() 메소드를 이용해서 문자 배열 값을 출력한다. InputStreamReader는 내부적으로 FileInputStream을 이용해서 읽어들이고 OutputStreamWriter는 내부적으로 System.out을 사용해서 출력한다.</p><h3>04. FileReader와 FileWriter</h3><p>FileReader와 FileWriter는 각각 InputStreamReader와 OutputStreamWriter와 기능이나 사용법이 유사하다. 다른 점이라면 문자 단위 출력과 바이트 단위 출력이 다르다는 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = null;</span><br><span class="line">FileWriter fw = null;</span><br><span class="line">try&#123;</span><br><span class="line">    fr = new FileReader(args[0]);</span><br><span class="line">    fw = new FileWriter(args[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>args[0]으로 지정한 파일로부터 읽어 들이는 FileReader 객체와 args[1]로 지정한 파일에 쓰는 FileWriter 객체를 생성한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char[] buffer = new char[512];</span><br><span class="line">int readCount = 0;</span><br><span class="line">while( ( readCount = fr.read() ) != -1 )</span><br><span class="line">&#123;</span><br><span class="line">    fw.write(buffer, 0, readCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileReader에 있는 read 메소드를 이용해서 배열 buffer에 파일로부터 문자열을 읽어들이고, FileWirter에 있는 write 메소드를 이용해서 buffer에 저장된 문자열을 파일에 출력한다.</p><h3>05. BufferedReader와 BufferedWriter</h3><p><code>BufferedReader</code>와 <code>BufferedWriter</code>는 이름 그대로 Buffer에 있는 IO 클래스다. Buffer란 다른 말로 메모리를 의미하는데, 메모리가 있기 때문에 입출력 시에 병목 현상을 줄일 수 있다. 빠른 속도로 읽어들이거나, 빠른속도로 쓰고자 할때 읽어 들여야 할 대상과 써야 할 대상 간의 속도차이 때문에 병목현상이 일어날 수 있기 때문이다. 따라서 중간에 버퍼를 둠으로써 읽기와 쓰기 시 성능이 향상될 수 있다.</p><p>또한 BufferedReader의 경우에는 한 줄씩 읽어 들이는 readLine이라는 메소드가 있기 때문에 한줄씩 읽어 들이기에도 유리하다. 다만 주의해야 할 점이 있는데 BufferedWriter의 경우 버퍼가 있기 때문에 반드시 flush() 메소드를 이용하거나 close() 메소드를 호출해줘야 한다. 그렇지 않고 프로그램을 종료하게 되면 버퍼에 내용을 완전하게 쓸 수 없게 된다.</p><p>특히 네트워크 프로그래밍의 경우에는 write() 메소드를 호출한 후에는 반드시 flush() 메소드를 호출해줘야 한다.</p><p>앞서 작성한 04. FileReader와 FileWriter는 버퍼가 없기 때문에 병목현상이 발생할 수 있다. 짧은 파일일 경우에는 그다지 영향을 받지 않지만, 큰 파일을 복사할 때에는 속도가 느릴 수 있다. 이를 해결하려면 BufferedReader와 BufferedWriter를 이용해서 IO 클래스에게 버퍼를 추가하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class BufferedFileCopy</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        if(args.length != 2)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Use : Java FileCopy FileName1, FileName2&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileReader fr = null;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        FileWriter fw = null;</span><br><span class="line">        BufferedWriter bw = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            fr = new FileReader(args[0]);</span><br><span class="line">            br = new BufferedReader(fr);</span><br><span class="line">            fw = new FileWirter(args[1]);</span><br><span class="line">            bw = new BufferedWriter(fw);</span><br><span class="line"></span><br><span class="line">            char[] buffer = new char[512];</span><br><span class="line">            int readCount = 0;</span><br><span class="line">            while( ( readCount = br.read(buffer) ) != -1 )</span><br><span class="line">            &#123;</span><br><span class="line">                bw.write(buffer, 0, readCount);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;File Copy Complete...&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                br.close();</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; catch (Exception e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fr = new FileReader(args[0]);</span><br><span class="line">br = new BufferedReader(fr);</span><br><span class="line">fw = new FileWirter(args[1]);</span><br><span class="line">bw = new BufferedWriter(fw);</span><br></pre></td></tr></table></figure><p>FileReader 객체를 BufferedReader의 인자로 지정해서 BufferedReader 객체를 생성하고, FileWriter 객체를 BufferedWriter의 인자로 지정해서 BufferedWriter 객체를 생성했다. 이는 FileReader를 BufferedReader로 감싸므로 FileReader에게 Buffer를 가진 것 같은 효과를 준 것이다.</p><h3>06. PrintWriter</h3><h3>07. CharArrayReader와 CharArrayWriter</h3><h3>08. StringReader와 StringWriter</h3><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 5장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;05. 문자 스트림 : 문자 단위 IO 클래스&lt;/h3&gt;
&lt;p&gt;문자 단위 IO클래스는 자바가 처음 등장했을떄에는 포함되지 않았다. 이후, 2바이트 문화권에서 2바이트 문자를 입출력하는 클래스를 요청하게 되었고 나중에 추가하게 된 것이다.&lt;/p&gt;

      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Char" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Char/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="Char" scheme="http://jungha-cho.github.io/tags/Char/"/>
    
  </entry>
  
  <entry>
    <title>08. TCP 프로그래밍 02. 에코 클라이언트/서버 프로그래밍</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIONetworkProgrammingEchoserver/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIONetworkProgrammingEchoserver/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:47:43.518Z</updated>
    
    <content type="html"><![CDATA[<h3>08. TCP 프로그래밍</h3><h3>02. 에코 클라이언트/서버 프로그래밍.</h3><p>에코는 말 그대로 메아리를 의미한다. 클라이언트가 보낸 데이터를 서버 쪽에서 받아들여, 클라이언트에게 그대로 다시 보내주는 것을 의미한다.</p><p>에코 서버</p><ol><li>1001번 포트에서 동작하는 ServerSocket을 생성한다.</li><li>ServerSocket의 accept() 메소드를 실행해서 클라이언트의 접속을 대기한다.</li><li>클라이언트가 접속할 경우 accept() 메소드는 socket 객체를 반환한다.</li><li>반환 받은 Socket으로부터 InputStream과 OutputStream을 구한다.</li><li>InputStream은 BufferedReader 형식으로 변환하고OutputStream은 PrintWriter 형식으로 변환한다.</li><li>BufferedReader의 readLine() 메소드를 이용해서 클라이언트가 보내는 문자열 한줄을 읽어 들인다.</li><li>6에서 읽은 문자열을 PrintWriter에 있는 println()을 이용해 다시 클라이언트로 전송한다.</li><li>6,7 작업을 반복한다. 클라이언트가 접속을 종료하게 되면 BufferedReader에 있는 readLine은 null을 반환한다.</li><li>IO 객체와 소켓의 Close() 메소드를 호출한다.</li></ol><p>에코 클라이언트</p><ol><li>Socket 생성자에 서버의 IP와 서버의 동작 포트 값(10001)을 인자로 넣어 생성한다. 소켓이 성공적으로 생성되었다면, 서버와 접속이 성공적으로 되었다는 것을 의미한다.</li><li>생성된 Socket으로부터 InputStream과 OutputStream을 구한다.</li><li>InputStream은 BufferedReader 형식으로 변환하고 OutputStream은 PrintWriter 형식으로 변환한다.</li><li>키보드로부터 한 줄씩 입력 받는 BufferedReader 객체를 생성한다.</li><li>키보드로부터 한 줄을 입력 받아 PrintWriter에 있는 println()메소드를 이용해서 서버에게 전송한다.</li><li>서버가 다시 반환하는 문자열을 BufferedReader에 있는 readLine() 메소드를 이용해서 읽어 들인다. 읽어 들인 문자열은 화면에 출력한다.</li><li>4, 5, 6을 키보드로부터 quit 문자열을 입력 받을대까지 반복한다.</li><li>키보드로부터 quit 문자열이 입력되면 IO 객체와 소켓의 close() 메소드를 호출한다.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class EchoClient&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Socket sock = new Socket(&quot;127.0.0.1&quot;, 10001);</span><br><span class="line">            BufferedReader keyBoard = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">            OutputStream out = sock.getOutputStream();</span><br><span class="line">            InputStream in = sock.getInputStream();</span><br><span class="line">            PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));</span><br><span class="line">            BufferedReader br = new BufferedReader(new InputStreamReader(in));</span><br><span class="line">            String line = null;</span><br><span class="line">            while((line = keyBoard.readLine()) != null)&#123;</span><br><span class="line">                if(line.equals(&quot;quit&quot;)) break;</span><br><span class="line">                pw.println(line);</span><br><span class="line">                pw.flush();</span><br><span class="line">                String echo = br.readLine();</span><br><span class="line">                System.out.println(&quot;서버로부터 전달받은 문자열 :&quot; +echo);</span><br><span class="line">            &#125;</span><br><span class="line">            pw.close();</span><br><span class="line">            br.close();</span><br><span class="line">            sock.close();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class EchoServer&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            ServerSocket serverSocket = new ServerSocket(10001);</span><br><span class="line">            System.out.println(&quot;접속을 기다립니다....&quot;);</span><br><span class="line"></span><br><span class="line">            Socket sock = serverSocket.accept();</span><br><span class="line">            InetAddress inetAddr = sock.getInetAddress();</span><br><span class="line">            System.out.println(inetAddr.getHostAddress() + &quot; 로 부터 접속했습니다.&quot;);</span><br><span class="line"></span><br><span class="line">            OutputStream out = sock.getOutputStream();</span><br><span class="line">            PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));</span><br><span class="line"></span><br><span class="line">            InputStream in = sock.getInputStream();</span><br><span class="line">            BufferedReader br = new BufferedReader(new InputStreamReader(in));</span><br><span class="line"></span><br><span class="line">            String line = null;</span><br><span class="line">            while((line = br.readLine()) != null)&#123;</span><br><span class="line">                System.out.println(&quot;클라이언트로 부터 전송받은 문자열 : &quot;+line);</span><br><span class="line">                pw.println(line);</span><br><span class="line">                pw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            pw.close();</span><br><span class="line">            br.close();</span><br><span class="line">            sock.close();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>4. 에코 클라이언트와 에코 서버의 문제점</h3><p>이 에코 서버의 문제점은 server는 하나의 클라이언트 접속만을 처리할 수 있다는 것이다. accept()로 대기하고 있다가 클라이언트의 접속 요청이 오면 클라이언트와 통신할 수 있는 소켓을 반환한 후, 다시 accept()하지 않기 때문이다.</p><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 8장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;08. TCP 프로그래밍&lt;/h3&gt;
&lt;h3&gt;02. 에코 클라이언트/서버 프로그래밍.&lt;/h3&gt;
&lt;p&gt;에코는 말 그대로 메아리를 의미한다. 클라이언트가 보낸 데이터를 서버 쪽에서 받아들여, 클라이언트에게 그대로 다시 보내주는 것을 의미한다.&lt;/p&gt;

      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="TCP" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/TCP/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="TCP" scheme="http://jungha-cho.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>08. TCP 프로그래밍</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIONetworkProgrammingTCPProgramming/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIONetworkProgrammingTCPProgramming/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:47:55.428Z</updated>
    
    <content type="html"><![CDATA[<h2>08. TCP 프로그래밍</h2><h3>1. 클라이언트의 접속 대기</h3><p>서버쪽에서는 클라이언트의 접속을 기다리기위해 ServerSocket 객체의 accept() 메소드를 실행해서 대기하게 된다. 서버 쪽에서는 이 accept()메소드에서 멈추게 되는데 이를 블로킹 메소드라고 한다.</p><h3>2. 클라이언트 접속</h3><p>accept()로 대기중인 서버라면 클라이언트는 서버로 접속할 수 있다. 클라이언트에서 서버 정보를 담은 Socket만 생성하게 되면 내부적으로 알아서 접속이 일어난다. 성공적으로 Socket 객체가 생성되었다면, 서버의 accept() 메소드는 클라이언트에 대한 Socket 객체를 반환한다.</p><p><code>Socket socket = new Socket(&quot;192.168.0.1&quot;, 10001);</code></p><p>서버 측 Accept()<br><code>Socket socket = server.accept();</code></p><h3>3. Socket으로부터 InputStream과 OutputStream 구하기</h3><p>클라이언트에서 서버로 접속이 성공햇다면 서버와 클라이언트는 각각 연결된 Socket을 가지게 된다. 이때 소켓을 이용한 Stream을 생성해 통신하게 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">InputStream in = socket.getInputStream();</span><br></pre></td></tr></table></figure><p>InputStream과 OutputStream을 직접 이용할 수도 있지만 수많은 다른 IO에 인자로 전달해 사용하는 경우가 많다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));</span><br><span class="line">BufferedReader br = new BufferedReader(new OutputStreamReader(in));</span><br></pre></td></tr></table></figure><h3>4. 접속 끊기</h3><p>소켓의 연결이 끊기기 전까지 Stream을 통해 통신이 가능하다. 소켓 연결을 끊기 전에 이 소켓을 통해 얻은 IO도 반드시 close() 메소드를 이용해서 종료해야 한다.</p><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 8장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;08. TCP 프로그래밍&lt;/h2&gt;
&lt;h3&gt;1. 클라이언트의 접속 대기&lt;/h3&gt;
&lt;p&gt;서버쪽에서는 클라이언트의 접속을 기다리기위해 ServerSocket 객체의 accept() 메소드를 실행해서 대기하게 된다. 서버 쪽에서는 이 accept()메
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="TCP" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/TCP/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="TCP" scheme="http://jungha-cho.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>08. TCP 프로그래밍 03. 멀티스레드를 이용한 에코 서버</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIONetworkProgrammingThreadEcho/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIONetworkProgrammingThreadEcho/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:48:12.250Z</updated>
    
    <content type="html"><![CDATA[<h3>03. 멀티스레드를 이용한 에코 서버</h3><h3>1. 멀티스레드 에코 서버 프로그래밍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class EchoThreadServer &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerSocket server = new ServerSocket(10001);</span><br><span class="line">            System.out.println(&quot;접속을 기다립니다.&quot;);</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                Socket socket = server.accept();</span><br><span class="line">                EchoThread ethr = new EchoThread(socket);</span><br><span class="line">                ethr.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EchoThread extends Thread&#123;</span><br><span class="line">    private Socket sock;</span><br><span class="line">    public EchoThread(Socket socke)&#123;</span><br><span class="line">        this.sock = socke;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            InetAddress inetAddr = sock.getInetAddress();</span><br><span class="line">            System.out.println(inetAddr.getHostAddress() + &quot;로 부터 접속했습니다.&quot;);</span><br><span class="line">            OutputStream out = sock.getOutputStream();</span><br><span class="line">            InputStream in = sock.getInputStream();</span><br><span class="line">            PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));</span><br><span class="line">            BufferedReader br = new BufferedReader(new InputStreamReader(in));</span><br><span class="line">            String line = null;</span><br><span class="line">            while((line = br.readLine()) != null)&#123;</span><br><span class="line">                System.out.println(&quot;클라이언트로부터 전송받은 문자열 : &quot;+line);</span><br><span class="line">                pw.println(line);</span><br><span class="line">                pw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            pw.close();</span><br><span class="line">            br.close();</span><br><span class="line">            sock.close();</span><br><span class="line">        &#125;catch(Exception ex)&#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>05. ChatServer, Client</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class ChatServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerSocket server = new ServerSocket(10001);</span><br><span class="line">            System.out.println(&quot;접속을 기다립니다.&quot;);</span><br><span class="line">            HashMap hm = new HashMap();</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                Socket sock = server.accept();</span><br><span class="line">                ChatThread chatthread = new ChatThread(sock, hm);</span><br><span class="line">                chatthread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ChatThread extends Thread &#123;</span><br><span class="line">    private Socket sock;</span><br><span class="line">    private String id;</span><br><span class="line">    private BufferedReader br;</span><br><span class="line">    private HashMap hm;</span><br><span class="line">    private boolean initFlag = false;</span><br><span class="line">    public ChatThread(Socket sock, HashMap hm) &#123;</span><br><span class="line">        this.sock = sock;</span><br><span class="line">        this.hm = hm;</span><br><span class="line">        try &#123;</span><br><span class="line">            PrintWriter pw = new PrintWriter (new OutputStreamWriter(sock.getOutputStream()));</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(sock.getInputStream()));</span><br><span class="line">            id = br.readLine();</span><br><span class="line">            broadcast(id + &quot;님이 접속했습니다.&quot;);</span><br><span class="line">            System.out.println(&quot;접속한 사용자의 아이디는 &quot;+id+&quot;입니다.&quot;);</span><br><span class="line">            synchronized(hm) &#123;</span><br><span class="line">                hm.put(this.id, pw);</span><br><span class="line">            &#125;</span><br><span class="line">            initFlag = true;</span><br><span class="line">        &#125;catch(Exception ex) &#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            String line = null;</span><br><span class="line">            while((line = br.readLine()) != null) &#123;</span><br><span class="line">                if(line.equals(&quot;/quit&quot;)) break;</span><br><span class="line">                if(line.indexOf(&quot;/to &quot;) == 0)&#123;</span><br><span class="line">                    sendmsg(line);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    broadcast(id+&quot; : &quot;+line);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception ex) &#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            synchronized(hm)&#123;</span><br><span class="line">                hm.remove(id);</span><br><span class="line">            &#125;</span><br><span class="line">            broadcast(id + &quot; 님이 접속 종료했습니다.&quot;);</span><br><span class="line">            try&#123;</span><br><span class="line">                if(sock != null) sock.close();</span><br><span class="line">            &#125;catch(Exception ex)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendmsg(String msg)&#123;</span><br><span class="line">        int start = msg.indexOf(&quot; &quot;) +1;</span><br><span class="line">        int end = msg.indexOf(&quot; &quot;, start);</span><br><span class="line"></span><br><span class="line">        if(end != -1) &#123;</span><br><span class="line">            String to = msg.substring(start, end);</span><br><span class="line">            String msg2 = msg.substring(end+1);</span><br><span class="line">            Object obj = hm.get(to);</span><br><span class="line">            if(obj != null)&#123;</span><br><span class="line">                PrintWriter pw = (PrintWriter) obj;</span><br><span class="line">                pw.println(id + &quot; 님이 다음의 귓속말을 보내셨습니다 : &quot;+msg2);</span><br><span class="line">                pw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void broadcast(String msg)&#123;</span><br><span class="line">        synchronized(hm) &#123;</span><br><span class="line">            Collection collection = hm.values();</span><br><span class="line">            Iterator iter = collection.iterator();</span><br><span class="line">            while(iter.hasNext())&#123;</span><br><span class="line">                PrintWriter pw = (PrintWriter)iter.next();</span><br><span class="line">                pw.println(msg);</span><br><span class="line">                pw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class ChatClient &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        if(args.length != 2)&#123;</span><br><span class="line">            System.out.println(&quot;사용법 : java ChatClient id 접속할 서버 ip&quot;);</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Socket sock = null;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        PrintWriter pw = null;</span><br><span class="line">        boolean endflag = false;</span><br><span class="line">        try&#123;</span><br><span class="line">            sock = new Socket(args[1], 10001);</span><br><span class="line">            pw = new PrintWriter(new OutputStreamWriter(sock.getOutputStream()));</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(sock.getInputStream()));</span><br><span class="line">            BufferedReader keyboard = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">            pw.println(args[0]);</span><br><span class="line">            pw.flush();</span><br><span class="line"></span><br><span class="line">            InputThread it = new InputThread(sock, br);</span><br><span class="line">            it.start();</span><br><span class="line">            String line = null;</span><br><span class="line">            while((line = keyboard.readLine()) != null)&#123;</span><br><span class="line">                pw.println(line);</span><br><span class="line">                pw.flush();</span><br><span class="line">                if(line.equals(&quot;/quit&quot;))&#123;</span><br><span class="line">                    endflag = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;클라이언트의 접속을 종료합니다.&quot;);</span><br><span class="line">        &#125;catch(Exception ex) &#123;</span><br><span class="line">            if(!endflag)&#123;</span><br><span class="line">                System.out.println(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                if(pw != null) pw.close();</span><br><span class="line">            &#125;catch(Exception ex)&#123;&#125;</span><br><span class="line">            try&#123;</span><br><span class="line">                if(br != null) br.close();</span><br><span class="line">            &#125;catch(Exception ex)&#123;&#125;</span><br><span class="line">            try&#123;</span><br><span class="line">                if(sock != null) sock.close();</span><br><span class="line">            &#125;catch(Exception ex)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InputThread extends Thread &#123;</span><br><span class="line">    private Socket sock = null;</span><br><span class="line">    private BufferedReader br = null;</span><br><span class="line">    public InputThread(Socket sock, BufferedReader br)&#123;</span><br><span class="line">        this.sock = sock;</span><br><span class="line">        this.br = br;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            String line = null;</span><br><span class="line">            while((line = br.readLine()) != null) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception ex)&#123;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                if(br != null) br.close();</span><br><span class="line">            &#125;catch(Exception ex) &#123;&#125;</span><br><span class="line">            try&#123;</span><br><span class="line">                if(sock != null) sock.close();</span><br><span class="line">            &#125;catch(Exception ex) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 8장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;03. 멀티스레드를 이용한 에코 서버&lt;/h3&gt;
&lt;h3&gt;1. 멀티스레드 에코 서버 프로그래밍&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="TCP" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/TCP/"/>
    
    
      <category term="Thread" scheme="http://jungha-cho.github.io/tags/Thread/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="TCP" scheme="http://jungha-cho.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>07. 네트워크 프로그래밍 기초 01. 소켓이란</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIONetworkProgrammingbasicsocket/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIONetworkProgrammingbasicsocket/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:43:24.275Z</updated>
    
    <content type="html"><![CDATA[<h3>1. 소켓의 세 가지 형식</h3><p>SOCK_STREAM, SOCK_DGRAM, SOCK_RAW가 있다. 이 중에서 SOCK_RAW는 자바에서 보안상 지원하지 않는다.</p><p><code>SOCK_STREAM</code> : 바이트를 주고 받을 수 있는 스트림(Stream) 통신을 구현할 수 있게 해주는 소켓으로 양방향 통신이 가능하다.<br><code>SOCK_DGRAM</code> : 데이터그램 통신용 소켓으로 SOCK_STREAM과 마찬가지로 양방향 통신이 가능하다.<br><code>SOCK_RAW</code> : RAW 방법을 이용하는 대표적인 프로그램으로는 핑(PING)이 있다. 핑은 내부적으로 ICMP(Internet Control Message Protocol)을 사용하는데, ICMP 패킷은 SOCK_RAW 형식의 소켓만을 지원한다. 이런 이유로 자바에서는 제대로 된 핑 프로그램을 구현할 수 없다. 대부분의 자바 기반 핑 프로그램은 흉내 내기일 뿐이다. SOCK_RAW의 경우 좀더 높은 수준의 제어를 하고 싶은 사용자를 위한 것으로, 패킷(Packet)을 전달할 때 패킷이 지나갈 경로까지도 지정할 수 있다. 이는 패킷을 받는 쪽에서 잘못된 경로의 패킷을 전송할 수도 있다는 것을 의미한다. 마치, 이미 접근을 허락 받은 클라이언트인 것처럼 잘못된 내용을 담아서 전송할 수 있다는 것이다. 이러한 이유로 보안상 문제가 발생할 수 있기 때문에 자바에서는 SOCK_RAW를 지원하지 않는다.</p><p><code>SOCK_STREAM</code> 형식을 이용하는 통신 방법을 다른 말로 TCP(Transfer Control Protocol)이라고 한다.</p><p><code>SOCK_DGRAM</code> 형식을 이용하는 통신 방법은 UDP(User Datagram Protocol)이라고 한다.</p><h3>2. 인터넷 주소와 포트</h3><h3>02. InetAddress 클래스를 활용한 도메인과 IP 변환</h3><p><a href="http://java.net" target="_blank" rel="noopener">java.net</a> 패키지에는 IP와 관련된 중요한 클래스가 있다. InetAddress는 도메인 주소를 IP 주소를 변환하거나 반대로 IP 주소를 도메인 주소를 변경할 수 있으며, 문자열이나 바이트 배열 형태로 IP 주소에 대한 정보를 얻을 수도 있다. 또한 현재 컴퓨터의 이름도 구할 수 있다.</p><h3>1. InetAddress 클래스를 이용한 nslookup 명령 구현</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line"></span><br><span class="line">public class NSLookup</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        if(args.length != 1)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;IP address or Host name is input args&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InetAddress inetaddr[] = null;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            inetaddr = InetAddress.getAllByName(args[0]);</span><br><span class="line">        &#125;catch(UnknownHostException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0 ; i &lt; inetaddr.length ; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(inetaddr[i].getHostName());</span><br><span class="line">            System.out.println(inetaddr[i].getHostAddress());</span><br><span class="line">            System.out.println(inetaddr[i].toString());</span><br><span class="line">            System.out.println(&quot;--------------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>2. InetAddress 클래스를 이용한 로컬 컴퓨터명과 IP 구하기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line"></span><br><span class="line">public class NSLookupLocal</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        InetAddress inetaddr = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            inetaddr = InetAddress.getLocalHost();</span><br><span class="line">        &#125;catch (UnknownHostException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(inetaddr.getHostName());</span><br><span class="line">        System.out.println(inetaddr.getHostAddress());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;byte[] ip print&quot;);</span><br><span class="line">        byte[] ip = inetaddr.getAddress();</span><br><span class="line">        for(int i = 0; i &lt; ip.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print((int)ip[i]);</span><br><span class="line">            if(i != ip.length -1)</span><br><span class="line">                System.out.print(&quot;.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 7장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;1. 소켓의 세 가지 형식&lt;/h3&gt;
&lt;p&gt;SOCK_STREAM, SOCK_DGRAM, SOCK_RAW가 있다. 이 중에서 SOCK_RAW는 자바에서 보안상 지원하지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt; : 바이트를 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Socket" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Socket/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="Socket" scheme="http://jungha-cho.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>07. 네트워크 프로그래밍 기초 - 개요</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIONetworkProgrammingbasic/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIONetworkProgrammingbasic/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:47:25.254Z</updated>
    
    <content type="html"><![CDATA[<p>실무 개발자 중 프로그래밍은 하는데, 개념이 약한 경우, 반면 개념은 확실한데 실제 프로그래밍이 약한 경우. 이 두 경우 모두 바람직한 현상은 아니다. 하지만 그래도 후자가 발전 가능성이 더 높을것 같다.</p><p>책에서는 &quot;내공이 깊으면 연공이 자유롭다&quot;라는 말을 한다. 개발에 빗대어 보자면 개념이 확실하다면 실제 프로그래밍을 쉽게 할수 있다는것 같다. 이 책에서는 개발단에서 일어나는 일 뿐만 아니라 기반 지식을 중요하게 강조하고 있다.</p><p>네트워크 프로그래밍을 하려면 운영체제를 잘 알 필요가 있다. 유닉스 시스템에서 프로그래밍을 자주하는 프로그래머라면 유닉스 시스템의 네트워크 방법에 대한 이해가 필요하고 윈도우 시스템에서 프로그래밍을 자주하는 프로그래머라면 윈도우 시스템의 네트워크 방법에 대한 이해를 필요로 한다.</p><p>특히 자바 프로그램의 경우 유닉스 시스템에서 운용될 때가 많기 때문에 이러한 운영체제에 대한 기본적인 지식이 상당히 중요하다. 또한 자바는 시스템에 대해 비종속적이라고 말을 하는데, 이는 자바 개발자가 여러 가지 종류의 운영체제에서 개발할 수 있어야 한다는 의미다.</p><p>프로그램 언어는 시스템에 대해서 비종속적인데, 개발자가 종속적이라면 어떻겠는가?</p><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 7장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;실무 개발자 중 프로그래밍은 하는데, 개념이 약한 경우, 반면 개념은 확실한데 실제 프로그래밍이 약한 경우. 이 두 경우 모두 바람직한 현상은 아니다. 하지만 그래도 후자가 발전 가능성이 더 높을것 같다.&lt;/p&gt;
&lt;p&gt;책에서는 &amp;quot;내공이 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
  </entry>
  
  <entry>
    <title>06. 객체 스트림 개요</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOObjectStream/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOObjectStream/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:48:22.548Z</updated>
    
    <content type="html"><![CDATA[<p>객체 안에 저장된 내용을 파일로 저장하거나 네트워크로 전송하려면 많은 노력이 필요하다. 객체에 있는 필드의 내용을 일일이 읽어 들여 하나씩 저장하거나 전송을 해야 하기 떄문이다. 그리고 네트워크 프로그래밍이라면 반대 쪽에선 전송한 데이터를 읽어 들이기 위해서 전송한 순서대로 읽어 들여야 한다는 번거로움도 있다.</p><p>이런 문제를 쉽게 해결할 수 있게 해주는 것이 객체 스트림이다. 그렇지만 객체 스트림의 경우에는 앞으로 배우겠지만, 마샬링(marshaling)과 언마샬링(Unmarshaling)이라는 작업을 해야하므로 추가적인 과부하가 발생할 수 있다는 문제가 있다. 하지만 요즘의 프로그래밍의 추세는 과부하보다는 좀더 손쉬운 프로그래밍, 좀더 쉽게 유지보수 할 수 있는 방법론을 선호하기 때문에 이러한 문제는 크게 부각되지 않는다.</p><p>이런 이유로 객체를 파일에 전송하거나 네트워크를 통해서 전송할 떄 객체 스트림을 사용한다. 객체 스트림을 꼭 알아야할 중요한 이유가 한 가지 더 있는데, 객체 스트림은 자바 RMI의 기반 기술이라는 것이다. 따라서 자바 RMI를 이해하려면 객체 스트림에 대한 확실한 이해가 필요하다.</p><p>자바 RMI는 또한 EJB의 기반 기술이기도 하다. 즉, EJB를 학습하고자 하는 독자라면 객체 스트림, 자바 RMI를 순서대로 공부한 후 EJB를 공부한다면 개념적으로 훨씬 쉽게 학습할 수 있을 것이다. 반대로 얘기하자면, EJB를 사용한다는 것은 내부적으로 객체 스트림을 사용한다는 것을 의미한다. 그리고 RMI를 사용한다는 것은 내부적으로 객체 스트림을 사용한다는 의미이다.</p><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 5장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;객체 안에 저장된 내용을 파일로 저장하거나 네트워크로 전송하려면 많은 노력이 필요하다. 객체에 있는 필드의 내용을 일일이 읽어 들여 하나씩 저장하거나 전송을 해야 하기 떄문이다. 그리고 네트워크 프로그래밍이라면 반대 쪽에선 전송한 데이터를 읽어 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Stream" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Stream/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
  </entry>
  
  <entry>
    <title>06. 03. 객체 스트림 소개</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOObjectStream3/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOObjectStream3/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:48:37.716Z</updated>
    
    <content type="html"><![CDATA[<p>객체가 전송되거나 쓴다고 하면, 보통 데이터만 해당된다고 생각할 수 있다. 객체가 전송된다는 것은 애플릿, 윈도우 등도 전송될 수 있다는 것을 의미한다.</p><p>객체 전송은 다음과 같은 순서를 지켜야 한다.</p><ol><li>데이터를 특정 통신 채널로 보낼 수 있는 형태로 바꾼다. 이를 마샬링(marshaling)이라고 한다.</li><li>변환된 데이터를 전송하거나 쓴다.</li><li>변환된 데이터를 읽어 들여 원래의 형태로 변환한다. 이를 언마샬링(marshaling)이라고 한다.</li></ol><p><code>마샬링</code></p><p>마샬링이란 데이터를 바이트의 흐름으로 만들어 TCP와 같은 통신 채널을 통해서 전송하거나 스트림으로 써줄 수 있는 형태로 바꾸는 과정을 말한다.<br>마샬링 될 수 있는 데이터는 기본 자료형 ( boolean, byte, char, short, int, long, float, double)과 java.io.serializable 인터페이스를 구현하고 있는 객체만 가능하다.<br>기본 자료형이 정수일 경우에는 4바이트로 쪼개져서 전송된다. 하지만 객체일 경우에는 이보다 훨씬 복잡한 과정을 거치게 되는데, 객체는 내부적으로 다른 객체를 참조할 수 있기 때문이다. 객체의 스트림은 객체 내부적인 참조까지도 유지하기 위한 방법을 제공해준디ㅏ.<br>마샬링은 객체 스트림인 ObjectOutputStream에 의해 제공된다. 그리고 ObjectOutputStream에 의해서 객체는 직렬화되어 전달된다. 객체 직렬화(Object Serialization)란 실제로 객체를 마샬링한다는 의미가 있다.</p><p><code>전송</code></p><p>데이터를 발신지에서 목적지로 전달하는 과정을 말한다. 전송을 위해서 객체 스트림은 바이트 기반의 표준 스트림을 이용하게 된다.<br>네트워크에 대한 전송뿐만 아니라 파일에 쓰기를 할 경우에도 객체 스트림은 바이트 기반의 표준 스트림을 이용하게 된다.</p><p><code>언마샬링</code></p><p>언마샬링이란 마샬링과 반대로 전송받은 데이터를 원래의 형태로 변환하는 과정을 뜻한다. 그리고 전달받은 데이터는 원래 형태로 변환될수 있는 충분한 내용을 포함하고 있다. 객체 직렬화와 반대로 이경우에는 역직렬화(deserialization)이라고 하며, ObjectInputStream에 의해 제공된다. ObjectOutputStream과 ObjectInputStream은 앞서 설명한 것처럼 객체를 직렬화하고 역직렬화 하기위해서 사용한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class Book implements Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private String isbn;</span><br><span class="line">    private String title;</span><br><span class="line">    private String author;</span><br><span class="line">    private int price;</span><br><span class="line"></span><br><span class="line">    public Book(String isbn, String title, String author, int price)</span><br><span class="line">    &#123;</span><br><span class="line">        this.isbn = isbn;</span><br><span class="line">        this.title = title;</span><br><span class="line">        this.author = author;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getIsbn() &#123; return isbn; &#125;</span><br><span class="line">    public String setIsbn(String isbn) &#123; this.isbn = isbn; &#125;</span><br><span class="line">    public String getTitle() &#123; return title; &#125;</span><br><span class="line">    public String setTitle(String title;) &#123; this.title = title; &#125;</span><br><span class="line">    public String getAuthor() &#123; return author; &#125;</span><br><span class="line">    public String setAuthor(String autho) &#123; this.author = author; &#125;</span><br><span class="line">    public String getPrice() &#123; return price; &#125;</span><br><span class="line">    public String setPrice(int price) &#123; this.price = price; &#125;</span><br><span class="line"></span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return getIsbn() + &quot;, &quot; + getTitle() + &quot;, &quot; + getAuthor() + &quot;, &quot; + getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Book 클래스는 마샬링되기 위해서 java.io.Serializable 인터페이스를 구현하고 있다. Book 클래스에 있는 필드는 java.lang.String 형과 기본형인 int로 구성되어 있기 때문에 모두 직렬화할 수 있다.</p><p>booklist.dat 직렬화</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class BookObjectOutputTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FileOutputStream fout = null;</span><br><span class="line">        ObjectOutputStream oos = null;</span><br><span class="line"></span><br><span class="line">        ArrayList list = new ArrayList();</span><br><span class="line">        Book b1 = new Book(&quot;a001&quot;, &quot;자바완성&quot;, &quot;홍길동&quot;, 10000);</span><br><span class="line">        Book b2 = new Book(&quot;a002&quot;, &quot;스트럿츠&quot;, &quot;김유신&quot;, 20000);</span><br><span class="line">        Book b3 = new Book(&quot;a003&quot;, &quot;기초 EJB&quot;, &quot;김성박&quot;, 25000);</span><br><span class="line">        list.add(b1);</span><br><span class="line">        list.add(b2);</span><br><span class="line">        list.add(b3);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            fout = new FileOutputStream(&quot;booklist.dat&quot;);</span><br><span class="line">            oos = new ObjectOutputStream(fout);</span><br><span class="line"></span><br><span class="line">            oos.writeObject(list);</span><br><span class="line">            oos.reset();</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Saved&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">                fout.close();</span><br><span class="line">            &#125; catch (Exception e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>booklist.dat 역직렬화</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class BookObjectInputTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FileInputStream fin = null;</span><br><span class="line">        ObjectInputStream ois = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            fin = new FileInputStream(&quot;booklist.dat&quot;);</span><br><span class="line">            ois = new ObjectInputStream(fin);</span><br><span class="line"></span><br><span class="line">            ArrayList list = (ArrayList) ois.readObject();</span><br><span class="line">            Book b1 = (Book) list.get(0);</span><br><span class="line">            Book b2 = (Book) list.get(1);</span><br><span class="line">            Book b3 = (Book) list.get(2);</span><br><span class="line"></span><br><span class="line">            System.out.println(b1.toString());</span><br><span class="line">            System.out.println(b2.toString());</span><br><span class="line">            System.out.println(b3.toString());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">                fin.close();</span><br><span class="line">            &#125; catch (Exception e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>05. 마샬링하고 싶지 않은 필드에 대한 처리</h3><p>기본 자료형과 java.io.Serializable 인터페이스를 구현한 객체의 경우 마샬링된다고 했다. 하지만 특별한 경우에는 필드가 마샬링되지 않기를 원할 때도 있다. 예를 들어, 보안상 중요한 필드일 경우에 그렇다.</p><p>이때는 자바의 키워드인 transient를 사용하면 된다.</p><p>private String author;    --&gt;    transient private String author;</p><h3>06. 윈도우 저장과 읽기</h3><h3>07. ObjectOutputStream 클래스의 생성자와 메소드</h3><p><code>ObjectOutputStream</code> 클래스는 객체를 직렬화하기 위해서 사용한다. <code>ObjectOutputStream</code> 클래스는 다음과 같이 선언되어 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants</span><br></pre></td></tr></table></figure><p><code>ObjectOutputStream</code> 클래스에는 생성자가 두 가지인데, 보통 <code>OutputStream</code>을 인자로 전달받는 생성자가 사용된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ObjectOutputStream(OutputStream out) throws IOException</span><br></pre></td></tr></table></figure><h3>08. ObjectInputStream 클래스의 생성자와 메소드</h3><p><code>ObjectInputStream</code>은 전소앋은 데이터를 역직렬화할 경우에 사용된다. <code>ObjectInputStream</code>은 다음과 같이 선언되어 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants</span><br></pre></td></tr></table></figure><p>ObjectInputStream 클래스에 있는 생성자도 두가지인데 보통 InputStream을 인자로 전달받는 생성자를 사용한다. 선언은 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ObjectInputStream(InputStream in) throws IOException</span><br></pre></td></tr></table></figure><h3>09. 객체 스트림의 예외</h3><p>객체 스트림은 직렬화와 역직렬화 과정과 관련해서 여러 예외를 발생시킬 수 있다.</p><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 6장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;객체가 전송되거나 쓴다고 하면, 보통 데이터만 해당된다고 생각할 수 있다. 객체가 전송된다는 것은 애플릿, 윈도우 등도 전송될 수 있다는 것을 의미한다.&lt;/p&gt;
&lt;p&gt;객체 전송은 다음과 같은 순서를 지켜야 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;데이터를 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Stream" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Stream/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
  </entry>
  
  <entry>
    <title>06. 01. 객체 스트림 : 생각해볼 문제와 간단한 예제</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOObjectStream2/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOObjectStream2/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:48:29.453Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vector v = new Vector();</span><br><span class="line">Vector v1 = new Vector();</span><br><span class="line">Vector v2 = new Vector();</span><br><span class="line">Vector v3 = new Vector();</span><br><span class="line">v1.addElement(new String(&quot;data 1&quot;));</span><br><span class="line">v1.addElement(new String(&quot;data 2&quot;));</span><br><span class="line">v1.addElement(new String(&quot;data 3&quot;));</span><br><span class="line">v2.addElement(new String(&quot;data 4&quot;));</span><br><span class="line">v3.addElement(v2);</span><br><span class="line">v.addElement(v1);</span><br><span class="line">v.addElement(v3);</span><br></pre></td></tr></table></figure><p>해당 객체들은 메모리에 Vector와 String이 복잡한 구조를 가지고 있다.</p><ul><li>이러한 복잡한 구조의 데이터를 파일에 저장하려면 어떻게 해야 할까?</li><li>메모리 구조가 더욱 복잡할 경우에는 어떻게 저장할 수 있을까?</li><li>저장한 후, 다시 읽어 들여 원래 형태로 구성하려면 어떻게 해야 할까?</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.util.Vector;</span><br><span class="line"></span><br><span class="line">public class ObjectStreamTest1</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FileOutputStream fout = null;</span><br><span class="line">        ObjectOutputStream oos = null;</span><br><span class="line"></span><br><span class="line">        Vector v = new Vector();</span><br><span class="line">        Vector v1 = new Vector();</span><br><span class="line">        Vector v2 = new Vector();</span><br><span class="line">        Vector v3 = new Vector();</span><br><span class="line">        v1.addElement(new String(&quot;data 1&quot;));</span><br><span class="line">        v1.addElement(new String(&quot;data 2&quot;));</span><br><span class="line">        v1.addElement(new String(&quot;data 3&quot;));</span><br><span class="line">        v2.addElement(new String(&quot;data 4&quot;));</span><br><span class="line">        v3.addElement(v2);</span><br><span class="line">        v.addElement(v1);</span><br><span class="line">        v.addElement(v3);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            fout = new FileOutputStream(&quot;object.dat&quot;);</span><br><span class="line">            oos = new ObjectOutputStream(fout);</span><br><span class="line"></span><br><span class="line">            oos.writeObject(v);</span><br><span class="line">            oos.reset();</span><br><span class="line">            System.out.println(&quot;Saved&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">                fout.close();</span><br><span class="line">            &#125; catch (Exception e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>writeObject() 메소드 한번으로 메모리 내의 모든 내용들이 object.bat 파일에 저장된다. 출력 후에는 반드시 reset() 메소드를 호출해야 한다. 그렇지 않을 경우 메모리 leak이 발생할 수 있기 떄문이다.</p><p>이제 읽어 들여보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectStreamTest2</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FileInputStream fin = null;</span><br><span class="line">        ObjectInputStream ois = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            fin = new FileInputStream(&quot;object.bat&quot;);</span><br><span class="line">            ois = new ObjectInputStream(fin);</span><br><span class="line"></span><br><span class="line">            Vector v = (Vector)ois.readObject();</span><br><span class="line">            Vector v1 = (Vector)v.get(0);</span><br><span class="line"></span><br><span class="line">            String d1 = (String)v1.get(0);</span><br><span class="line">            String d2 = (String)v1.get(1);</span><br><span class="line">            String d3 = (String)v1.get(2);</span><br><span class="line"></span><br><span class="line">            Vector v3 = (Vector)v.get(1);</span><br><span class="line">            Vector v2 = (Vector)v3.get(0);</span><br><span class="line"></span><br><span class="line">            String d4 = (String)v2.get(0);</span><br><span class="line"></span><br><span class="line">            System.out.println(d1);</span><br><span class="line">            System.out.println(d2);</span><br><span class="line">            System.out.println(d3);</span><br><span class="line">            System.out.println(d4);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fin.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; catch (Exception e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 6장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Stream" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Stream/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
  </entry>
  
  <entry>
    <title>04. 2. 바이트 단위 IO 클래스 (2) (Piped)</title>
    <link href="http://jungha-cho.github.io/2017/04/10/JavaIOPiped/"/>
    <id>http://jungha-cho.github.io/2017/04/10/JavaIOPiped/</id>
    <published>2017-04-10T09:10:59.000Z</published>
    <updated>2018-03-26T07:48:46.635Z</updated>
    
    <content type="html"><![CDATA[<h3>5. PipedInputStream과 PipedOutputStream</h3><p>PipedInputStream과 PipedOutputStream을 이해하려면 먼저 파이프가 무엇인지 알아야 한다.</p><p>유닉스 시스템에서 자주 사용하는 기호중에 파이프 기호(’|’)가 있다. 이는 앞 명령어에서 출력된 문자들을 파이프 기호 명령을 통해 뒤의 명령어로 전달할 수 있다. ( ex : ls | wc )</p><p>자바에서 제공하는 Piped도 위의 파이프 기호와 같은 기능을 수행한다. PipedOutputStream으로 출력한 결과를 PipedInputStream을 통해서 읽어 들일수 있게 만들 수 있는 것이다.</p><p>보통 이러한 예는 멀티스레드에서 종종 사용된다. 하나의 스레드가 읽어 들인 내용을 다른 스레드에게 전달하고자 할때 PipedInputStream과 PipedOutputStream을 이용하는 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">class ReadThread extends Thread implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    InputStream pi = null;</span><br><span class="line">    OutputStream po = null;</span><br><span class="line"></span><br><span class="line">    ReadThread ( InputStream pi, OutputStream po)</span><br><span class="line">    &#123;</span><br><span class="line">        this.pi = pi;</span><br><span class="line">        this.po = po;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        int ch;</span><br><span class="line">        byte[] buffer = new byte[512];</span><br><span class="line">        int bytes_read;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            for(;;)</span><br><span class="line">            &#123;</span><br><span class="line">                bytes_read = pi.read(buffer);</span><br><span class="line">                if(bytes_read == -1)</span><br><span class="line">                &#123;</span><br><span class="line">                    return ;</span><br><span class="line">                &#125;</span><br><span class="line">                po.write(buffer, 0, bytes_read);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SystemStream</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           int ch;</span><br><span class="line">           while(true)</span><br><span class="line">           &#123;</span><br><span class="line">               PipedInputStream writeIn = new PipedInputStream();</span><br><span class="line">               PipedOutputStream readOut = new PipedOutputStream(writeIn);</span><br><span class="line"></span><br><span class="line">               ReadThread rt = new ReadThread(System.in, readOut);</span><br><span class="line">               ReadThread wt = new ReadThread(writeIn, System.out);</span><br><span class="line"></span><br><span class="line">               rt.start();</span><br><span class="line">               wt.start();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 4장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;5. PipedInputStream과 PipedOutputStream&lt;/h3&gt;
&lt;p&gt;PipedInputStream과 PipedOutputStream을 이해하려면 먼저 파이프가 무엇인지 알아야 한다.&lt;/p&gt;
&lt;p&gt;유닉스 시스템에서 자주 사용하는 
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Pipe" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Pipe/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
  </entry>
  
  <entry>
    <title>04. 바이트 스트림 : 바이트 단위 IO 클래스</title>
    <link href="http://jungha-cho.github.io/2017/04/09/JavaIOByteStream/"/>
    <id>http://jungha-cho.github.io/2017/04/09/JavaIOByteStream/</id>
    <published>2017-04-09T12:10:59.000Z</published>
    <updated>2018-03-26T07:45:20.511Z</updated>
    
    <content type="html"><![CDATA[<h3>04. 바이트 스트림 : 바이트 단위 IO 클래스</h3><p><a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지에 있는 클래스 중에서 바이트 스트림은 다양한 입출력 프로그램에서 사용된다. 모든 데이터는 바이트 단위로 구성되어 있기 때문이다. 하지만, 많은 개발자들이 바이트 스트림 클래스의 사용 방법에 대해 어려워한다. 이는 바이트 스트림 클래스의 사용 원리를 이해하지 못하기 때문이다.</p><p><a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지에서 클래스는 객체를 재사용하는 좋은 예이다. <a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지의 클래스를 조합해서 다양한 방법으로 사용할 수 있기 때문이다. <a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지의 바이트 스트림은 네트워크 프로그래밍을 할 경우에도 사용하며 JDBC에서 대용량 바이너리 파일을 데이터베이스에 저장하거나 읽어 들이고자 할 경우에도 사용한다.</p><p>XML 프로그래밍에서는 XML 문서를 읽어 들이거나 XML 문서를 출력할 때 <a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지의 바이트 스트림을 사용하기도 한다.<br>즉, <a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지의 바이트 스트림은 입출력과 관련된 곳이라면 항상 사용된다고 생각해도 과언이 아니다.</p><p>어떤 대상으로부터 읽고 쓰든지 간에 <a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지의 사용 방법은 항상 동일하다. 그리고 <a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지의 클래스는 객체지향적으로 잘 만들어졌다. 물론, <a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지를 잘 사용하기 위한 전제는 객체지향 프로그래밍 방법에 대한 확실한 이해다.</p><h3>01. File 클래스</h3><p>영어권의 경우 1byte로 모든 글자를 표현할 수 있지만, 한국, 중국, 일본 등은 1byte로 모든 글자를 표현할 수 없다. 따라서 한국, 일본, 중국등에서 사용되는 글자를 표현하려면 2byte가 필요하며 이러한 지역을 2byte 문화권이라 한다.</p><p>디렉토리 역시 파일로써 취급된다.</p><ul><li>자바를 만든 썬 마이크로시스템즈는 유닉스 계열 운영체제를 만드는 회사다. 그리고 유닉스 시스템은 디렉토리도 파일로 취급한다. 다만, 파일이나 디렉토리를 담아둘 수 있는 특수한 용도의 파일로 취급하는 것이 다를 뿐이다.</li></ul><p><img src="http://cfile24.uf.tistory.com/image/242A133358EA498808AE3C" alt="img22"></p><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 4장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;04. 바이트 스트림 : 바이트 단위 IO 클래스&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://java.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java.io&lt;/a&gt; 패키지에 있는 클래스 중에서 바이트 스트림은 다양한 입출력
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Byte" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Byte/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="Byte" scheme="http://jungha-cho.github.io/tags/Byte/"/>
    
  </entry>
  
  <entry>
    <title>03. 자바 I/O ( 오버라이딩에 대한 이해 )</title>
    <link href="http://jungha-cho.github.io/2017/04/09/JavaIOOverrinding/"/>
    <id>http://jungha-cho.github.io/2017/04/09/JavaIOOverrinding/</id>
    <published>2017-04-09T12:10:59.000Z</published>
    <updated>2018-03-26T07:45:49.781Z</updated>
    
    <content type="html"><![CDATA[<h3>오버라이딩에 대한 확실한 이해</h3><p>자바의 상속과 오버라이딩에 대한 확실한 이해가 없으면 안된다!내가 알고 있는 오버라이딩과 오버로딩의 개념이 헷갈린다.</p><ul><li>오버라이딩<br>올라타다. 라는 단어로 외웠다. 즉, 부모의 메소드를 자식 클래스에서 메소드를 다시 재정의 할 수 있는 기능이다.</li><li>오버로딩<br>로드, 로딩, 즉, 같은 이름의 함수를 정의하고 인자 값에 변화를 줘서 여러 메소드를 정의 할 수 있는 기능이다.</li></ul><p>하지만, 이 예제를 보자 개념이 흔들리기 시작했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">    int i = 7;</span><br><span class="line">    public int get()</span><br><span class="line">    &#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent</span><br><span class="line">&#123;</span><br><span class="line">    int i = 5;</span><br><span class="line">    public int get()</span><br><span class="line">    &#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChildTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void print(Parent p)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(p.i);</span><br><span class="line">        System.out.println(p.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Parent p = new Parent();</span><br><span class="line">        System.out.println(&quot;------------1-----------&quot;);</span><br><span class="line">        System.out.println(p.i);</span><br><span class="line">        System.out.println(p.get());</span><br><span class="line"></span><br><span class="line">        Child c = new Child();</span><br><span class="line">        System.out.println(&quot;------------2------------&quot;);</span><br><span class="line">        System.out.println(c.i);</span><br><span class="line">        System.out.println(c.get());</span><br><span class="line"></span><br><span class="line">        Parent p2 = new Child();</span><br><span class="line">        System.out.println(&quot;------------3------------&quot;);</span><br><span class="line">        System.out.println(p2.i);</span><br><span class="line">        System.out.println(p2.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;------------4------------&quot;);</span><br><span class="line">        print(c);</span><br><span class="line">        print(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1번과 2번의 결과는 예측할 수 있었다. 하지만, 3번, 4번의 결과는 헷갈려서 틀려버렸다.</p><p>위 예제의 출력은</p><ol><li>7 7</li><li>5 5</li><li>7 5</li><li>7 5<br>이다.</li></ol><p>책에서는 오버라이드(Override) 라는 용어의 개념부터 바로잡고 있다.<br>“부모가 가지고 있는 것을 자식이 대체 한다.” 라는 나도 알고 있던 개념을 잘못된 해석이라고 정의한다.</p><p>즉, 똑같은 크기의 트럼프 카드 두장을 겹쳐놓았다고 하자. 아래의 카드는 보이지 않고 윗장의 카드만 보일 것 이다.<br>하지만 아래의 카드가 사라진 것일까? 없어진 것일까? 아니다. 아래의 카드는 보이지만 않을뿐 엄연히 존재하는 카드이다.<br>이것이 오버라이드 즉, 직역하자면 &quot;올라타다&quot;라는 개념인 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent p2 = Child();</span><br><span class="line">System.out.println(&quot;------------3------------&quot;);</span><br><span class="line">System.out.println(p2.i);</span><br><span class="line">System.out.println(p2.get());</span><br></pre></td></tr></table></figure><p>위 예제에서 Child() 객체가 메모리에 올라가게 되면 Child에 있는 필드 i와 Parent에 있는 i 모두가 메모리에 올라가게 된다.<br>이 경우 객체를 가리키는 참조 변수가 Parent라면 필드는 Parent의 것을 사용하게 된다.</p><p>하지만, 메소드가 오버라이딩되는 경우, 부모의 메소드의 코드는 사라지고 자식 메소드의 코드만 남게 된다.</p><p>그 결과, Parent 형식의 참조 변수가 Child 객체를 가리킬 때, 메소드는 자식에서 선언된 메소드가 사용되기 때문에 Child의 i 값이 출력되는 것이다.</p><ul><li>부모는 자식을 가리킬 수 있다. 조상은 자손을 가리킬 수 있다.</li><li>만약, 자식이나 자손이 메소드를 오버라이딩하고 있으면 메소드의 기능은 자식이나 자손이 구현한 것을 따른다.</li></ul><p>즉, 메소드가 오버라이딩될 경우 무조건 자식의 메소드 기능을 따른다.<br>필드는 객체를 가리키는 참조 변수에 따른다.</p><p>그렇다면 아래의 출력 결과는 어떻게 될까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void print(Parent p)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(p.i);</span><br><span class="line">    System.out.println(p.get());</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------</span><br><span class="line">System.out.println(&quot;------------4------------&quot;);</span><br><span class="line">print(c);</span><br><span class="line">print(p2);</span><br></pre></td></tr></table></figure><p>먼저 메소드의 인자를 잘 보아야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void print(Parent p)</span><br></pre></td></tr></table></figure><p>나 같은 경우에도 책을 읽으며 “메소드 print는 인자로 parent를 받는다” 라고 해석했다. 이는 반은 맞고 반은 틀리다.</p><p>&quot;메소드 print는 인자로 parent와 parent의 자손을 받아들인다&quot;라고 보아야한다.</p><p>이 책의 역자가 말하듯, 어떠한 기술이나 언어, 또 lib를 공부할떄 그에 수반되는 기본 지식을 정확하게 알아야 한다는 말처럼<br>기본이 튼튼해야 그 위에 쌓이는 지식 또한 뿌리 깊은 나무가 될것 같다.</p><p><a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/override/OverrideChildTest.java" target="_blank" rel="noopener">소스코드</a></p><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 3장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;오버라이딩에 대한 확실한 이해&lt;/h3&gt;
&lt;p&gt;자바의 상속과 오버라이딩에 대한 확실한 이해가 없으면 안된다!내가 알고 있는 오버라이딩과 오버로딩의 개념이 헷갈린다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;오버라이딩&lt;br&gt;
올라타다. 라는 단어로 외웠다. 즉, 부
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="Override" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/Override/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="Override" scheme="http://jungha-cho.github.io/tags/Override/"/>
    
  </entry>
  
  <entry>
    <title>03. 05. 자바 IO란?</title>
    <link href="http://jungha-cho.github.io/2017/04/09/JavaIOWhatisjavaIO/"/>
    <id>http://jungha-cho.github.io/2017/04/09/JavaIOWhatisjavaIO/</id>
    <published>2017-04-09T12:10:59.000Z</published>
    <updated>2018-03-26T07:46:00.925Z</updated>
    
    <content type="html"><![CDATA[<h3><a href="http://Java.io" target="_blank" rel="noopener">Java.io</a></h3><p>읽고 쓸 수 있는 클래스들은 크게 두 가지로 나뉘어지는데, 바이트 단위로 읽고 쓸수 있는 '바이트 스트림 클래스’와 문자 단위로 읽고 쓸 수 있는 '문자 스트림 클래스’로 나뉜다.</p><p>처음의 자바는 바이트 단위로 읽고 쓸 수 있는 바이트 스트림 클래스만 존재했지만, 2바이트 문화권인 한국, 일본, 중국 등의 영향으로 문자 스트림 클래스가 추후에 추가됐다. 이는 한글을 입출력하는 프로그램의 경우 문자 스트림 클래스를 사용하는 것이 유리하다는 것을 의미한다.</p><p><img src="http://cfile29.uf.tistory.com/image/223F6E3D56103655110058" alt="es2"></p><ul><li>자바 IO에서 제공되는 클래스의 일부, 실제로는 훨씬 많은 IO 클래스가 제공된다.</li></ul><p>클래스명에 사용되는 단어들은 각각 중요한 의미가 있는데, 해당 단어를 보고 어떤 기능의 IO 객체인지 쉽게 짐작할 수 있다.</p><p><img src="http://cfile23.uf.tistory.com/image/2572625058EA3D6216918A" alt="es"></p><h3>06 생성자가 중요한 자바 IO 관련 클래스</h3><p>자바 IO 패키지는 상당히 많은 수의 클래스로 구성되어 있는데, 이러한 클래스를 잘 사용하려면</p><ul><li>첫째, 앞서 설명한 클래스명을 구성하는 단어들의 의미를 잘 알고 있어야 한다.</li><li>둘째, 자바IO 패키지 클래스의 생성자 의미를 잘 알고 있어야 한다. 자바 IO와 관련된 클래스의 생성자는 인자로 읽어 들일 대상, 혹은 출력해야 할 대상을 지정하는데 사용하기 때문이다.</li></ul><p>예를 들어 파일 IO 클래스는 파일명이나 파일 관련 클래스를 인자로 받아들여 해당 파일로부터 읽거나 쓰는 동작을 하게 된다.<br>즉, “어디로부터 읽어 들일 것인가?” 또는 &quot;어떤 곳에 출력할 것인가?&quot;를 잘 하려면 생성자를 잘봐야 한다는 것을 의미 한다.</p><h3>07 자바IO 프로그래밍을 잘하려면</h3><p>자바IO 프로그래밍을 잘하려면 자바 API를 한번쯤 꼭 읽어볼 필요가 있다. 그래야만 어떤 클래스에 어떤 메소드가 있는지 알 수 있기 때문이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedReaderTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        InputStreamReader isr = InputStreamReader(System.in);</span><br><span class="line">        BufferedReader br = new BufferedReader(isr);</span><br><span class="line">        String line = br.readLine();</span><br><span class="line">        System.out.println(&quot;키보드로 부터 입력 받은 문자열 : &quot; + line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 3장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;a href=&quot;http://Java.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java.io&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;읽고 쓸 수 있는 클래스들은 크게 두 가지로 나뉘어지는데, 바이트 단위로 읽고 쓸수 있는 &#39;바이트 스트림 클
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="IO" scheme="http://jungha-cho.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 13. Thread</title>
    <link href="http://jungha-cho.github.io/2017/04/06/Chapter13Thread/"/>
    <id>http://jungha-cho.github.io/2017/04/06/Chapter13Thread/</id>
    <published>2017-04-06T12:10:59.000Z</published>
    <updated>2018-03-26T07:44:53.388Z</updated>
    
    <content type="html"><![CDATA[<h3>Chapter 13. Thread</h3><ul><li>멀티 쓰레딩의 장단점</li><li>CPU의 사용률을 향상시킨다.</li><li>사용자에 대한 응답성이 향상된다.</li><li>사용자에 대한 응답성이 향상된다,</li><li>작업이 분리되어 코드가 간결해 진다.</li></ul><h3>Context Switching</h3><ul><li>멀티 쓰레드 환경에서 문맥 전환( Context Switching )은 시간이 걸린다.</li><li>싱글코어와 멀티코어의 같은 작업에 대한 수행시간은 같거나 싱글 코어가 더 빠를수도 있다.</li><li>문맥 전환시 프로세스의 PCB에 저장되며, CPU의 레지스터 값, 프로세스의 상태, 메모리 관리 정보등을 포함한다.</li></ul><h3>Priority</h3><p>쓰레드 우선순위는 쓰레드를 실행하기 전에만 변경할 수 있다.</p><h3>Thread Group ( 쓰레드 그룹 )</h3><ul><li>쓰레드 그룹은 서로 관련된 쓰레드를 그룹으로 다루기 위한 것</li><li>쓰레드 그룹은 보안상의 이유로 도입된 개념이다.</li><li>자신이 속한 쓰레드 그룹이나 하위 쓰레드 그룹은 변경할 수 있지만 다른 쓰레드 그룹의 쓰레드를 변경할 수는 없다.</li><li>모든 쓰레드는 반드시 쓰레드 그룹에 포함되어 있어야 한다.</li><li>기본적으로 자신을 생성한 쓰레드와 같은 쓰레드 그룹에 포함 된다.</li><li>JVM은 main과 system이라는 쓰레드 그룹을 만들고 JVM 운영에 필요한 쓰레드들을 생성해서 이 쓰레드 그룹에 포함시킨다.</li><li>우리가 생성하는 모든 쓰레드 그룹은 main 쓰레드 그룹의 하위 쓰레드 그룹에 속하게 된다.</li></ul><h3>Daemon Thread ( 데몬 쓰레드 )</h3><ul><li>데몬 쓰레드는 다른 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드이다.</li><li>보조 역할이므로 일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제적으로 자동 종료되는데, 일반 쓰레드의 보조 역할 이므로 일반 쓰레드가 다 죽으면 존재 이유가 없다.</li><li>이 점을 제외 하고는 다른점이 없다.</li><li>가비지 컬렉터, 워드 프로세서의 자동 저장, 화면 자동 갱신</li></ul><h3>쓰레드의 동기화</h3><ul><li>Java.util.concurrent.locks, java.util.concurrent.atomic 패키지를 통해 다양한 방식으로 동기화를 구현할 수 있도록 지원, since jdk1.5</li><li>임계영역은 멀티 쓰레드 프로그램의 성능을 좌우하기 때문에 가능하면 메서드 전체에 락을 거는 것보다 synchronized 블럭으로 임계영역을 최소화 해서 보다 효율적인 프로그램이 되도록 노력해야 한다.</li><li>NotifyAll()은 모든 객체의 wating이 깨워지는것은 아니다. 객체마다 wating pool이 존재하기 때문이다.</li></ul><h3>Lock과 Condition을 이용한 동기화</h3><ul><li><p>Java,util.concurrent.locks 패키지가 제공하는 lock클래스를 이용하기.</p></li><li><p>synchronized 블럭은 자동적으로 잠기고 풀린다. 블럭 내에서 예외가 발생해도  lock은 자동적으로 풀리기 때문에 편리하다 하지만 같은 메서드 내에서만 lock을 걸 수 있다는 제약이 불편할때 java.util,concurrent.locks를 이용한다.</p></li><li><p>Reentrantlock : 재진입이 가능한 락, 가장 일반적인 베타 lock</p></li><li><p>Reentrantreadwritelock : 읽기에는 공유적이고 쓰기에는 베타적인 lock</p></li><li><p>stampedLock : reentrantreadwritelock에 낙관적인 lock의 기능을 추가</p></li><li><p>ReentrantReadWriteLock : 읽기 Lock은 동시에 읽기 가능. 읽기 Lock이 걸려있는 상태에서 Write 진입 불가, Write 락 중에서도 Read 불가.</p></li><li><p>StampedLock : 읽기와 쓰기를 위한 낙관적인 Lock. 쓰기와 읽기가 충돌할 떄만 쓰기가 끝난 후에 읽기 Lock을 건다.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">Try &#123;</span><br><span class="line">// 임계 영역</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일반적으로 finally로 묶어준다.<br>tryLock(); 은 lock을 얻으려고 기다리지 않느다. 지정된 시간 만큼만 기다리고 얻으면 true 아니면 false</p><h3>Volatile</h3><ul><li>멀티 코어 프로세서에서는 코어 마다 별도의 캐시를 가지고 있다.</li><li>코어는 메모리에서 읽어온 값을 캐시에 저장하고 캐시에서 값을 읽어서 작업한다.</li><li>다시 같은 값을 읽어올 떄는 먼저 캐시에 있는지 확인하고 없을때만 메모리에서 읽어온다.</li><li>변수 앖에 volatile boolean stopFlag = false; 를 붙이면 캐시가 아닌 메모리에서 값을 읽어오기 때문에 캐시와 메모리간 값의 불일치가 해결된다.##</li><li>But 도중에 메모리에 저장된 값이 다른 경우가 발생한다. 그래서 변수 stopped의 값이 바뀌었는데도 쓰레드가 멈추지 않고 계속 실행되는 것이다.</li><li>volatile 대신 synchronized 블럭을 사용해도 같은 효가를 얻을수 있다. 쓰레드가 synchronized 블럭으로 들어갈때와 나올때 캐시와 메모리간의 동기화가 이루어 지기 때문에 값의 불일치가 해소된다.</li></ul><h3>volatile로 long과 double를 원자화</h3><ul><li>JVM은 데이터를 4 바이트(=32bit) 단위로 처리하기 때문에 인트와 인트보다 작은 타입들은 한번에 읽거나 쓰는것이 가능하다.</li><li>이는 하나의 명령어로 처리 가능하고 더이상 나눌수 없는 최소의 작업 단위 임으로 작업 중간에 다른 쓰레드가 끼어들 틈이 없다.</li><li>그러나 크기가 8byte인 long과 double 타입의 변수는 하나의 명령어로 값을 읽거나 쓸수 없다. 따라서 다른 쓰레드가 끼어들 여지가 있다.</li><li>따라서 volatile long sharedVal; volatile double sharedVal;로 8byte를 원자화한다.</li><li>하지만 volatile은 변수의 읽기와 쓰기를 원자화 할뿐 동기화 하는것은 아니다.</li></ul><h3>Fork &amp; join 프레임 워크</h3><ul><li><p>코어가 늘어나는 CPU가 발전함에 따라 멀티코어를 잘 활용할 수 있는 멀티 쓰레드 프로그래밍이 중요해지고 있다.</p></li><li><p>JDK 1.7부터 fork&amp;join 프레임 웍이 추가되었고 이 프레임 웍은 하나의 작업을 작은 단위로 나눠서 여러 쓰레드가 동시에 처리하는 것을 쉽게 만들어 준다.</p></li><li><p>RecursiveAction : 반환값이 없는 작업을 구현할때, RecursiveTask : 반환값이 있는 작업을 구현할때</p></li><li><p>ForkJoinPool pool = new ForkJoinPool();</p></li><li><p>SumTask task = new SumTask(from, to);</p></li><li><p>Long result = pool.invoke(task);</p></li><li><p>ForkJoinPool은 해당 프레임웍에서 제공하는 쓰레드 풀로 지정된 쓰레드를 생성해 미리 만들어놓고 반복해서 재사용할 수 있게 한다.</p></li><li><p>쓰레드를 반복해서 생성하지 않아도 된다는 장점과, 너무 많은 쓰레드가 생성되어 성능이 저하되는 것을 막아준다는 장점이 있다.</p></li><li><p>쓰레드 풀은 쓰레드가 수행해야하는 작업이 담긴 큐를 제공하며 각 쓰레드는 자신의 작업 큐에 담긴 작업을 순서대로 처리한다.</p></li><li><p>쓰레드 풀은 기본적으로 코어의 개수와 동일한 개수의 쓰레드를 생성한다.</p></li><li><p>fork()는 비동기 메서드, join()은 동기 메서드이다.</p></li></ul><p>출처 : 남궁성, 『 자바의 정석 3/E』, 도우출판(2016.1.27), chapter 13 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Chapter 13. Thread&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;멀티 쓰레딩의 장단점&lt;/li&gt;
&lt;li&gt;CPU의 사용률을 향상시킨다.&lt;/li&gt;
&lt;li&gt;사용자에 대한 응답성이 향상된다.&lt;/li&gt;
&lt;li&gt;사용자에 대한 응답성이 향상된다,&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Thread" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/Thread/"/>
    
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Thread" scheme="http://jungha-cho.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>네트워크와 네트워킹</title>
    <link href="http://jungha-cho.github.io/2017/04/06/NetworkAndNetworking/"/>
    <id>http://jungha-cho.github.io/2017/04/06/NetworkAndNetworking/</id>
    <published>2017-04-06T12:10:59.000Z</published>
    <updated>2018-03-26T07:45:37.396Z</updated>
    
    <content type="html"><![CDATA[<h3>01. 네트워크와 네트워킹</h3><p>기본 개념 정리 파트이다. 모르는 것만 간단하게 요점 정리 해야 겠다!</p><p>OSI 7계층</p><ul><li>7계층 : 애플리케이션 ( NFS, FTP, HTTP…. )</li><li>6계층 : 프리젠테이션 ( XDE, XML, ASCI, Java Serialization )</li><li>5계층 : 세션 ( Sun RPC, DCE RPC, IIOP, RMI )</li><li>4계층 : 트랜스포트 ( TCP, UDP )</li><li>3계층 : 네트워크 ( IP )</li><li>2계층 : 데이터 링크 ( wire formats for message )</li><li>1계층 : 물리 ( wires, signaling )</li></ul><p>Bit, frame, packet</p><h3>IP ( Internet Protocol )</h3><p>패킷이 상대방에게 안전하게 전송되는 것을 보장하지 않는다.<br>IP는 상위 계층인 트랜스포트 계층에서 패킷을 안전하게 전달하는 신뢰성을 책임진다는 가정하에 IP 프로토콜은 데이터를 효율적으로 보내는 것에만 집중한다.</p><ul><li>IPv4 - 32bit</li><li>IPv6 - 128bit</li></ul><h3>ICMP ( Internet Control Message Protocol )</h3><p>IP는 내장된 오류처리, 또는 보고 매커니즘이 없다. 이를 보완한 프로토콜이 ICMP이다.<br>전송 역할은 IP가 담당하고 IP에 ICMP를 덧붙여 추가적인 오류보고와 기타 제어 메세지를 포함시킨다.</p><h3>TCP ( Transmission Control Protocol )</h3><p>TCP는 신뢰성 있는 프로토콜이다. 즉, 전송할 데이터가 안전하게 전달되는 것을 보장하는 프로토콜이라는 뜻이다.<br>전달되는 데이터는 순서를 보장하며 안전하게 전달되는 것을 보장한다.<br>TCP는 연결 지향 프로토콜이다.<br>TCP는 소켓과 포트를 이용해서 동시에 여러 개의 접속을 지원할 수 있다.</p><p>IP + TCP -&gt; HTTP ( 80 )<br>    SMTP ( 25 )<br>    POP3 ( 110 )<br>       FTP ( 20, 21 )</p><p>UDP보다 속도는 느리고 더 복잡하다. 하지만 신뢰성 있는 전송이 가능하다는 장점 때문에 많은 프로토콜이 TCP를 사용한다.</p><h3>UDP ( User Datagram Protocol )</h3><p>UDP는 신뢰성 없는 프로토콜이다. 데이터가 잘 전달되었는지 확인하지 않고 단지 데이터를 보내는 것으로 자신의 임무를 다한 것으로 생각한다.<br>UDP는 음악이나 동영상의 스트리밍 서비스에 적당하다.</p><h3>인터넷 애플리케이션 프로토콜</h3><p>OSI 계층 중 7 계층에 속하는 애플리케이션 프로토콜이 자바 개발자들이 실제로 다뤄야 할 부분이다.<br>메일을 보내고 파일을 전송하고, 웹 사이트에 접속하기 위한 프로토콜이 이미 표준으로 정의되어 있다.</p><h3>06. TCP/IP 스택</h3><h3>07. 소켓과 포트</h3><h3>08. 보안</h3><p>출처 : 김성박 송지훈 공저, 『 자바 IO &amp; NIO 네트워크 프로그래밍』, 한빛미디어(2004.9.30), 1장 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;01. 네트워크와 네트워킹&lt;/h3&gt;
&lt;p&gt;기본 개념 정리 파트이다. 모르는 것만 간단하게 요점 정리 해야 겠다!&lt;/p&gt;
&lt;p&gt;OSI 7계층&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;7계층 : 애플리케이션 ( NFS, FTP, HTTP…. )&lt;/li&gt;
&lt;li&gt;6계
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Book/JavaIO-NIO/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="JavaIO NIO" scheme="http://jungha-cho.github.io/tags/JavaIO-NIO/"/>
    
      <category term="OSI" scheme="http://jungha-cho.github.io/tags/OSI/"/>
    
      <category term="IP" scheme="http://jungha-cho.github.io/tags/IP/"/>
    
      <category term="ICMP" scheme="http://jungha-cho.github.io/tags/ICMP/"/>
    
      <category term="TCP" scheme="http://jungha-cho.github.io/tags/TCP/"/>
    
      <category term="UDP" scheme="http://jungha-cho.github.io/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>Generics</title>
    <link href="http://jungha-cho.github.io/2017/04/06/Generic/"/>
    <id>http://jungha-cho.github.io/2017/04/06/Generic/</id>
    <published>2017-04-06T12:10:59.000Z</published>
    <updated>2018-03-26T07:44:58.982Z</updated>
    
    <content type="html"><![CDATA[<h1>Chapter 12. Generic</h1><h3>Generics란?</h3><ul><li>다양한 타입의 객체를 다루는 메소드나 컬렉션 클래스에 컴파일 시 Type을 체크해 주는 기능이다.</li><li>객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형 변환의 번거로움이 줄어든다.</li></ul><h2>Type 안정성?</h2><ul><li><p>의도하지 않은 타입의 객체가 저장되는 것을 막는다.</p></li><li><p>원래의 타입과 다른 타입으로 잘못 형 변환 되어 발생할 수 있는 오류를 줄여준다.</p></li><li><p>ArrayList temp와 ArrayList<string> temp의 차이인듯 하다.</string></p></li><li><p>각각 넣을때와 꺼낼때 타입 체크와 형변환을 생략할 수 있다.</p></li></ul><h2>Generics의 장점</h2><ul><li><p>타입 안정성을 제공한다.</p></li><li><p>타입 체크와 형변환을 생략할 수 있으므로 코드가 간결해 진다.</p></li><li><p>정리 하자면 다루고자 하는 객체의 타입을 미리 명시해 줌으로써 번거로운 형변환을 줄여준다는 얘기다.</p></li></ul><p>Generic 클래스의 선언</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Class name&lt;T&gt;&#123;</span><br><span class="line">T name;</span><br><span class="line"></span><br><span class="line">void setName (T item)&#123; this.name = item; &#125;</span><br><span class="line">T getName () &#123; return name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name&lt;String&gt; b = new name&lt;String&gt;(); // 타입 T 대신 실제 타입 지정</span><br><span class="line">b.setName(new Object()); // 에러, String만</span><br><span class="line">b.setName(“duh”);</span><br><span class="line"></span><br><span class="line">Name b = new name(); // 이전 방식으로도 생성 가능하다. 호환성 문제로 지원</span><br><span class="line">b.setName(“ABC”);// 지네릭 타입을 지정하지 않아서 안전하지 않다는 경고 발생</span><br><span class="line"></span><br><span class="line">name&lt;T&gt; 지네릭 클래스, T의 name, T name이라고 읽는다.</span><br><span class="line">T타입 변수 또는 타입 매개변수 ( T는 타입 문자 )</span><br><span class="line">Box원시 타입 ( raw type )</span><br><span class="line"></span><br><span class="line">또한 다형성과 상속관계에 따라 다음과 같은 T도 허용 가능하다.</span><br><span class="line">Name&lt;Korea&gt; newName = new KoreaName&lt;Korea&gt;; // 다형성</span><br><span class="line"></span><br><span class="line">Name&lt;Korea&gt; newName = new KoreaNmae&lt;Korea&gt;;</span><br><span class="line">newName.add(new Korea);</span><br><span class="line">newName.add(new childKorea); // 상속관계</span><br><span class="line">제한된 Generic 클래스</span><br><span class="line">매개타입 T를 제한하는 방법</span><br><span class="line">Class KoreaName(T extends Korea)&#123; // Korea의 자손만 타입으로 지정 가능</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>매개변수가 Interface를 구현해야 한다고 하더라도 extends를 사용한다.<br>클래스 Korea의 자손이면서 SouthKorea를 구현해야 한다면…<br>Class KoreaName&lt;T extends Korea &amp; SouthKorea&gt;{…}</p><p>와일드 카드<br>메소드 오버로딩시 Generic 타입이 다른것 만으로는 오버로딩이 성립되지 않는다. 오히려 메소드 중복 정의이다.<br>이때 사용하기위해 고안된 것이 와일드 카드이다.</p><? extends T>   : 와일드 카드 상한 제한. T와 그 자손들만 가능<? super T>   : 와일드 카드 하한 제한. T와 그 부모들만 가능<?>     : 제한 없음<p>Generic Type의 형변환</p><p>출처 : 남궁성, 『 자바의 정석 3/E』, 도우출판(2016.1.27), chapter 7 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Chapter 12. Generic&lt;/h1&gt;
&lt;h3&gt;Generics란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다양한 타입의 객체를 다루는 메소드나 컬렉션 클래스에 컴파일 시 Type을 체크해 주는 기능이다.&lt;/li&gt;
&lt;li&gt;객체의 타입을 컴파일 시에 체크하
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Generic" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/Generic/"/>
    
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="Generic" scheme="http://jungha-cho.github.io/tags/Generic/"/>
    
  </entry>
  
  <entry>
    <title>총 정리</title>
    <link href="http://jungha-cho.github.io/2017/04/06/StandardOfJava/"/>
    <id>http://jungha-cho.github.io/2017/04/06/StandardOfJava/</id>
    <published>2017-04-06T12:10:59.000Z</published>
    <updated>2018-03-26T07:39:42.770Z</updated>
    
    <content type="html"><![CDATA[<h1>StandardOfJava</h1><ul><li>모든 자료는, 출처 : 남궁성, 『 자바의 정석 3/E』, 도우출판(2016.1.27), 를 인용하였음을 알립니다.</li><li>Java를 공부하며 실습 자료를 올리는 공간입니다.</li></ul><h2>Java 일반</h2><ul><li><a href="https://github.com/JungHa-Cho/StandardOfJava/tree/master/Java" target="_blank" rel="noopener">Java 기초 목차</a> - 목차 study by wikidocs</li><li><a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/common/Counter.java" target="_blank" rel="noopener">CallByValue</a> - Call By Value</li><li><a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/common/Counter2.java" target="_blank" rel="noopener">CallByReference</a> - Call By Reference</li></ul><h2>Chapter 7. Abstract</h2><ul><li>추상, 낱낱의 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작용</li><li>추상화와 구체화의 차이점</li><li><a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/chapter7/Abstract/Implements.java" target="_blank" rel="noopener">Implements</a> - 추상 메소드의 구현</li><li>구체화, 상속을 통해 클래스를 구현, 확장하는 작업</li><li><a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/chapter7/Abstract/Abstract.java" target="_blank" rel="noopener">Abstract</a> - 추상화 작업을 통한 부모 클래스 작성 ( <a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/chapter7/Abstract/Abstract.java" target="_blank" rel="noopener">원형 클래스</a>, <a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/chapter7/Abstract/Abstract.java" target="_blank" rel="noopener">추상화 작업 후</a> )</li><li>추상화, 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업</li><li>일반 메소드를 상속받아 @Override하는 것과 abstract로 @Override하는 것은 차이가 없다. 하지만 abstract로 선언해두면, 자손 클래스에서 abstract 메소드를 강제할 수 있다.</li></ul><h2>Chapter 7. Interface</h2><ul><li><h3>인터페이스</h3></li><li><p>추상클래스를 부분적으로 완성된 미완성 설계도라 한다면, 인터페이스는 구현된 것은 아무 것도 없고 밑그림만 그려져 있는 기본 설계도라 할 수 있다.</p></li><li><p>그 자체로 사용되기 보다 다른 클래스를 작성하는데 도움 줄 목적으로 작성 된다.</p></li><li><p>인터페이스의 이름에는 주로 Eatable같이 ~를 할수 있다는 의미의 able를 주로 쓴다. 이 인터페이스를 구현하면 먹을 수 있다. 처럼 인터페이스를 상속한 클래스 John은 먹을 수 있다. 처럼 먹는 메소드를 제공한다는 것을 강조하기 위함이다.</p></li><li><p>오버라이딩 할 때는 조상의 메서드보다 넓은 범위의 접근 제어자를 지정해야 한다. 인터페이스 내 메소드는 public abstract를 생략하고 있기 때문이다.</p></li><li><h3>인터페이스의 특징, 일반적인 클래스와 달리 인터페이스의 멤버들은 다음과 같은 제약사항이 있다.</h3></li><li><p>인터페이스는 static 상수만 정의할 수 있다.</p></li><li><p>모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.</p></li><li><p>모든 메서드는 public abstract 이어야 하며 이를 생략할 수 있다.</p></li><li><p>단, static 메서드와 디폴트 메서드는 예외 JDK 1.8 부터 변경</p></li><li><h3>인터페이스를 이용한 다중 상속 <a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/chapter7/Interface/MultiExtendsTVCR.java" target="_blank" rel="noopener">예제</a></h3></li><li><p>두 조상으로부터 같은 이름의 메소드를 상속 받을떄 멤버 변수 이름이 같거나 메소드 이름이 같으면 자손 클래스는 어느 조상의 멤버를 상속 받아야 될지 모른다.</p></li><li><p>다중 상속의 장점보다 이러한 단점이 더 크다고 판단한 Java는 다중상속을 허용하지 않는다.</p></li><li><p>하지만, 자바도 인터페이스를 이용해 다중 상속이 가능하다. 라는 사실 때문에 인터페이스는 다중 상속을 위한 것이라고 오해를 사는 것 일뿐 자바에서 인터페이스로 다중상속을 구현하는 경우는 거의 없다.</p></li><li><h3>인터페이스를 이용한 다형성</h3></li><li><p>리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.</p></li><li><h3>인터페이스의 장점</h3></li><li><p>개발시간을 단축시킬 수 있다. 메소드의 선언부만 알면 양쪽에서 필요한 기능을 개발할 수 있기 때문이다. (의존성 분리)</p></li><li><p>표준화가 가능하다. 프로그램의 기본 틀을 인터페이스로 제공하면 대형 프로젝트에서도 표준화가 가능하다.</p></li><li><p>서로 관계없는 클래스드들에게 관계를 맺어 줄 수 있다.</p></li><li><p>독립적인 프로그래밍이 가능하다. 하나의 클래스 변경이 다른 클래스에 영향을 끼치지 않도록 할 수 있다.</p></li></ul><h3>Chapter 9. java.lang 패키지와 유용한 클래스</h3><ul><li><h2></h2></li></ul><h3>Chapter 12. Enum</h3><ul><li><a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/chapter12/AbstractEnum.java" target="_blank" rel="noopener">AbstractEnum</a> - Abstract Enum</li></ul><h3>Chapter 13. Thread</h3><ul><li><a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/chapter13/ThreadExample1.java" target="_blank" rel="noopener">쓰레드 구현</a> - 쓰레드를 구현하는 두가지 방법 p.724</li><li><a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/chapter13/ThreadExample2.java" target="_blank" rel="noopener">StampedLock</a> - JDK 1.8부터 지원하는 StampedLock</li><li><a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/chapter13/ThreadWaitExample1.java" target="_blank" rel="noopener">ReentrantLock</a> - ReentrantLock과 Condition으로 구분하는 Pool</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;StandardOfJava&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;모든 자료는, 출처 : 남궁성, 『 자바의 정석 3/E』, 도우출판(2016.1.27), 를 인용하였음을 알립니다.&lt;/li&gt;
&lt;li&gt;Java를 공부하며 실습 자료를 올리는 공간입니다.&lt;/li&gt;
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="자바의정석" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D/"/>
    
  </entry>
  
  <entry>
    <title>Network Byte Order</title>
    <link href="http://jungha-cho.github.io/2017/04/06/ByteOrder/"/>
    <id>http://jungha-cho.github.io/2017/04/06/ByteOrder/</id>
    <published>2017-04-06T12:10:59.000Z</published>
    <updated>2018-03-26T07:38:25.041Z</updated>
    
    <content type="html"><![CDATA[<h3>Byte Order에 대한 정리 및 기초 복습</h3><p>세상에나 마상에나… 학교에서 치를 떨며 배웠지만 중요하게 생각하지 않았던 기초들이 칼날이 되어 돌아왔다… <code>bit</code> <code>byte</code>… <code>word</code>…하핳… 그래서 오늘 이에대한 정리 겸 복습을 해보고자 한다.</p><p><code>digital</code>이 뭘까? 01010101101000101010101010101001 영화 매트릭스에서도 봤던 숫자들이다. 이 디지털 세상에서는 모든 데이터가 <code>bit</code> 단위로 돌아간다. 즉, 디지털 세상에서는 제일 기본이 되는 단위인 bit는 0과 1밖에 표시하지 못한다. 전기신호 또한 똑같다. 5v, 0v, 5, 0v, 0v 5v, 이 또한 5는 1이 되고 0은 0이 되는 <code>bit</code> 단위이다.</p><p>이런 비트가 개인적으로 가장 와닿았던 곳은 네트워크를 배울때였다. A Class B class C class가 어떻니 저떻니… 할때 192.168.0.1이 사설 주소라는 것을 알게 됐고 이 주소가 8bit.8bit.8bit.8bit로 총 32bit의 표현범위를 가진다는것을 알게됐었다. 또 <a href="https://jungha-cho.github.io/%EC%9D%BC%EB%B0%98/2017/04/03/2%EC%9D%98-%EB%B3%B4%EC%88%98%EB%B2%95%EC%9C%BC%EB%A1%9C-%EC%9D%8C%EC%88%98-%ED%91%9C%ED%98%84%ED%95%98%EA%B8%B0.html">2의 보수법으로 음수 표현하기</a>라는 좋은 포스팅을 접하면서 이해도가 조금 더 높아졌었다.</p><h3>Byte</h3><p>그렇다면 이 <code>byte</code>는 뭘까? bit 1개가 8개가 모이면 1byte로 계산한다. 라는 표준 규격에 따라 1byte는 8bit이다. 여기서 왜 하필 1byte는 8bit일까? 꼭 8bit가 아니어도 괜찮치 않은가? 여기에는 컴퓨터 아키텍처와 밀접한 관련이 있고 사실 꼭 1byte를 8bit로 규정짓지 않는 컴퓨터도 있다. 물론 옛날 컴퓨터지만… 관련 정보들은 <a href="http://thrillfighter.tistory.com/116" target="_blank" rel="noopener">32비트와 64비트 포스팅</a>을 참고하길 바란다. 여기서 컴퓨터 운영체제의 32bit, 64bit가 어떤걸 뜻하는지 진심으로 깨닳은지가 얼마되지 않았다. 이 32bit, 64bit 단위는 CPU가 사용하는 데이터를 잠시 담아놓는 <code>레지스터</code>가 있는데 이 <code>레지스터</code>의 최소 단위가 32bit, 64bit라는 말이다. 즉 이 운영체제의 CPU는 데이터를 처리하는 최소 단위인 <code>레지스터</code>의 용량이 32bit, 64bit라는 것이다. 이 또한 더 좋은 <a href="http://bboy6604.tistory.com/entry/%ED%8F%AC%EC%9D%B8%ED%84%B0-%EB%B3%80%EC%88%98%EA%B0%80-4byte-%EC%9D%B8-%EC%9D%B4%EC%9C%A0" target="_blank" rel="noopener">포스팅</a>을 참조하길 바란다.</p><h3>Byte Order</h3><p>여기까지 오는데 너무 많은 개념이 필요했다. 그 만큼 기초부터 차근 차근 쌓아 나아가는게 흔들리지 않는다는 것을 개발자 인생에서 또 한번 느낀다. 각설하고 <code>Byte Order</code>는 말 그대로 바이트의 순서이다. 가장 효율적으로 메모리에 한번에 접근하고 읽어올 수 있는 이 <code>4Byte</code> 단위의 데이터를 메모리에 적재하는 방식의 차이이다. Big Endian, Little Endian의 두가지 방식이 있는데, 계란의 둥근 곳부터 깨먹는게 맞다. 계란의 뾰족한 곳부터 깨먹는게 맞다 처럼 또 엄마가 좋냐 아빠가 좋냐처럼 답이 없는듯한 개념이다. <code>0x01 0x02 0x03 0x04</code>라는 4byte를 메모리에 올릴때 최상위 바이트 <code>MSB (Most Significant Byte)</code>부터 차례로 저장하는 방식이 <code>Big Endian</code>이고 최하위 바이트 <code>LSB (Least Significant Byte)</code> 부터 차례로 저장하는 것이 <code>Litte Endian</code> 방식이다. Intel CPU는 Big Endian 방식을 사용하고 SPARC CPU는 Little Endian 방식을 사용한다. <a href="http://genesis8.tistory.com/37" target="_blank" rel="noopener">참조</a></p><h3>Network Byte Order</h3><p>이처럼 저장하는 방식 부터 차이가 나므로 이 데이터를 네트워크를 통해 보내고 받을때에도 보내는 곳과 받는곳의 데이터 저장방식을 맞출 필요가 있다. 이 개념이 <code>Network Byte Order</code>의 필요성이다. 최근 Network 프로그램을 작성하면서 <code>JVM</code>은 기본 Bit Endian 방식으로 데이터를 저장하고 <code>Network</code> 또한 Big Endian 방식을 사용한다고 하기에 아무 생각없이 <code>System.arraycopy()</code>로 빈공간에 <code>SPACE</code>를 채우고 <code>4byte</code>를 전송했더랬다. 이유도 모른체 socket의 IO Exception을 바라봐야 했고 많은 자료도 찾아봤지만 Endian방식이 문제가 아니라 이 데이터를 패킹하는 방식이 문제였다.</p><p>2의 Integer형을 패킹할때 <code>Integer.toString(&quot;1&quot;).getByte()</code>로 패킹한후 1의 사이즈 만큼 <code>arraycopy</code>를 수행하고 전송했는데 이것이 문제였다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getBigEndianInNetwork(byte[] src) &#123;</span><br><span class="line">    byte dest[] = new byte[length];</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(4);</span><br><span class="line">    bb.order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">    System.arraycopy(src, 0, dest, 0, 4);</span><br><span class="line">    bb.put(dest);</span><br><span class="line"></span><br><span class="line">    return bb.get(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 함수를 작성하기까지 수많은 삽질의 시간을 보냈다… 또 최근 Network 프로그램을 작성하던 도중 기초가 헷갈리고 개념이 헷갈려 많은 삽질을 했기에 이 글을 포스팅한다. 끄.ㅅ.!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Byte Order에 대한 정리 및 기초 복습&lt;/h3&gt;
&lt;p&gt;세상에나 마상에나… 학교에서 치를 떨며 배웠지만 중요하게 생각하지 않았던 기초들이 칼날이 되어 돌아왔다… &lt;code&gt;bit&lt;/code&gt; &lt;code&gt;byte&lt;/code&gt;… &lt;code&gt;w
      
    
    </summary>
    
      <category term="Network" scheme="http://jungha-cho.github.io/categories/Network/"/>
    
      <category term="ByteOrder" scheme="http://jungha-cho.github.io/categories/Network/ByteOrder/"/>
    
    
      <category term="Network" scheme="http://jungha-cho.github.io/tags/Network/"/>
    
      <category term="ByteOrder" scheme="http://jungha-cho.github.io/tags/ByteOrder/"/>
    
  </entry>
  
  <entry>
    <title>Interface</title>
    <link href="http://jungha-cho.github.io/2017/04/06/Interface/"/>
    <id>http://jungha-cho.github.io/2017/04/06/Interface/</id>
    <published>2017-04-06T12:10:59.000Z</published>
    <updated>2018-03-26T07:45:05.022Z</updated>
    
    <content type="html"><![CDATA[<h3>JAVA Interface</h3><ul><li><p>개발 시간을 단축시킬 수 있다. ( 설계도를 제공 )</p></li><li><p>표준화가 가능하다. (ex. Jdbc Interface )</p></li><li><p>서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다. ( 공통 부분을 묶어서 inteface로 작성하고 implements로 구현하게 하면 된다. )</p></li><li><p>독립적인 프로그래밍이 가능하다. ( 선언부와 구현부의 분리 )</p></li><li><p>구문 분석기는 Interface를 구현해서 원하는 함수를 실행 가능 하다</p></li><li><p>Chapter 7. 객체지향 프로그래밍 2, p. 389</p></li><li><p>분산환경 프로그래밍에서 그 위력을 발휘한다.</p></li><li><p>사용자 컴퓨터에 설치된 프로그램을 변경하지않고 서버측의 변경만으로도 사용자가 새로 개정된 프로그럄을 사용하는것이 가능하다.</p></li><li><p>실제로 자바에서는 다수의 데이터베이스 관련된 다수의 인터페이스를 제공하고 있다.</p></li><li><p>이는 데이터베이스에 종속적이지 않은 프로그램을 구현 가능하게 한다.</p></li></ul><p>Arraycopy, fill</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(Object src, ins srcPos, Object dest, int destPos, int length)&#123;&#125;</span><br><span class="line">// 원본, 원본 시작 위치, 복사본, 복사본 시작위치, 복사본에서 읽어올 만큼</span><br><span class="line">// 원본 시작위치에서 복사본에다가 읽어올 만큼 읽어옴</span><br><span class="line"></span><br><span class="line">Arrays.fill(byte[] paramArrayOfByte, int paramInt1, int paramInt2, byte paramByte)&#123;&#125;</span><br><span class="line">// 원본 바이트 배열, 1부터 2까지 paramByte로 채우기</span><br><span class="line"></span><br><span class="line">Instanceof</span><br><span class="line">왼쪽의 피검사 오브젝트가 오른쪽의 검사 오브젝트인지 검사</span><br><span class="line"></span><br><span class="line">If (ProcessManager.getThreadDLV(key) instanceof SMSSEND)</span><br><span class="line">&#123;</span><br><span class="line">thread = new Thread (((SMSSEND) ProcessManager.getThreadDLV(key)));</span><br><span class="line">&#125;</span><br><span class="line">Else if (ProcessManager.getThreadDLV(key) instanceof MMSSEND)</span><br><span class="line">&#123;</span><br><span class="line">thread = new Thread (((MMSSEND) ProcessManager.getThreadDLV(key)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">초기화 블럭!!</span><br><span class="line"></span><br><span class="line">Class initBlock &#123;</span><br><span class="line">static &#123; /* 클래스 초기화 블럭 */ &#125;</span><br><span class="line">&#123; /*인스턴스 초기화 블럭 */ &#125;</span><br><span class="line">// …..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : 남궁성, 『 자바의 정석 3/E』, 도우출판(2016.1.27), chapter 7 인용.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;JAVA Interface&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;개발 시간을 단축시킬 수 있다. ( 설계도를 제공 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;표준화가 가능하다. (ex. Jdbc Interface )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서로 관
      
    
    </summary>
    
      <category term="Book" scheme="http://jungha-cho.github.io/categories/Book/"/>
    
      <category term="자바의 정석" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"/>
    
      <category term="Interface" scheme="http://jungha-cho.github.io/categories/Book/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/Interface/"/>
    
    
      <category term="자바의 정석" scheme="http://jungha-cho.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"/>
    
      <category term="Interface" scheme="http://jungha-cho.github.io/tags/Interface/"/>
    
  </entry>
  
  <entry>
    <title>engine</title>
    <link href="http://jungha-cho.github.io/2017/04/05/Engine/"/>
    <id>http://jungha-cho.github.io/2017/04/05/Engine/</id>
    <published>2017-04-05T14:43:59.000Z</published>
    <updated>2018-03-26T07:44:30.003Z</updated>
    
    <content type="html"><![CDATA[<h3>MyISAM ( Indexed Sequential Access Method )</h3><ul><li>결론부터, 트랜잭션 처리가 불필요하며 Select 속도가 빠르므로 조회작업 특화 엔진</li><li>비 트랜잭션 세이프(Non-Transaction-Safe)</li><li>테이블 단위 Lock (Table Level Locking) 쓰기(INSERT, UPDATE) 작업 속도가 느림, Select 속도가 빠름</li><li>Table 명세에 Row Count를 가지고 있음, <code>Select count(*) from TABLE</code> 빠름</li><li>InnoDB에 비해 단순, 데이터 모델 디자인 또한 단순, 따라서 전체적으로 InnoDB보다 빠름</li><li>Full-text 인덱싱 가능, 검색하고자 하는 내용에 대한 복합 검색 가능</li><li>But, 무결성 보장 안됨, 트랜잭션 보장 없음 즉, delete update시 복구 불가</li><li>Table Leve Locking은 한 테이블에 많은 접근이 이루어 질수록 속도가 느려짐</li></ul><h3>InnoDB()</h3><ul><li>결론부터, 데이터 입력과 수정이 빈번하고 다수, 동시접속, 높은 부하시 퍼포먼스가 좋고 대용량 데이터 처리가 필요할때</li><li>InnoDB는 인덱스 관리에 테이블 스페이스(Table Space) 사용</li><li>Commit, Rollback, 장애 복구 등 트랜잭션 지원</li><li>Full Text Index 미지원, 속도 MyISAM에 비해 느림</li><li>행 단위 Lock (Row Level Locking) - 변경 ( Insert, Update, Delete )에 대한 속도가 빠름</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;MyISAM ( Indexed Sequential Access Method )&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;결론부터, 트랜잭션 처리가 불필요하며 Select 속도가 빠르므로 조회작업 특화 엔진&lt;/li&gt;
&lt;li&gt;비 트랜잭션 세이프(Non-Transa
      
    
    </summary>
    
      <category term="DataBase" scheme="http://jungha-cho.github.io/categories/DataBase/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/DataBase/%EC%9D%BC%EB%B0%98/"/>
    
    
  </entry>
  
  <entry>
    <title>ShutDownHook</title>
    <link href="http://jungha-cho.github.io/2017/04/05/ShutDownHook/"/>
    <id>http://jungha-cho.github.io/2017/04/05/ShutDownHook/</id>
    <published>2017-04-05T14:43:59.000Z</published>
    <updated>2018-03-26T07:44:42.069Z</updated>
    
    <content type="html"><![CDATA[<p>프로세스가 종료될때 반드시 실행되어야 하는 코드를 임의로 정의할 수 있다.</p><p>Runtime Library에 정의되어 있다.</p><p>Shutdown Hook은 프로세스가 종료될때 반드시 실행되고 Hook이 끝날때까지는 프로세스도 종료되지 않는다.<br>Shutdown Hook은 짧게 작성되어야 한다. 머신 종료에 의한 프로세스 종료일때 JVM은 프로세스가 완전히 종료될때까지 기다리지 않고 일정 시간 후 종료한다. 따라서 Shutdown Hook은 Hook이 실행되기 전에 종료될 수도 있고 도중에 종료될 수도 있다.<br>Shutdown Hook은 반드시 실행되지는 않는다. Shutdown hook은 정상적인 종료 상황에서만 호출된다. 따라서 비정상적인 종료에서도 반드시 실행되어야 하는 일들은 Java App를 실행하는 스크립트를 작성하거나 App을 하나더 만든다.<br>비 정상적인 종료란?<br>에러 코드를 반환하는 것이 비정상적인 종료가 아니다.<br>System.exit로 호출되는 경우 status 코드를 무엇으로 반환하든지 정상 종료이다.<br>SIGTERM을 받아서 종료되는 경우에도 정상종료이다.<br>SIGTERM을 받은 프로세스는 정상적으로 Hook을 호출하고 Thread를 정리한다.<br>Handle되지 않은 Exception이 발생하는 경우에도 Java는 정상종료로 취급한다.<br>위의 3가지 경우엔 문제없이 Hook이 호출된다.<br>대표적 비정상 종료는 halt이다. halt는 프로세스 강제종료로 실행되는 즉시 종료된다.<br>프로세스가 SIGKILL을 받는 경우도 비정상 종료이다. SIGKILL은 SIGTERM과 달리 바로 종료된다.<br>JVM 문제가 발생해서 종료되는 경우도 있다.<br>예외</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;프로세스가 종료될때 반드시 실행되어야 하는 코드를 임의로 정의할 수 있다.&lt;/p&gt;
&lt;p&gt;Runtime Library에 정의되어 있다.&lt;/p&gt;
&lt;p&gt;Shutdown Hook은 프로세스가 종료될때 반드시 실행되고 Hook이 끝날때까지는 프로세스도 종
      
    
    </summary>
    
      <category term="Java" scheme="http://jungha-cho.github.io/categories/Java/"/>
    
      <category term="라이브러리" scheme="http://jungha-cho.github.io/categories/Java/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>Document</title>
    <link href="http://jungha-cho.github.io/2017/04/05/Document/"/>
    <id>http://jungha-cho.github.io/2017/04/05/Document/</id>
    <published>2017-04-05T14:43:59.000Z</published>
    <updated>2018-03-26T07:44:26.359Z</updated>
    
    <content type="html"><![CDATA[<p>XML 문서 전체를 메모리에 저장<br>트리 모델<br>org.w3c.dom.Node 인터페이스 기반,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import javax.xml.parsers.DocumentBuilder;</span><br><span class="line">import javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"></span><br><span class="line">import org.w3c.dom.Document;</span><br><span class="line">import org.w3c.dom.Element;</span><br><span class="line">import org.w3c.dom.Node;</span><br><span class="line">import org.w3c.dom.NodeList;</span><br><span class="line"></span><br><span class="line">public class docum &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder builder = factory.newDocumentBuilder();</span><br><span class="line">        Document doc = builder.parse(&quot;src/test/doc_test.xml&quot;);</span><br><span class="line">        Element root = doc.getDocumentElement();</span><br><span class="line">        System.out.println(&quot;ROOT: &quot; + root.getNodeName());</span><br><span class="line"></span><br><span class="line">        NodeList all = root.getChildNodes();</span><br><span class="line">        System.out.println(&quot;루트의 지식노드수 :&quot; + all.getLength());</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; all.getLength(); i++) &#123;</span><br><span class="line">            Node node = all.item(i);</span><br><span class="line">            System.out.println(&quot;자식노드 : &quot; + node.getNodeName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // personal 이라는 이름을 가진 요소들을 모두 가려내는 작업.</span><br><span class="line">        NodeList n_list = root.getElementsByTagName(&quot;personal&quot;);</span><br><span class="line">        // 첫번째 요소 personal이라는 요소</span><br><span class="line">        Element p = (Element) n_list.item(0);</span><br><span class="line">        Node s_node = n_list.item(0);</span><br><span class="line">        NodeList s_list = s_node.getChildNodes();</span><br><span class="line">        for (int i = 0; i &lt; s_list.getLength(); i++) &#123;</span><br><span class="line">            if (!s_node.getNodeName().equals(&quot;#text&quot;)) &#123;</span><br><span class="line">                Node no = s_node.getFirstChild();</span><br><span class="line">                System.out.println(no.getNodeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 얻어낸 personal의 자식요소들 중에서 name을 구하고 싶을때</span><br><span class="line">        NodeList names = p.getElementsByTagName(&quot;name&quot;);</span><br><span class="line">        Element el_name = (Element) names.item(0);</span><br><span class="line">        // name의 값을 구한다.</span><br><span class="line">        Node txt = el_name.getFirstChild();</span><br><span class="line">        System.out.println(&quot;Names: &quot; + txt.getNodeValue());</span><br><span class="line"></span><br><span class="line">        // personal의 두번째 요소중 phone을 구하자!</span><br><span class="line">        p = (Element) n_list.item(1);</span><br><span class="line">        names = p.getElementsByTagName(&quot;phone&quot;);</span><br><span class="line">        el_name = (Element) names.item(0);</span><br><span class="line">        txt = el_name.getFirstChild();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;phone: &quot; + txt.getNodeValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;XML 문서 전체를 메모리에 저장&lt;br&gt;
트리 모델&lt;br&gt;
org.w3c.dom.Node 인터페이스 기반,&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="Language" scheme="http://jungha-cho.github.io/categories/Language/"/>
    
      <category term="Java" scheme="http://jungha-cho.github.io/categories/Language/Java/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Language/Java/%EC%9D%BC%EB%B0%98/"/>
    
    
  </entry>
  
  <entry>
    <title>DesignPattern</title>
    <link href="http://jungha-cho.github.io/2017/04/05/DesignPattern/"/>
    <id>http://jungha-cho.github.io/2017/04/05/DesignPattern/</id>
    <published>2017-04-05T14:43:59.000Z</published>
    <updated>2018-03-26T07:37:16.158Z</updated>
    
    <content type="html"><![CDATA[<p>처음 업무를 맡아서 원 소스를 받았을때 코드를 보기가 힘들었다. 눈에 들어오지도 않을뿐더러 이게 왜 필요한 메소드인지 왜 필요한 로직인지 이해조차 할수 없었다. 내 스타일의 코딩이 아니었고 처음 보는 구조였고 내가 익숙한 코드도 아니었다. 온갖 핑계와 이해가 안된다며 스스로 안좋은 코드라고 정의내렸다. 이는 좋은 코드는 무엇인가에 대한 고민으로 이어졌고 또 이 원 소스가 정말로 안좋은 코드인가에 대한 고민과 이해에 대해 이어졌다. 결론은 내가 문제였다. 핑계로 점칠돼 소스를 이해하지도 않았고 이 소스의 진짜 문제가 무엇인지도 몰랐다.</p><p>이에 체계적이고 유지보수가 가능한, 또 적재 적소에 필요할때 사용할수 있는 또 누구에게나 익숙한 코딩 스타일과 패턴을 익히고 사용하기위해 디자인 패턴 공부의 필요성을 느꼈다.</p><h3>디자인 패턴이란?</h3><p>필요성을 느끼고 나서 이것저것 책도 살펴보고 검색도 해봤지만, 어려운 말 이해되지 않는 내용과 깊은 지식과 경험을 필요로하는 조언들이 넘쳐났다. 누군가가 오랫동안 생각하고 만들고 조언한 내용들이란것은 알겠지만, 이제 갖 디자인 패턴의 필요성을 느끼고 입문하려니 너무 어려운 말들 뿐이었다.</p><p>일단, 한걸음씩 오늘은 여러 부분에서 공통적으로 강조하는 SOLID 원칙에 대해 이해하고 넘어가자.</p><p>SRP ( 단일 책임 원칙 : Single Responsibility Principle ) : 하나의 클래스는 하나의 책임만 가져야 한다.<br>OCP ( 개방 / 폐쇄의 법칙 : Open/Closed Principle ) : 확장에는 열려있어야하고, 변경에는 닫혀있어야 한다.<br>LSP ( 리스코프 치환의 원칙 : Liskov Substitution Principle ) : 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.<br>ISP ( 인터페이스 분리 원칙 : Interface Segregation Principle ) : 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.<br>DIP ( 의존관계 역전의 법칙 : Dependency Inversion Principle ) : 추상화에 의존해야지 구체화에 의존하면 안된다.</p><p>더 자세한 내용!<br><a href="http://www.nextree.co.kr/p6960/" target="_blank" rel="noopener">http://www.nextree.co.kr/p6960/</a><br><a href="http://pooh-explorer.tistory.com/5" target="_blank" rel="noopener">http://pooh-explorer.tistory.com/5</a><br><a href="http://alleysark.tistory.com/197" target="_blank" rel="noopener">http://alleysark.tistory.com/197</a></p><p>출처: <a href="http://devshock.tistory.com/58" target="_blank" rel="noopener">http://devshock.tistory.com/58</a> [Developer]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;처음 업무를 맡아서 원 소스를 받았을때 코드를 보기가 힘들었다. 눈에 들어오지도 않을뿐더러 이게 왜 필요한 메소드인지 왜 필요한 로직인지 이해조차 할수 없었다. 내 스타일의 코딩이 아니었고 처음 보는 구조였고 내가 익숙한 코드도 아니었다. 온갖 
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/%EC%9D%BC%EB%B0%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Connection Pool</title>
    <link href="http://jungha-cho.github.io/2017/04/04/ConnectionPool/"/>
    <id>http://jungha-cho.github.io/2017/04/04/ConnectionPool/</id>
    <published>2017-04-04T13:43:59.000Z</published>
    <updated>2018-03-26T07:43:44.815Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Data Base Connection Pool이란, Java Programming에서 DB로 Connection을 맺을때 다수의 사용자들이 Connection을 요구 한다면 최악의 경우 Server가 다운되는 일이 발생할 수도 있다. 이를 해결하기 위해 Connection Pool을 이용한다.</li><li>Connection Pool은 Database와의 연결을 효율적으로 관리하는 역할을 한다.</li><li>사전에 일정량의 Connection 객체를 만들어 공유된 장소에 모아둠으로써 객체 생성에 걸리는 시간을 아끼고 속도 향상을 도모한다. 사용이 끝난 Connection 객체는 다시 공유된 장소에 넣어둔다.</li><li>DB에 연결하는 과정은 시간이 많이 소요되는 Cost가 비싼 연산이다. JDBC, DBCP, ORM</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Data Base Connection Pool이란, Java Programming에서 DB로 Connection을 맺을때 다수의 사용자들이 Connection을 요구 한다면 최악의 경우 Server가 다운되는 일이 발생할 수도 있다. 
      
    
    </summary>
    
      <category term="DataBase" scheme="http://jungha-cho.github.io/categories/DataBase/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/DataBase/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="기초" scheme="http://jungha-cho.github.io/tags/%EA%B8%B0%EC%B4%88/"/>
    
  </entry>
  
  <entry>
    <title>Lock</title>
    <link href="http://jungha-cho.github.io/2017/04/04/Lock/"/>
    <id>http://jungha-cho.github.io/2017/04/04/Lock/</id>
    <published>2017-04-04T13:40:59.000Z</published>
    <updated>2018-03-26T07:43:56.441Z</updated>
    
    <content type="html"><![CDATA[<h3>MySQL에서의 Lock</h3><p>데이터 베이스 접근 경쟁 제어를 위해 Lock을 사용한다. MySQL은 크게 Table Lock, Global Lock, Name Lock, User Lock이 존재한다.</p><h3>Table Lock</h3><p>어떤 세션이 테이블 자원에 엑세스해 데이터를 사용할때 다른 세션에서 테이블 자원에 대한 엑세스를 제한하는 락이다. 락을 걸면 락을 해지하기 전까지 세션은 접근을 못한다. 락을 사용하기 위해서는 테이블 락 권한이 필요하다.</p><h3>Global Lock</h3><p>Global Read Lock, 현재 세션에서 Global Read Lock을 사용할때 Flush table 이용</p><h3>Name Lock</h3><h3>User Lock</h3><p>사용자 레벨에서 락을 걸수 있는 방법, GET_LOCK, RELEASE_LOCK</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;MySQL에서의 Lock&lt;/h3&gt;
&lt;p&gt;데이터 베이스 접근 경쟁 제어를 위해 Lock을 사용한다. MySQL은 크게 Table Lock, Global Lock, Name Lock, User Lock이 존재한다.&lt;/p&gt;
&lt;h3&gt;Table Lock
      
    
    </summary>
    
      <category term="Java" scheme="http://jungha-cho.github.io/categories/Java/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Java/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="기초" scheme="http://jungha-cho.github.io/tags/%EA%B8%B0%EC%B4%88/"/>
    
  </entry>
  
  <entry>
    <title>MDC</title>
    <link href="http://jungha-cho.github.io/2017/04/04/MDC/"/>
    <id>http://jungha-cho.github.io/2017/04/04/MDC/</id>
    <published>2017-04-04T13:16:59.000Z</published>
    <updated>2018-03-26T07:44:04.455Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Simple Logging Facade for Java (SLF4J)는 다양한 로깅 프레임워크(Log4j, java.util.logging, logback 등)를 위한 간단한 추상계층</p></li><li><p>MDC 지원</p></li><li><p>java.util.Map 형식을 이용하여 클라이언트 특징적인 데이타를 저장하기 위한 메카니즘이</p></li><li><p>로깅 프레임워크에 의해 유지되는 Map</p></li><li><p>응용 프로그램이 Key-Value 쌍으로 제공</p></li><li><p>로깅 프레임워크에 의해 로깅 메세지 안으로 추가될 수 있다. SLF4J, Logback만 MDC 지원</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Simple Logging Facade for Java (SLF4J)는 다양한 로깅 프레임워크(Log4j, java.util.logging, logback 등)를 위한 간단한 추상계층&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MDC 지원
      
    
    </summary>
    
      <category term="Java" scheme="http://jungha-cho.github.io/categories/Java/"/>
    
      <category term="Logging" scheme="http://jungha-cho.github.io/categories/Java/Logging/"/>
    
    
      <category term="Logging" scheme="http://jungha-cho.github.io/tags/Logging/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse 유용한 단축키</title>
    <link href="http://jungha-cho.github.io/2017/04/04/eclipse%EC%9C%A0%EC%9A%A9%ED%95%9C%EB%8B%A8%EC%B6%95%ED%82%A4/"/>
    <id>http://jungha-cho.github.io/2017/04/04/eclipse유용한단축키/</id>
    <published>2017-04-04T13:16:59.000Z</published>
    <updated>2018-03-26T07:34:10.907Z</updated>
    
    <content type="html"><![CDATA[<h3>실행</h3><ol><li><p>Ctrl + F11 : 바로 전에 실행했던 클래스 실행 소스 네비게이션</p></li><li><p>Ctrl + 마우스커서(혹은 F3) : 클래스나 메소드 혹은 멤버를 상세하게 검색하고자 할때</p></li><li><p>Alt + -&gt;, Alt + &lt;- : 이후, 이전</p></li><li><p>Ctrl + o : 해당 소스의 메소드 리스트를 확인하려 할때</p></li><li><p>F4 : 클래스명을 선택하고 누르면 해당 클래스의 Hierarchy 를 볼 수 있다.</p></li><li><p>Ctrl + Shift + R : 파일 쉽게 열기 (파일명으로 검색) 문자열 찾기</p></li><li><p>Ctrl + K : 찾고자 하는 문자열을 블럭으로 설정한 후 키를 누른다.</p></li><li><p>Ctrl + Shift + K : 역으로 찾고자 하는 문자열을 찾아감.</p></li><li><p>Ctrl + J : 입력하면서 찾을 수 있음.</p></li><li><p>Ctrl + Shift + J : 입력하면서 거꾸로 찾아갈 수 있음.</p></li><li><p>Ctrl + F : 기본적으로 찾기</p></li></ol><h3>소스 편집</h3><ol><li>Ctrl + Shift + F : 코드 자동 정리</li><li>Ctrl + Shift + G : 특정 메써드나 필드를 Reference하고 있는 곳을 찾는다.</li><li>Ctrl + 1 : Quick Fix. 에러가 발생했을 경우 Quick Fix를 통해 쉽게 해결이 가능하다.</li><li>CTRL + L : 특정 줄번호로 가기</li><li>Alt + Shift + J : 자동으로 주석 달기 (메소드나 멤버변수에 포커스 두고 실행)</li><li>F2 : 컴파일 에러의 빨간줄에 커서를 갖져다가 이 키를 누르면 에러의 원인에 대한 힌트를 제공한다.</li><li>Ctrl + L : 원하는 소스 라인으로 이동<br>로컬 히스토리 기능을 이용하면 이전에 편집했던 내용으로 변환이 가능하다.</li><li>Ctrl + Shift + Space : 메소드의 가로안에 커서를 놓고 이 키를 누르면 파라미터 타입 힌트를 볼 수 있다.</li><li>한 줄 삭제 CTRL + D</li><li>파일 닫기 : CTRL+W</li><li>들여쓰기 자동 수정. (3.0 NEW) : CTRL+I</li><li>블록 주석(/<em>…</em>/) 추가.(3.0 NEW): CTRL+SHIFT+/</li><li>Ctrl + / 해주면 여러줄이 한꺼번에 주석처리됨. 주석 해제하려면 반대로 하면 됨.</li><li>위(아래)줄과 바꾸기 : ALT+UP(DOWN)</li><li>블록 선택하기. : ALT+SHIFT+방향키</li><li>메소드의 파라메터 목록 보기. : CTRL+SHIFT+SPACE</li><li>자동으로 import 하기 : CTRL+SHIFT+O</li><li>열린 파일 모두 닫기 : CTRL + SHIFT + F4</li><li>전체화면 토글 : CTRL+M</li><li>한 줄(블럭) 복사 : Ctrl + Alt + 위(아래)</li><li>다음 annotation(에러, 워닝, 북마크 가능)으로 점프 : Ctrl + , or .</li><li>메소드 정의부로 이동 : F3</li><li>하이어라키 팦업 창 띄우기(인터페이스 구현 클래스간 이동시 편리) : Ctrl + T</li><li>메소드나 필드 이동하기 CTRL + O</li><li>ULTRAEDIT나 EDITPLUS 의 CTRL+TAB 과 같은 기능. : CTRL+F6</li></ol><h3>템플릿 사용</h3><ol><li>sysout 입력한 후 Ctrl + Space 하면 System.out.println(); 으로 바뀐다.</li><li>try 입력한 후 Ctrl + Space 하면 try-catch 문이 완성된다.</li><li>for 입력한 후 Ctrl + Space 하면 여러가지 for 문을 완성할 수 있다.</li><li>템플릿을 수정하거나 추가하려면 환경설정/자바/편집기/템플리트 에서 할 수 있다.</li></ol><h3>메소드 쉽게 생성하기</h3><p>클래스의 멤버를 일단 먼저 생성한다.</p><ol><li>override 메소드를 구현하려면 : 소스-&gt;메소드대체/구현 에서 해당 메소드를 체크한다.</li><li>기타 클래스의 멤버가 클래스의 오브젝트라면 : 소스-&gt;위임메소드 생성에서 메소드를 선택한다.</li></ol><h3>Organize import</h3><ol><li>자바파일을 여러개 선택한 후 소스 -&gt; 가져오기 체계화 해주면 모두 적용된다.</li></ol><h3>소스 코드 형식 및 공통 주석 설정</h3><ol><li><p>환경설정 -&gt; 자바 -&gt; 코드 스타일 -&gt; 코드 포멧터 -&gt; 가져오기 -&gt; 프로파일.xml 을 불러다가 쓰면 된다.</p></li><li><p>또한 다수의 자바파일에 프로파일을 적용하려면 패키지 탐색기에서 패키지를 선택한 후 소스 -&gt; 형식화를 선택하면 된다.</p></li><li><p>환경설정 -&gt; 자바 -&gt; 코드 스타일 -&gt; 코드 템플리트 -&gt; 가져오기 -&gt; 템플리트.xml 을 불러다가 쓰면 된다.<br>에디터 변환</p></li><li><p>에디터가 여러 파일을 열어서 작업중일때 Ctrl + F6 키를 누르면 여러파일명이 나오고 F6키를 계속 누르면 아래로</p></li><li><p>Ctrl + Shift + F6 키를 누르면 위로 커서가 움직인다.</p></li><li><p>Ctrl + F7 : 뷰간 전환</p></li><li><p>Ctrl + F8 : 퍼스펙티브간 전환</p></li><li><p>F12 : 에디터로 포커스 위치</p></li></ol><h3>디버깅 단축키</h3><ol><li>CTRL + Shift + B : 현 커서의 위치에 브레이크 포인터 설정/해제</li><li>F11 : 디버깅 시작</li><li>F8 : 디버깅 계속</li><li>F6 : 한줄씩 실행(Step Over)</li><li>F5 : 한줄씩 실행하되 함수일 경우 그 함수 내부로 들어감(Step Into)</li><li>CTRL + R : 현재 라인까지 실행(Run to Line)</li></ol><p><a href="http://www.dreamy.pe.kr/zbxe/CodeClip/163389" target="_blank" rel="noopener">http://www.dreamy.pe.kr/zbxe/CodeClip/163389</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;실행&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ctrl + F11 : 바로 전에 실행했던 클래스 실행 소스 네비게이션&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ctrl + 마우스커서(혹은 F3) : 클래스나 메소드 혹은 멤버를 상세하게 검색하고자 할때&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Tools" scheme="http://jungha-cho.github.io/categories/Tools/"/>
    
      <category term="IDE" scheme="http://jungha-cho.github.io/categories/Tools/IDE/"/>
    
      <category term="Eclipse" scheme="http://jungha-cho.github.io/categories/Tools/IDE/Eclipse/"/>
    
    
      <category term="단축키" scheme="http://jungha-cho.github.io/tags/%EB%8B%A8%EC%B6%95%ED%82%A4/"/>
    
  </entry>
  
  <entry>
    <title>LogBack (slf4j)</title>
    <link href="http://jungha-cho.github.io/2017/04/04/LogBack(slf4j)/"/>
    <id>http://jungha-cho.github.io/2017/04/04/LogBack(slf4j)/</id>
    <published>2017-04-04T13:06:59.000Z</published>
    <updated>2018-03-26T07:44:02.958Z</updated>
    
    <content type="html"><![CDATA[<h3>Logging Framework, Logback</h3><ul><li>Logback은 slf4j의 native 구현체</li><li>Logback은 logback-core, logback-classic, logback-access 3개의 모듈로 구성</li><li>core는 classic, access의 모듈</li></ul><h3>name</h3><ul><li>Logger들은 이름 기반으로 생성</li><li>LoggerFactory.getLogger(“NAME”)으로 Logger를 호출</li><li>NAME에 대한 유일한 instance 반환, 여러번 호출해도 똑같은 객체</li><li>흔히 Class 객체 넘겨주면 ,PackageName + ClassName으로 구성</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  example.logback.level.Grandparents</span><br><span class="line">  example.logback.level.grandparents.Parents</span><br><span class="line">  example.logback.level.grandparents.parents.Children   </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  private static final Logger logger = LoggerFactory.getLogger(Grandparents.class);</span><br><span class="line">  private static final Logger logger = LoggerFactory.getLogger(Parents.class);</span><br><span class="line">  private static final Logger logger = LoggerFactory.getLogger(Children.class);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">// 각각 클래스마다 구현</span><br><span class="line">public void run() &#123;</span><br><span class="line">    logger.trace(&quot;trace&quot;);</span><br><span class="line">    logger.debug(&quot;debug&quot;);</span><br><span class="line">    logger.info(&quot;info&quot;);</span><br><span class="line">    logger.warn(&quot;warn&quot;);</span><br><span class="line">    logger.error(&quot;error&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위처럼 Class GrandParents, Parents, Children을 위와 같은 구조로 생성하고 아래처럼 Logger를 Class 마다 생성하면 3개의 Logger가 Full Package+ClassName으로 생성됨</p><h3>Level</h3><ul><li>Logger들은 Tree Hierarchy 구조로 Level을 적용 받을 수 있음</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LogBack.xml</span><br><span class="line"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;Pattern&gt;%d&#123;HH:mm&#125; %-5level %logger&#123;36&#125; - %msg%n&lt;/Pattern&gt;</span><br><span class="line">        &lt;/layout&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;logger name=&quot;example.logback.level.grandparents&quot; level=&quot;TRACE&quot;/&gt;</span><br><span class="line">    &lt;logger name=&quot;example.logback.level.grandparents.parents.children&quot; level=&quot;INFO&quot;/&gt;</span><br><span class="line">    &lt;root level=&quot;DEBUG&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>여기서 root는 root logger를 말한다.</p><h3>Level</h3><ol><li>trace</li><li>debug</li><li>info</li><li>warn</li><li>error</li></ol><ul><li>위 처럼 5단계의 Level 이 존재하고, Trace 선언을 하면 trace 밑으로 debug, info, warn, error 등 모든 level을 포함</li><li>INFO로 설정되면 info, warn, error 포함</li></ul><h3>Appender</h3><ul><li>Event 마다 log를 기록하는 기능은 Appender가 처리</li><li>Logger는 어떤 Appender에 할당되어 처리 되는지가 중요</li><li>Appender를 설정하더라도 Log 출력에 해당되지 않으면 작동하지 않음</li><li>Appender는 출력될 형식을 직접 가지고 있지 않고, Layout과 Encoder에 위임</li><li>ConsoleAppender, FileAppender, RollingFileAppender</li></ul><h3>Configuration</h3><ul><li>LogBack이 구동될때 LogBack 설정 - LogBack.xml</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;Logging Framework, Logback&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Logback은 slf4j의 native 구현체&lt;/li&gt;
&lt;li&gt;Logback은 logback-core, logback-classic, logback-access 3개의 
      
    
    </summary>
    
      <category term="Java" scheme="http://jungha-cho.github.io/categories/Java/"/>
    
      <category term="Logging" scheme="http://jungha-cho.github.io/categories/Java/Logging/"/>
    
    
      <category term="Logging" scheme="http://jungha-cho.github.io/tags/Logging/"/>
    
  </entry>
  
  <entry>
    <title>try catch문의 finally와 return의 우선순위</title>
    <link href="http://jungha-cho.github.io/2017/04/04/trycatch%EB%AC%B8%EC%9D%98finally%EC%99%80return%EC%9D%98%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84/"/>
    <id>http://jungha-cho.github.io/2017/04/04/trycatch문의finally와return의우선순위/</id>
    <published>2017-04-04T12:48:00.000Z</published>
    <updated>2018-03-26T07:44:07.550Z</updated>
    
    <content type="html"><![CDATA[<p>코딩 중 Try Catch 문에서 생각치 못한 것을 만났다. 바로 Finally와 return문의 우선순위 이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class TryCatchFinally</span><br><span class="line">&#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    if(returnTest())&#123;</span><br><span class="line">      System.out.println(&quot;returnTest is True&quot;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        System.out.println(&quot;returnTest is False&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static boolean returnTest() &#123;</span><br><span class="line">      try&#123;</span><br><span class="line">        return true;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">          return 0;</span><br><span class="line">          &#125;finally&#123;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>위 코드를 실행하면 어떻게 될까? true? false? 아니면 0?</p><p>나는 항상 return문에 최우선 순위를 두고 코딩을 했었는데 finally도 예외는 아니었다.<br>단순히 IO 작업이나 소켓같은 close를 꼭 호출해야하는 코딩에서만 사용했기에 크게 깊이 생각하지도 않았다.</p><p>결론적으로 말하자면 위 코드는 returnTest is False를 출력한다. try catch문에 있어서는 모든 경우를 따지지 않고 return이 호출된 이후에도 fianlly가 제일 마지막으로 호출되며 종료된다.<br>이는 catch문 안에 있는 return도 예외가 아니다. try문 안에서 예외가 발생했더라도 fianlly에서 return을 호출하게 되면 정상 종료로 인식하게 되고 catch의 Exception 구문을 생략해 버린다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;코딩 중 Try Catch 문에서 생각치 못한 것을 만났다. 바로 Finally와 return문의 우선순위 이다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="Java" scheme="http://jungha-cho.github.io/categories/Java/"/>
    
      <category term="문법" scheme="http://jungha-cho.github.io/categories/Java/%EB%AC%B8%EB%B2%95/"/>
    
    
      <category term="문법" scheme="http://jungha-cho.github.io/tags/%EB%AC%B8%EB%B2%95/"/>
    
  </entry>
  
  <entry>
    <title>Java-Programming-지침-(설계편)</title>
    <link href="http://jungha-cho.github.io/2017/04/04/JavaProgramming%EC%A7%80%EC%B9%A8(%EC%84%A4%EA%B3%84%ED%8E%B8)/"/>
    <id>http://jungha-cho.github.io/2017/04/04/JavaProgramming지침(설계편)/</id>
    <published>2017-04-04T12:19:59.000Z</published>
    <updated>2018-03-26T07:43:50.444Z</updated>
    
    <content type="html"><![CDATA[<h2>1. 고상하면 언제나 득이된다.</h2><ul><li>짧게 보면 문제에 대해 진정으로 우아한 해결책에 도달하는 게 오히려 시간이 더 걸리는 것처럼 보이겠지만, 처음에만 제대로 해서 몇 시간, 며칠, 몇 달을 고생하지 않고 새로운 상황에 쉽게 적용할 수 있는 것이(누구도 값을 매길 수 없는) 보상이 될 것이다.<br>이렇게 하면 프로그램을 구축하고 디버그하는 일이 쉬워질 뿐만 아니라, 이해하고 유지하는 일도 쉬워지며, 재정적으로도 이득이다.<br>이 점을 이해하려면 어느 정도 경험이 있어야 하는데, 왜냐하며 고상한 코드를 작성하는 일이 생산적인 것처럼 보이지 않기 때문이다. 서두르지 말자. 천천히 해야 할 일이다.</li></ul><h2>2. 먼저 동작하게 하고 그 다음에 빠르게 하라.</h2><ul><li>정말 중요한 코드이고 시스템에서 주된 명복 지점이 될 게 확실하더라도 이것은 사실이다. 그러지 말자.<br>먼저 가능한 간단한 설계로 시스템을 운영하고 나서 속도가 충분히 나지 않으면 프로파일하라.<br>대부분은 병목 지점이 문제가 아닐 것이다. 정말 중요한 부분에 시간을 투자하자.</li></ul><h2>3. “나누어서 정복하기” 원칙을 기억하라.</h2><ul><li>다루고 있는 문제가 너무 혼란스럽다면, 프로그램이 해야 하는 기본적인 작업이 무엇인지 상상해본다.<br>그러면 구체적인 부분을 다루는 마법의 &quot;조각&quot;이 나타난다. 그 &quot;조각&quot;이 객체이다. 객체를 사용하는 코드를 작성하고 나면, 객체를 살펴보고 그것의 그체적인 부분은 다른 객체 안으로 캡슐화 하든가 하라.</li></ul><h2>4. 클래스 사용자(클라이언트 프로그래머)로부터 클래스 창조자를 분리하라.</h2><ul><li>클래스 사용자는 &quot;고객&quot;이기에 클래스 뒤에 뭐가 있는지 알 필요도 없고 알고 싶어 해서도 안된다.<br>클래스 창조자는 클래스 설계에 있어서 전문가이어야 하고, 가능하면 초보 프로그래머가 사용할 수 있으면서 애플리케이션에서 제대로 작동하도록 클래스를 작성해야 한다. 클래스를 다른 클래스에 대한 서비스 제공자로 생각하라. 명확한 라이브러리는 사용하기도 쉽다.</li></ul><h2>5. 클래스를 작성할 때 주석이 필요없을 만큼 이름을 확실하게 하라.</h2><ul><li>여러분의 목표는 클라이언트 프로그래머에 대한 인터페이스를 간단하게 하는 것이다. 그렇게 하기 위해서, 직관적이고 사용하기 쉬운 인터페이스를 만들기에 적당하다면 메소드 과부하를 이용하라.</li></ul><h2>6. 여러분의 분석과 설계를 최소한 시스템 안의 클래스, 그것의 public 인터페이스, 다른 클래스 특히 기반 클래스와의 관계를 생산해야 한다.</h2><ul><li>만약 설계 방법론이 그 이상을 생산한다면, 방법론으로 만들어진 조각들이 프로그램 수명 이상의 가치를 갖는지 여러분 자신에게 물어보라.<br>개발팀의 인원들은 생산성에 도움이 되지 않는 것을 유지하려고 하지 않는다.<br>이것은 많은 설계 방법론이 설명하지 못하는 삶의 진실이다.</li></ul><ol start="7"><li>모두 자동화하라.</li></ol><ul><li>테스트 코드를 먼저(클래스를 작성하기 전에) 작성하고 클래스와 함께 유지하라. 빌드 툴을 이용하여 테스트를 자동화하라. 아마 실질적으로 표준 자바 자바 빌드 툴, Ant를 사용하고 싶을 것이다.</li></ul><blockquote><p>이렇게 하면 테스트 코드가 실행되면서모든 변경사항이 자동으로 검증되고, 바로 에러를 발견할 수 있다.<br>테스트 프레임워크라는 안전 그물이 있기 때문에 여러분은 필요할 때 변경하는 일에 좀더 과감해질 것이다.<br>타입 검사, 예외 처리 등을 제공하는 내장 테스트가 언어에서는 굉장한 개선점이지만, 여러분에게는 그 뿐이라는 사실을 기억하라. 여러분의 클래스나 프로그램에 특정한 기능을 검증하는 테스트를 채워서 단단한 시스템을 만드는 일은 여러분의 몫이다.</p></blockquote><h2>8. 클래스 설계가 완전한지 확인하기 위해 테스트 코드를 먼저(클래스 작성하기 전에) 작성하라.</h2><ul><li>테스트 코드를 작성하지 않으면 클래스가 어떤 모습인지 알 수 없다. 게다가 테스트 코드를 작성하다 보면 클래스에 필요한 추가 기능이나 제안이 떠오르곤 한다 (이러한 기능이나 제한은 분석 및 설계 단계에서는 나타나지 않는다).<br>테스트는 클래스를 어떻게 사용하는 보여주는 예제 코드이기도 하다.</li></ul><h2>9. 모든 소프트웨어 설계 문제는 개념상의 샛길을 추가하면 간단해진다.</h2><ul><li>소프트웨어 엔지니어링의 기본 법칙은 객체지향 프로그래밍의 주요 특성이 추상화이다.<br>OOP에서는 &quot;코드가 너무 복잡하다면 객체를 더 만들라&quot;라고 말할 수 있다.</li></ul><h2>10. (지침 9와 함께) 모든 샛길에는 의미가 있어야 한다.</h2><ul><li>여기서 의미란 &quot;공통으로 사용하는 코드는 하나의 메소드에 넣는다&quot;처럼 간단해야 한다.<br>의미없는 샛길(추상화, 캡슐화 등)을 추가하는 것은 안하는 것과 같다.</li></ul><h2>11. 클래스는 가능한 작게 하라.</h2><ul><li><p>클래스마다 한 가지씩 명확한 목적(다른 클래스에 제공하는 응집도가 높은 서비스)을 부여하라. 클래스나 시스템 설계가 너무 복잡해지면 복잡한 클래스를 간단한 것으로 나누라. 이것을 알 수 있는 척도는 순전히 크기 뿐이다.<br>클래스가 크면 너무 많을 일을 할 수 있으므로 나누어줘야 한다.</p></li><li><p>클래스 재설계를 암시하는 실마리는 다음과 같다.</p></li></ul><ol><li>복잡한 switch 문 -&gt; 다형성을 고려하라.</li><li>서로 다른 종류의 작업을 감당하는 수많은 메소드 -&gt; 클래스 사용을 고려하라.</li><li>서로 다른 특성과 관계가 있는 수많은 멤버 변수 -&gt; 클래스 사용을 고려하라.</li><li>다른 실마리는 Martin Fowler의 [Refactoring: Improving the Design of Existing Code(Addison-Wesley 1999)에서 찾을 수 있다.</li></ol><h2>12. 긴 인자 목록을 주의하라.</h2><ul><li>그렇게 되면 메소드 호출을 작성하고 읽고 유지되는 일이 어려워진다.<br>그 대신 메소드를 좀 더 알맞은 클래스로 옮기던가 객체를 인자로 넘겨 주도록 하라.</li></ul><h2>13. 반복하지 말라.</h2><ul><li>코드 조각이 유도 클래스의 메소드에서 자주 반복된다면, 그 코드를 기반 클래스의 메소드 하나에 놓고 유도 클래스에서 그 메소드를 호출하라.<br>코드 공간을 절약할 뿐만 아니라 변경사항도 쉽게 전파된다. 이렇게 발견된 공통 코드는  인터페이스에 유익한 기능을 더해주기도 한다.<br>상속 관계가 아니면 이 지침은 더 간단하다. 클래스의 메소드에서 코드가 반복된다면, 그 코드를 공통 메소드로 분리해서 다른 메소드에서 호출하라.</li></ul><h2>14. switch 문과 연속된 if-else절을 주의하라.</h2><ul><li>이것은(처음에는 정확하게 알 수 없는)일존의 타입 정보에 따라 실행할 코드를 결정하는 타입 검사 코드에 대한 전형적인 지표이다.<br>보통 이런 종류의 코드는 상속과 다형성으로 대체할 수 있다. 다형적인 메소드 호출이 타입을 검사해주며, 보다 믿을 수 있고 확장하기 쉽다.&gt;</li></ul><h2>15. 설계 관점에서 변하는 것을 찾아서 변하지 않는 것과 구분하라.</h2><ul><li>다시 말해서, 시스템에서 재설계를 강요하지 않으면서 변경하고자 하는 요소를 찾아서 클래스로 캡슐화 하라.<br>이 개념에 대해서는 www.BruceEckel.com의 [Thinking in Patterns(with java)]에서 더 많이 배울 수 있다.</li></ul><h2>16. 서브 클래스에서 기본 기능을 확장하지 말라.</h2><ul><li>기반 클래스에 속하는 클래스에 인터페이스 요소가 필요하다면, 도출할 때 추가하지 말라.<br>상속할 때 메소드를 추가한다면 설계를 재검토해야 한다.</li></ul><h2>17. 작을수록 좋다.</h2><ul><li>최소한의 인터페이스로 클래스를 시작하라, 문제를 바로 해결하는 데 필요한 만큼 작고 간단하게, 하지만 클래스가 어떻게 사용될지 예측하려고 하지 말라. 클래스를 사용해보면 인터페이스를 확장해야 한다는 사실을 알게 된다. 하지만, 한 번 클래스를 사용하면 클라이언트 코드를 엎지 않고는 인터페이스를 축소할 수 없다. 메소드를 추가하고 싶다면, 그건 괜찮다. 그런다고 코드를 엎지 않는다. 새로운 메소드가 예전 것의 기능을 대신한다고 해도 기존 인터페이스는 남겨 두어야 한다(원한하면 내부 구현을 행하면서 기능을 조합할 수 있다). 기존 메소드에 인자를 추가해서 인터페이스를 확장하고 싶다면, 새로운 인자로 과부하 메소드를 만들라. 이렇게 하면 기존 메소드 호출을 방해하지 않는다.</li></ul><h2>18. 논리적인지 확인하기 위해 클래스를 큰소리로 읽으라.</h2><ul><li>기반 클래스와 유도 클래스 사이의 관계는 &quot;is-a&quot;이고 멤버 객체 사이의 관계는 &quot;has-a&quot;라는 것을 참고하라.</li></ul><h2>19. 상속과 합성 관계 중에서 결정할 때는 기반 타입으로 상향 캐스트할 필요가 있는지 고려하라.</h2><ul><li>그렇지 않다면 합성 관계(멤버 객체)가 상속보다 좋다. 그렇게 하면 여러가지 기반 타입을 알지 않아도 된다.<br>상속한다면 사용자는 클래스가 상향 캐스트될 거라고 예측할 것이다.</li></ul><h2>20. 필드는 값의 다양함에, 메소드 오버라이드는 행위의 다양함에 사용하라.</h2><ul><li>다시 말해서, 상태 변수에 따라서 행위를 변경하는 메소드가 클래스 안에 있다면, 서브 클래스와<br>오버라이드한 메소드로 행위의 차이를 표현하도록 재설계해야 한다.</li></ul><h2>21. 과부하를 주의하라.</h2><ul><li>메소드는 인자값에 따라서 선택적으로 실행되어서는 안 된다.<br>이 경우, 두 개 이상의 과부하 메소드를 대신 작성한다.</li></ul><h2>22. 예외 계층 구조를 활용하라.</h2><ul><li>이왕이면 표준 자바 예외 계층 구조에 있는 클래스로부터 도출한다. 예외를 잡는 쪽은 기반 타입의 핸들러를 본떠서 특정 타입의 예외에 대한 핸들러를 작성할 것이다. 새로 도출된 예외를 추가해도 기존 클라이언트 코드는 여전히 기반 타입을 통해서 예외를 잡을 것이다.</li></ul><h2>23. 가끔 간단한 집합 관계가 도움이 된다.</h2><ul><li>비행기의 &quot;승객 편의 시설&quot;은 단절된 요소로 이루어져 있다. 의자, 에어컨, 비디오 등이 그것이고, 게다가 비행기 한 대에 이러한 것들이 많이 있다.<br>private 멤버를 만들고 모든 인터페이스를 새로 만들어야 하나? 아니다.<br>이 경우 컴포넌트 또한 public 인터페이스의 일부이므로 public 멤버 객체를 만들어야 한다. 그 객체들은 여전히 개별적으로 구현되므로 안전하다. 간단한 집합 관계는 자주 사용되는 해결책을 아니지만 간혹 도움이 된다는 사실을 알아두라.</li></ul><h2>24. 클라이언트 프로그래머와 코드 유지보수자의 입장을 고려하라. 가능한 사용하기 명확하게 클래스를 설계하라.</h2><ul><li>가능한 변경사항을 예측하고 그러한 변경사항이 쉽게 이루어질 수 있도록 클래스를 설계하라.</li></ul><h2>25. &quot;거대한 객체 신드롬&quot;을 주의하라.</h2><ul><li>이것은 막 OOP에 입문한 절차적 프로그래머에게는 골칫거리가 되는데 그들은 절차적 프로그램을 작성해서 한 두 개의 거대한 객체에 붙여넣는 식으로 처리한다. 애플리케이션 프레임워크를 제외하면 객체는 애플리케이션에서의 개념을 대표하지 애플리케이션 자체를 대표한다.</li></ul><h2>26. 추잡함 무언가를 해야 한다면, 적어도 그 추잡함을 클래스로 한정하라.</h2><h2>27. 이식성이 없는 무언가를 해야 한다면, 추상화해서 클래스 안에 넣으라.</h2><ul><li>이 샛길을 비이식성이 프로그램 전체에 퍼지는 것을 막아준다(이 관습은 다른 것보다도 &quot;Bridge 패턴&quot;에 구체적으로 표현되어 있다).&gt;</li></ul><h2>28. 객체는 단지 데이터만 갖고 있어서는 안된다.</h2><ul><li>잘 정의된 행위도 갖고 있어야 한다(간혹 &quot;데이터 객체&quot;가 어울리긴 하지만, 일반적인 컨테이너로 충분하지 못한 경우 한무리의 항목을 묶어서 넘겨줄 때 뿐이다).</li></ul><h2>29. 기존 클래스로부터 새로운 클래스를 만들 때 먼저 합성 관계를 선택하라.</h2><ul><li>설계에서 필요한 경우에만 상속 관계를 이용한다. 합성 관계로도 가능한  상속 관계를 이용한다면 설계가 불필요하게 복잡해질 것이다.</li></ul><h2>30. 상속 관계를 이용하고 행위의 차이를 표현하려면 오버라이드를, 여러 가지 상태를 효현하려면 필드를 사용하라.</h2><ul><li>극단적인 예를 들면 색상을 나타내는 클래스를 상속하지 않고 “color” 필드를 사용하는 것이다.</li></ul><h2>31. 변이를 주의하라.</h2><ul><li>의미상으로 서로 다른 두 개의 객체가 동일한 행동을 하거나 책임을 갖는다면, 당연히 하나를 다른 하나의 서브 클래스로 만들어서 상속 관계의 이득을 보려는 욕구가 생길 것이다. 이것은 변이(vartrance)라고 하는데, 여기에는 있지도 않은 슈퍼 클래스/서브 클래스 관계를 강요할 수 있는 정당성이 없다. 좀더 좋은 해결책은 두 개의 유도 클래스에 인터페이스를 제공하는 일반적인 기반 클래스를 만드는 것이다. 이것은 공간을 조금 차지하긴 하지만, 여전히 상속으로 인한 이득을 볼 수 있으면 설계의 중요성을 알게해줄 것이다.</li></ul><h2>32. 상속의 한계를 주의하라.</h2><ul><li>깨끗한 설계는 상속된 것에 새로운 기능을 추가한다. 수상한 설계는 상속할 때 새로운 것을 추가하지 않고 예전 기능을 없애 버린다. 하지만 규칙은 깨지기 마련인데, 예전 클래스 라이브러리를 사용한다면, 예전 클래스 위에 새로운 클래스가 제자리를 찾도록 계측 구조를 재구성하는 것보다 서브 클래스에서 기존 클래스를 제한하는 게 보다 효과적인 것이다.</li></ul><h2>33. &quot;드러난 기능&quot;을 없애기 위해 디자인 패턴을 사용하라.</h2><ul><li>다시 말해서, 클래스에서 하나의 객체만 생성되어야 한다고 해서 &quot;하나만 만드시오&quot;라고 주석을 달아서 애플리케이션 앞에 못박으면 안 된다.<br>싱글톤으로 감싸라.<br>객체를 생성하는 코드가 메인 프로그램 여기저기에 널려 있다면 생성 작업을 캡슐화하는 팩토리 메소드 같은 생성 패턴을 찾으라.<br>&quot;드러난 기능&quot;을 없애는 일은 코드를 이해하고 유지하기 쉽게 할 뿐만 아니라 뒤에서 쫓아오는 선의의 유지보수자에 대한 방탄막이 될 것이다.</li></ul><h2>34. &quot;분석 마비&quot;를 주의하라.</h2><ul><li>보통 모든 것을 알기도 전에 프로젝트가 진행되는데, 모르는 부분을 알게 되는 가장 빠르고 좋은 방법은 머리 속으로 생각하는 것이 아니라 다음 단계로 넘어가는 것이라는 사실을 기억하라. 해결책을 갖기 전에는 해결책을 알 수 없다.<br>자바에는 내장 방화벽이 있다. 그것이 작동하도록 내버려 두라. 하나 혹은 일련의 클래스에 실수를 했다고 해서 전체 시스템을 파괴하지 않는다.</li></ul><h2>35. 좋은 분석이나 설계, 구현이라고 생각되면 검토하라.</h2><ul><li>그룹 밖에 누군가를 데려오라. 컨설턴트일 필요는 없지만, 회사 내 다른 그룹의 누군가여야 한다.<br>신선한 두 눈으로 리뷰한다면 고치기 쉽고 지불해야 할 시간과 돈을 검토 과정에서 “잃어버리는” 단계에서 문제가 드러날 수 있다.</li></ul><p>출처 : <a href="http://riny.tistory.com/55" target="_blank" rel="noopener">http://riny.tistory.com/55</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1. 고상하면 언제나 득이된다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;짧게 보면 문제에 대해 진정으로 우아한 해결책에 도달하는 게 오히려 시간이 더 걸리는 것처럼 보이겠지만, 처음에만 제대로 해서 몇 시간, 며칠, 몇 달을 고생하지 않고 새로운 상황에 쉽게
      
    
    </summary>
    
      <category term="설계" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/%EC%84%A4%EA%B3%84/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="설계" scheme="http://jungha-cho.github.io/tags/%EC%84%A4%EA%B3%84/"/>
    
  </entry>
  
  <entry>
    <title>Call by Value reference</title>
    <link href="http://jungha-cho.github.io/2017/04/04/CallbyValuereference/"/>
    <id>http://jungha-cho.github.io/2017/04/04/CallbyValuereference/</id>
    <published>2017-04-04T12:19:59.000Z</published>
    <updated>2018-03-26T07:43:38.989Z</updated>
    
    <content type="html"><![CDATA[<h1>Call by value</h1><p>메소드에 값을 전달하는 것과 객체를 전달하는 것에는 큰 차이가 있다. 이것은 매우 중요하기 때문에 이전에 잠깐 언급했지만 다시한번 자세히 알아보도록 하자. 결론부터 얘기한다면 메소드로 객체를 전달할 경우 객체의 속성 값을 변경할 수 있게 된다.</p><p>다음의 예제를 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Updator &#123;</span><br><span class="line">  public void update(int count) &#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Counter &#123;ㅑ</span><br><span class="line">  int count = 0;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Counter myCounter = new Counter();</span><br><span class="line">    System.out.println(&quot;before update:&quot;+myCounter.count);</span><br><span class="line">    Updator myUpdator = new Updator();</span><br><span class="line">    myUpdator.update(myCounter.count);</span><br><span class="line">    System.out.println(&quot;after update:&quot;+myCounter.count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Counter 객체 myCounter의 count값을 Updator 객체 myUpdator의 update 함수에 전달하여 count 값을 증가시키려고 시도하는 예제이다.</p><p>실행 해 보면 다음과 같은 결과 값이 나온다.</p><p><code>before update:0</code><br><code>after update:0</code><br>인스턴스 변수 count의 값을 update메소드에 넘겨서 변경시키더라도 값에 변화가 없다. 그 이유는 이전 챕터에서 알아본 것과 같이 update 메소드는 값을 전달받았기 때문이다.</p><p>이제 예제를 다음과 같이 변경 해 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Updator &#123;</span><br><span class="line">  public void update(Counter counter) &#123;</span><br><span class="line">    counter.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Counter &#123;</span><br><span class="line">  int count = 0;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Counter myCounter = new Counter();</span><br><span class="line">    System.out.println(&quot;before update:&quot;+myCounter.count);</span><br><span class="line">    Updator myUpdator = new Updator();</span><br><span class="line">    myUpdator.update(myCounter);</span><br><span class="line">    System.out.println(&quot;after update:&quot;+myCounter.count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이전 예제와의 차이점은 update 메소드의 입력항목이다. 전에는 int count와 같이 값을 전달받았다면 지금은 Counter counter와 같이 객체를 전달받도록 변경한 것이다.</p><p>update 메소드를 호출하는 부분도 다음처럼 바뀌었다.</p><p><code>myUpdator.update(myCounter);</code><br>이제 변경된 클래스를 실행 해 보면 다음과 같은 결과가 출력된다.</p><p><code>before update:0</code><br><code>after update:1</code><br>myCounter 객체의 count 값이 1만큼 증가되었다.</p><p>※ 객체를 전달하는 것을 call by reference 라고도 하는데 사실 객체를 전달하더라도 동일한 객체를 가리키는 또다른 레퍼런스가 넘어가기 때문에 엄밀한 의미에서는 call by reference가 아닌 call by value가 맞다. 하지만 여러분은 그러한 논쟁에 휘말릴 필요없이 메소드에 객체가 넘어오면 객체의 속성 값을 변경할 수 있게 된다는 사실만 기억하도록 하자.</p><p><a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/common/Counter.java" target="_blank" rel="noopener">https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/common/Counter.java</a></p><p><a href="https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/common/Counter2.java" target="_blank" rel="noopener">https://github.com/JungHa-Cho/StandardOfJava/blob/master/StandardOfJava/src/com/tistory/devshock/common/Counter2.java</a></p><p>출처 : <a href="https://wikidocs.net/265" target="_blank" rel="noopener">https://wikidocs.net/265</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Call by value&lt;/h1&gt;
&lt;p&gt;메소드에 값을 전달하는 것과 객체를 전달하는 것에는 큰 차이가 있다. 이것은 매우 중요하기 때문에 이전에 잠깐 언급했지만 다시한번 자세히 알아보도록 하자. 결론부터 얘기한다면 메소드로 객체를 전달할 경우 
      
    
    </summary>
    
      <category term="Java" scheme="http://jungha-cho.github.io/categories/Java/"/>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/Java/%EC%9D%BC%EB%B0%98/"/>
    
    
      <category term="기초" scheme="http://jungha-cho.github.io/tags/%EA%B8%B0%EC%B4%88/"/>
    
  </entry>
  
  <entry>
    <title>2의 보수법으로 음수 표현하기</title>
    <link href="http://jungha-cho.github.io/2017/04/03/2complement/"/>
    <id>http://jungha-cho.github.io/2017/04/03/2complement/</id>
    <published>2017-04-03T14:44:59.000Z</published>
    <updated>2018-03-28T00:51:55.170Z</updated>
    
    <content type="html"><![CDATA[<p>부호있는 정수를 표현하기 위해 사용하는 2의 보수법이 얼마나 자연스럽고 아름다운지 써보려고 한다. 초딩때 프로그래밍을 처음 배울때는 그냥 외웠었는데 중딩때 쯤 이게 얼마나 아름다운 방법인지에 깨달음(ㅎㅎ)이 왔었더랬다. 2의 보수법으로 음수를 표현하는 기계적 방법(즉 알고리즘)은 아래와 같다.</p><ol><li>모든 비트를 뒤집는다. 예를 들어 양수가 <code>00100000</code> 였다면 <code>11011111</code> (1의 보수)</li><li>여기에 1을 더한다. 예를 들어 <code>11011111</code>였다면 <code>11100000</code></li></ol><p><code>00100000</code>(32)을 2의 보수법에 따라 음수로 인코딩한 값은 <code>11100000</code>(-32)이다. 대체 왜 이딴 짓을 하는걸까? 이게 뭐가 아름답나? 위의 절차를 잠깐 잊고 다른 방식으로 생각해보자.</p><h3>정수의 수직선</h3><p>초딩때 배운 수직선(perpendicular 말고 number line) 개념을 생각해보자. 선분 위에 자연수들이 늘어져있는거. 자연수가 아니라 정수를 나타내려면 0을 가운데에 그리고 왼쪽으로 음수가 나열되고, 오른쪽으로 양수가 나열되는 무한하게 긴 직선(양쪽에 화살표를 그려서 표현한다)을 그렸더랬다.</p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/9/93/Number-line.svg/1500px-Number-line.svg.png" title="Check out the Falcon 9 from SpaceX"><p>그런데 컴퓨터는 튜링 머신이 아니라서 메모리가 유한하기 때문에 무한하게 긴 직선 따위는 존재할 수 없다. 즉, 직선의 양 끝을 대충 잘라야 한다. 8비트 정수라면 -128에서 127 지점을 자르고, 16비트 정수라면 -32768에서 32767 지점을 자른다.</p><h3>인코딩</h3><p>직선의 양끝을 위와 같이 자른 다음에 직선의 양끝(-128과 127)을 이어붙여서 고리(ring)로 만들자:</p><img src="http://i.stack.imgur.com/sd9po.jpg" title="Check out the Falcon 9 from SpaceX"><p>이 그림을 보고 0에서 시작해서 시계방향으로 돌면서 이진수 값을 하나씩 매핑하면 2의 보수법을 따르는 인코딩이 완성된다. 이 그림을 떠올리면 127 다음에 -128이 나오는 이유, 0은 <code>00000000</code>인데 -1은 <code>11111111</code>인 이유, 2의 보수법 인코딩에서 사칙연산이 자연스럽게 수행되는 이유, carry flag가 어떤 경우에 켜지며 그 때의 값이 어떻게 되는지 등 온갖 것들이 자연스럽게 이해된다.  참말 아름답지 아니한가?</p><p><a href="http://www.ecogwiki.com/2%EC%9D%98_%EB%B3%B4%EC%88%98%EB%B2%95%EC%9C%BC%EB%A1%9C_%EC%9D%8C%EC%88%98_%ED%91%9C%ED%98%84%ED%95%98%EA%B8%B0" target="_blank" rel="noopener">출처</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;부호있는 정수를 표현하기 위해 사용하는 2의 보수법이 얼마나 자연스럽고 아름다운지 써보려고 한다. 초딩때 프로그래밍을 처음 배울때는 그냥 외웠었는데 중딩때 쯤 이게 얼마나 아름다운 방법인지에 깨달음(ㅎㅎ)이 왔었더랬다. 2의 보수법으로 음수를 표
      
    
    </summary>
    
      <category term="일반" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EB%B0%98/"/>
    
      <category term="비트" scheme="http://jungha-cho.github.io/categories/%EC%9D%BC%EB%B0%98/%EB%B9%84%ED%8A%B8/"/>
    
    
      <category term="보수" scheme="http://jungha-cho.github.io/tags/%EB%B3%B4%EC%88%98/"/>
    
  </entry>
  
</feed>
